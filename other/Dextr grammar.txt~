<!--
XML is used to divide this document into sections, to make manipulating it easier, but it is otherwise not formatted as XML.
-->

<!--
character types:

	illegal
	" "
	"\n"
	"\t"
	reserved (e.g. + - * /) (Also includes characters I don't want used in identifiers, even if they aren't used in any operators. They are still allowed in strings.)
	numerical
	free (any character that is not in one of the other categories)

-->

<grammar>

<token-types>
	DOCUMENT_OPEN
	DOCUMENT_CLOSE
	INDENT_OPEN
	INDENT_CLOSE
	NEWLINE
	IDENTIFIER
	INTEGER
	RATIONAL
	STRING
	KEYWORD_*
	OPERATOR_*
</token-types>

<keywords>
	in out inout
	expose import using as
	own share
	do while times for key pair from to in inclusive loop
	break continue return yield throw
	decl declfirst auto dyn
	block
	if elif else
	select case
	try catch observe finally
	and nand or nor xor xnor
	lt lte eql gte gt dne
	array chain generator
	class
	comprehension
	dictionary
	enum
	func
	generic
	interface
	impls
</keywords>

<operators><![CDATA[
	= ASSIGN
	. EXTRACT
	, COMMA
	+ ADD
	- SUBTRACT
	* MULTIPLY
	/ DIVIDE
	+= ADD_ASSIGN
	-= SUBTRACT_ASSIGN
	*= MULTIPLY_ASSIGN
	/= DIVIDE_ASSIGN
	( OPENING_PARENTHESIS
	) CLOSING_PARENTHESIS
	{ OPENING_BRACE
	} CLOSING_BRACE
	< OPENING_ANGLE_BRACKET
	> CLOSING_ANGLE_BRACKET
	[ OPENING_BOX_BRACKET
	] CLOSING_BOX_BRACKET
]]></operators>

<!--
production syntax:

	rule
		Name = ... ;
	optional (0 or 1)
		[ ... ]
	0 or more
		{ ... }
	1 or more
		... +
	grouping
		( ... )
	options
		... | ...

production syntax for SableCC:
	optional
		... ?
	0 or more
		... *
-->

<productions>

Expression
	= Simple
	| Add
	| BooleanLogic
	| DeclareFirst
	| IfElse
	| Test ;

Identifier
	= [ "$" ] FREE ;

Primary
	= Identifier
	| INTEGER
	| RATIONAL
	| STRING
	| Parenthetical ;

Parenthetical
	= "(" Expression ")" ;

Simple
	= Block
	| Call
	| ExtractMember
	| Primary ;

Call
	= Simple "(" ArgumentList ")" ;

ArgumentList
	= [ Expression { "," Expression } ] ;

ExtractMember
	= Simple "." Identifier ;

Mult
	= Simple { ("*" | "/") Simple } ;

Add
	= Mult { ("+" | "-") Mult } ;

BooleanLogic
	= Simple ("and" | "nand" | "or" | "nor" | "xor" | "xnor") Simple ;

DeclareFirst
	= DeclareFirstNormal
	| FunctionDeclaration ;

DeclareFirstNormal
	= "decl" Identifier "=" Expression ;

FunctionDeclaration
	= "func" Identifier "(" ParameterList ")" Block ;

ParameterList
	= [ Parameter { "," Parameter } ] ;

Parameter
	= Identifier ;

Block
	= BraceBlock
	| TabBlock
	| BraceTabBlock ;

//to ensure this starts and ends on the same line,
//test lineNumber of "{" and "}" tokens
//this can't be easily stated in BNF
BraceBlock
	= "{" [ Expression { "," Expression } ] "}" ;

//the tokenizer ensures a newline comes before every indent open
//the newline is declared optional to allow, e.g.: NEWLINE TabBlock
TabBlock
	= [ NEWLINE ] INDENT_OPEN { Expression NEWLINE } INDENT_CLOSE ;

BraceTabBlock
	= "{" TabBlock "}" ;

Test
	= Simple ("lt" | "lte" | "eql" | "gte" | "gt" | "dne") Simple ;

IfElse
	= "if" (Simple | Test) Block [ { "elif" (Simple | Test) Block } "else" Block ] ;

BundleDocument
	=
		DOCUMENT_OPEN
		{ "expose" Identifier | NEWLINE }
		{ "plane" STRING | NEWLINE }
		{ DeclareFirst | NEWLINE }
		DOCUMENT_CLOSE
	;

PlaneDocument
	=
		DOCUMENT_OPEN
		{ DeclareFirst | NEWLINE }
		DOCUMENT_CLOSE
	;

</productions>

</grammar>
