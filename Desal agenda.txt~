
----- DESAL SEMANTICS -----

terms
	infoset
	structure
	layout
	tree
	semantics
	data model
	abstract infoset/structure/tree/etc
	hierarchy
	leaf/terminal nodes
	tree nodes
	layout
	objects
	values
	scope
	closures

generators
yield statement
generators should be a different node from function, so it is easier to tell whether something is a generator or a function

say that a "Desal agent" is something that undertands Desal and can work with it
	parsing agent
	processing agent
	execution agent

say which nodes have scope

generics
something like C++'s template specialization
how can generics be instantiatiated with "dyn" as an interface?
	interface Array<I>
	Int[] is the same as Array<Int> is the same as Array.instantiate(Int)
	dyn[] would be what? Array<null> i.e. Array.instantiate(null) ?
	perhaps nullable type parameters, just like nullable function parameters
	interface Array<nullable I> i.e. func instantiate(nullable Interface face)

interfaces that require that (implementations of the interface also (implement other specified interfaces))
	interface Foo
		require Bar
	An implementation of Foo must also implement Bar.
	That way, a Foo can be cast to a Bar without producing a warning about an unsafe cast.
	This is different from inheritance, in that a reference to Foo can't user Bar members directly.
		Foo foo = ...
		foo.methodOfBar() //error
		(foo as Bar).methodOfBar() //known during processing to be okay

conversion methods
	interface Foo
		convert String
	Foo foo = ...
	String string = (foo to String)
	(foo sameobject string) == false, even if Foo inherited from String

const/immutable objects/values
see if const would be a good thing to add
some people are outspoken against it


multiple dispatch
	made possible with dynamic identikeys
	Do I need to say anything? I should probably mention it, although multiple dispatch should exist without specifically specifying it.
	Dyn a = ..., b = ..., c = ...
	doSomething(a, b, c) //type of a,b,c used to decide what method to call

requirements on arguments
	func doStuff(Int a where (3 < a and a < 10), Int b where (a < b))
	func doStuff(Foo foo where testArg(foo))

requirements on identifiers
	Foo foo where foo impls Bar = getFoo()
		//or: Foo|Bar foo = getFoo()
	Bar bar = foo //safe cast

adding interfaces
	//adding 2 interfaces must always produce same interface
	Foo+Bar obj = getFooBar()
	obj.propOfFoo()
	obj.propOfBar()
	Foo foo = obj
	Bar bar = obj

conversions
	Int a = 3
	Rat b = (a as Rat)

performance interfaces
	that tells the growth rate of various actions
	example: an array would implement the List interface and specify with an object that implements the performance interface that the array supports O(1) (constant time) key lookups (ie. random access)

how does the return statement work?

come up with better name for parameter directions
	in
	in-mutable
	out
	inout
	in-mutbale-out

add Reference to builtin library
or add reference types
example
	$decl Reference<Int> a = ReferenceClass<Int>(8)
	println a.val
	a.val = 936
	println a.val
add WeakReference to builtin library

nullable in/inout parameters
	it must be explicit, and not by default
	func foo(null Int value) ...
		...

consider: objects can't be immutable, but values can
implementing const/immutable versions of interfaces that aren't normally const/immutable
	Q: should the mutable version of the interface inherit from the immutable one?
immutable object references can only be cast to immutable object references
Q: how to cast a mutable type to an immutable type?
immutability and generics need much more specing
encouragement:
	mode where any dynamic typing produces a warning, like for/when
	Dyn identifiers
	generics use methods not defined by Desal (eg add, add!)
	object identifiers are cast to interfaces that are not inherited by the previous interface
the "!" part of identifiers is syntax
	it should not be a part of Desal semantics
	mutator methods should only be a way for Dextr to specify that the method produces mutations
	in Desal, there should be some other way
	it shouldn't be part of the identifiers!
adding interfaces
make object identifiers and function identifiers more similar
	make sure functions can be boud to function identifiers in child scopes
identifier declarations
	take place before scope is executed
	binding may also occur here
	differentiate between bindings that happen later
	warn when identifier is referenced before being bound to a value
		//okay - bound at decl time
		Int a = b * 2
		def Int b = 5
		//produce warning - not bound yet
		Int a = b * 2
		Int b = 5

const function identikeys
	can't have further functions bound
		rational: call on that identifier may change when a function is added that requires fewer casts
	can't unbind functions
		rational: call on identifiers that were valid may become invalid
Decide how multiple functions could be bound to a const function identikey.

unbinding functions
	(from non-const identikeys only)

decide if interfaces can be sealed/closed
	* all interfaces are implementable, even enums, function interfaces and Object
	* If there are multiple interfaces user code can't implement, create a section that refers to all of them.

binding to nth parameters
decl func doStuff( Int a, Rat b, String c ) {...}
decl f = doStuff:( 3 = "bar" )


spec out the identikeys created by parameters


create an "expression-output" node that tells what kind of values can be given when an expression node is evaluated
like identikeys and function calls
expression-output ::=
	boolean nullable
	boolean automatic
	? expression interface
	? expression test
merge dynamic and strict identikeys
identikey-type ::=
	identikey-category (function/single/in-param/)
	type
	boolean constant
automatic means there's a static type, but it should be determine by the agent during processing
if it can't be determined during processing, no interface restriction is placed on it and an error is output
func foo( Int i where smToLg(5, i, 20) ) { ... }
(parameter
	(identifier i)
	(expression-output
		(.nullable false)
		(.automatic false)
		(identifier.interface Int)
		(call.test
			(identifier.value smToLg)
			(integer.argument 5)
			(idenifier.argument i)
			(integer.argument 20)))
	(block ...))


give block nodes an optional expression-output member
	if given, the block evaluates to the contents of an "eval" node that evaluates the parent to the given value
		like return, but more general
decl Int v = Int {
	if a < b : eval 5
	eval 9
}
decl foo = * {
	if a < b : eval getDyn()
	eval getDyn()
}


spec out identifiers
list of 1+ Unicode code points
agents must support code points outside the BMP
no reserved characters, control characters or whitespace
what is reserved/control/whitespace is not defined, but should include:
surrogate pairs
chars used for BOM
null, bell
space, tab, vertical tab, form feed, carriage return, paragraph separator, line separator, nell
can't start with 0-9 \/`[]~!@#$%^&*(){?+ etc
can't contain ( ) . : - * / + ' "
case sensitive, though agents are encouraged to give suggestions of differently-cased identifiers when an identikey/property/method is not found


remove the dynCall method from the Function interface
functions can already be called dynamically. This method is not needed and only gets in the way.




after adding opacity information, put the call node in a new category:
"sometimes executable, sometimes evaluatable"

If the opacity information for a function/method specifies that calling the function has no side effects, then the function/method can't be in a call that is executed. If this is determined at runtime, a warning is output and no exception is produced, but during processing, this results in an error.

Whether the function is evaluatable depends on whether the function returns anything.



instructions for execution/evaluation assume no processing has been done
	* involve runtime checks and throwing exceptions	
define processing as:
	* find code that can produce errors during execution/evaluation (besides explict throw nodes)
		- when found, alert of the error and don't run the program
	* notice that:
		- the outcome of runtime checks can sometimes be determined during processing
		- agents are allowed to change or do anything as they please as long as the results stay the same (make sure this is speced somewhere and linked to from here)
		- therefore, agents can remove runtime checks where the outcome can be deteremined during processing, as it it has no result on the outcome
		- say that agents should remove such runtime checks



warning supression
$decl ? foo = doSomething() :suppress "always null"

warning-supress ::=
	expression
	+ string

string "all" suppresses all warnings

create section with some warnings
say that agents are encouraged to create additional warnings

warnings
	"always null" - a node that never produces a value when executed, is being used as an expression - e.g. the output is assigned to something or passed as an argument


spec out phrases/terms:
	using a node as an expression
	using a node as a statement
	expression
	statement
	execution
	evaluation




spec out partial template specialization
come up with better name (partial generics specialization?)

ensure that substition failure is not an error for generics
this page explains that:
http://boost.org/libs/utility/enable_if.html



define complex string literals and string formatting
"x: ${x}"
"x: %" % x
http://boost.org/libs/format/doc/format.html
http://docs.python.org/lib/typesseq-strings.html
consider making it an island instead, like regular expressions


Desal supports some dynamic features, but is in several ways a very static language.
dynamic:
	dynamic typing (a.k.a. duck typing)
	dynamic creation of interfaces, classes, and interface implementations
static:
	Scope formulas/trees (a tree of scopes and identikeys) can always be entirely known before runtime. Identikeys cannot be declared conditionally.
	Members of interfaces/classes/values cannot be added or removed.
	An "eval" command could not be supported in Desal without major changes and/or extreme limitations.


define how assignment to namespaced identikeys can occur
possibility:
	assign ::=
		* identifier namespaces
		identifier identikey name
		expression value
possibility:
	assign ::=
		namespaced-identikey
		expression value
	namespaced-identikey ::=
		* identifier namespaces
		identifier identikey name
possibility:
	assign ::=
		identifier|namespace-identikey
		expression value
	namespaced-identikey ::=
		+ identifier namespaces
		identifier identikey name



remove all instances of "evaluate" from the Desal semantics spec (there are a lot)



define how a class's private value is used to implement an interface for the class

class Foo {
	Bar _bar
	
	...
	
	impl Bar {
		//use of Bar members goes to _bar unless overridden
		delegate _bar
		
		//override one of Bar's members
		func doSomething() {...}
	}
}



consider merging planes and namespaces
remember to keep semantics and representation separate
	but also keep performance in mind (compiling separate files/chunks individually)
make a list of the purposes of each and what each is good and bad at
	


define a "function" namespace of the standard library

map, fold, anyTrue?, forEach, filter, everyTrue?, etc


func collectWhile( producer, test ) {
	List list = List()
	while test() : list << producer()
	return list
}

list = [] # start with empty list and fill it
while Something :
	list.append( next_thing() )

list = collectWhile( next_thing, ||Something )

string = '' # start with empty string and fill it
while Something:
	string = string + next_token() 

string = collectWhile( next_thing, ||Something )



spec that the interface of a value produced by a function identikey is the same as addition of the function interfaces

$declfunc foo = $func()Int {...}
$declfunc foo = $func(Int)Int {...}
$declfunc foo = $func(Int,Int)Int {...}

$decl fooValue = foo
activeInterface(fooValue) ==
	( $func()Int + $func(Int)Int + $func(Int,Int)Int ) //true




Define how the automatic iteration loops work. Generators? Iterators? Either/or/both?



Say that instructions in spec for how to do stuff are intended to be understandable by people, and not intended to have full mathematical or other type of riguor. Or something like that. Basically, if instructions are understandable to people, they're good enough, even if they make no sense in a mathematical way.



An agent is allowed to refuse to handle a Desal bundle if the agent can determine that any of the nodes, when executed, would throw an exception (besides the throw node). For example:

decl Int foo = 3
println fooo

If "fooo" was not defined, the agent would have reason to refuse to handle the bundle. "Handling" may refer to executing the bundle or translating it, e.g. to machine code, bytecode, or another language.

Once an agent has begun execution, such reasons are not valid reasons for not continuing execution. Execution must continue normally as described.



----- Dextr

assign a copy
$decl Int a = b //no copy
$decl Int c := d //copy
translates to:
$decl Int c = $copy d
translates to:
(declaration-assign
	(identifier.interface Int)
	(identifier.name c)
	(copy.value
		(identifier.value d)))

possible syntax for nullability:
	"*" for any interface and not nullable
	"?" for any interface and nullable
	"Type" for a particular interface and not nullable
	"Type ?" for a particular interface and nullable
decl Int ? a = null
decl ? b = null
note: for this, you'd have to declare that identifiers can't start with a "?", which would be good anyway for conditional expressions (a ? b : c)


-----


See how ML and Haskell handle returning multiple values.




Desal:
	try {
		...
	}
	catch( Exception e where e impls InstantiationException or e impls IllegalAccessException ) {
		...
	}
Try to make this more compact. For example, I think C# has this:
catch( Exception : InstantiationException, IllegalAccessException e )



instead of
	$try {
		doStuff()
	}
	$catch FooError e {
		errors.logError(e)
		$throw e
	}
add something to make it cleaner
	$try {
		doStuff()
	}
	$notice FooError e {
		logger.logError(e)
	}
$notice blocks can't return or evaluate. However, a try-catch node with a notice block can still evaluate, since whenever execution goes into the notice block, the exception that took it there will raise up out of the node so that it wouldn't evaluate anyway. Also spec that a try-catch node can still evaluate if some $catch blocks throw errors instead of evaluating.
	$decl foo = {
		$eval doStuff()
	}
	$catch XmlError e {
		$throw ParseError(e)
	}


keep in mind: Code is usually read several more times than it is written. Therefore, when choosing between something that is easier to write but harder to read, or something that is harder to write but easier to read, chose the one that is harder to write but easier to read.

possibly spec out common conventions, at least for builtin library
	Interface
	returnsBoolean?
	FooFactory / CFoo / ClassFoo
	other

ensure Desal has all features of lambda calculus

add processing step to Desal
create ScopeFormulas from declarations
check all interfaces to ensure correctness

add to rationale section
	why lang?
	why split between semantics and syntax?
	why not use technology XXX (like ASN.1, LaTeX, etc)

rename Desal Interpreter 001 to Desal Agent 001

spec out function identikeys that can refer to functions with different return types
spec out methods with the same name that have different return types

write style guidelines for specs
separate (what stuff *should* do) from (what stuff should *not* do)


Every class node's interface implementations should be reduced to a single interface implemenatation of the interface that is produced by adding together the interfaces of the provided interface implementations.
class
	faceimpl Foo
	faceimpl Bar
__priv = Foo + Bar
class
	faceimpl __priv


figure out how to create closed/sealed interfaces -- interfaces that are inherited already, but can't be inherited any more
example: a Node interface that is inherited by Tree and Leaf interfaces, but no others
(decl-first
	(identifier.name Node)
	(interface
		/* ... */
		(boolean.sealed true)))
(decl-first
	(identifier.name Tree)
	(interface
		/* ... */
		(identifer.inheritee Node)))
(decl-first
	(identifier.name Leaf)
	(interface
		/* ... */
		(identifer.inheritee Node)))
Note: For global identikeys, need to prevent other planes from inheriting interface.


spec out creating objects without classes (singletons)

Look at Java's way of handling multiple source files and libraries:
	import java.util.Random;

Spec out binding namespaces to identifers

write up rational for allowing classes to implement the same interface multiple times in different ways

test how other languages treat it
	interface Base
	interface Parent1 : Base
	interface Parent2 : Base
	class {
		Parent1 {...}
		Parent2 {...}
	}


many important libraries should be accessible from Desal Implementation 001
	standard libraries
		Java (see Mozilla's Java<->JavaScript bridge)
		Perl
		PHP
		Python
		Ruby
		Visual Basic (not VB.NET)
	component models
		Bonobo
		CLI (Common Language Infrastructure)
		COM
			ActiveX
			OLE
		CORBA
		D-Bus
		DCOP
		KPart
		Kross
		XPCOM
	libraries with bindings
		GObject
			maybe other stuff from GLib
		GTK
		Mono/DotGNU/.NET
		Qt
		WxWidgets

NOTE: The interfaces of most of these types will have to be "sealed" or "closed" or something. If a library function takes an instance of the Foo class, Desal code cannot create another implementation of the same interface and send an instance of that in. This is extremely bad for Desal, and has huge repercussions. It means that Desal agents cannot rely on preexisting libraries. Instead, new libraries will have to be created that focus on open interfaces and avoid sealed interfaces. Previously, I thought Desal could save a lot of time and effort by using the preexisting large and complex libraries, but I now understand that I was wrong. Desal will need brand new libraries.

Possible solution: Automatically translate the implementation of these libraries into Desal. That way, the libraries will support open interfaces, without having to be completely rewritten.




implementation:
	when handling a Desible element, mark it as handled
	after parsing Desible, go through every element
	throw error or warn if any of the elements haven't been handled

divide expression nodes into only-expression nodes and dual expression/statement nodes
dual expression/statement nodes "do something" when executed
only-expression nodes cannot be executed


Q: Why are namespaces not values? Everything else is. Interfaces, classes, functions, and generics of them are all values, but namespaces aren't?
Write up rationale. Create for/against list.


spec out representing numbers in bases besides base 10
should NOT be a part of semantics - only representations
Dextr:
	8x123 (base 8)
	0xF00 (base 16)
	16xDeAd (base 16)
	2x110101001010 (base 2)
	1234567890 (base 10)
	10x123 (base 10)
Desible:
	<integer>123</integer> (base 10)
	<integer base="8">444</integer> (base 8)
	<integer base="2">10101000101</integer>
	<integer base="10">567</integer>
	<integer base="16">CAFE</integer>

similarly to above:
	<string escaped="true">null: \000000</string>
	<string escaped="true">one slash: \\</string>
	<string escaped="false">two slashes: \\</string>
	<string>two slashes: \\</string>


//declaration:
func Rat square

//declaration:
def func square(Rat n) Rat {
	return n * 2
}

//not declaration:
square = func(Rat n) Rat {
	return n * 2
}


impl: add "immutable" attribute to ObjectReference class

implement prevalent identifiers
	func bindIdent(string ident)
		if identIsPrevalent(ident)
			throw error
		...
	func identIsPrevalent(string ident)
		if parent == null
			return prevalentIdents.contains(ident)
		return top.identIsPrevalent(ident)
	top get
		if parent == null
			return this
		return parent

ensure this is possible:
	take a value of any type and wrap it so you get 2 values:
		* a value that implements the same interface
		* a value used for event registration
	Int a = 8
	Listener l
	(l, a) = wrap(a)
	l.addMethodCallListener("add", func(event){...})
	Int b = a + 80 //listener gets called

interface Int
	Bool negative?
	Bool positive?

interface Interface
	func add(Interface) Interface

search for XXX in all specs and work on fixing problems

check Desal specs and implementation into version control
look at version control systems

lookup license of GPL
lookup extremely permissive licenses
see about making Desal Spec license more permissive

make sure my Desal implementation isn't affecting the spec in negative ways
It's okay for them to differ, even greatly!

emphasize that the rational for creating this language was to create a better separation between interface and implementation

further separate interface from implementation
	licensing libraries
		It should be easy to separate a public library interface from everything else and license it under a permissive license, while licensing the implementation of the library under a copyleft license.
		problem: Enum values must be part of the public library interface.
	loading libraries
		Should be possible to specify a library interface (and version) and get an implementation of it, both for static and dynamic linking. Should also be possible to specify several implementations to try first. If none of the implementations are available, programmer should be able to prevent a different implementation from being used.

spec out dynamically loading a library as a meta object

Desal implementation
	divide into these parts:
		library interface
		library implementation
		command line wrapper around library
		GUI wrapper around library

Desal implementation defines a way of declaring a class so bindings can be created automatically
make class node and children like that
copy the syntax/format

spec out enums
	are they even possible with all this interface business?
	see how enums work in other languages (especially highly OOP ones)
should Bool be an enum?
Bool could also be an interface that user code could not implement, and true and false the only implementations.

many things that should be function identifiers look like object identifiers
make it clear they are function identifiers, not obect identfiers

create specification for ASN.1 representation (Desasn) of Desal Semantics
modify Desible specification so it uses ASN.1 representation

need some way to access iterators (or functionality of iterators) in loops
	clean, easy, simple for loops that need it
	not show up for loops that don't need it


$decl foo =
if a : "text"
else : 12345

The if-else node shouldn't have a type of "dyn". Instead, it should have a type of something like "String or Int" or perhaps something like "dyn o where o impls String or o impls Int".


define a few things for the examples in the spec
	like what comments look like
add lots more comments to describe what's going on


---




make list of significant features
	specifications
		permissive license
	working implementation
		GPL/BSD license
		planned future: access to many libraries
	syntax separated from semantics
		no reserved words in semantics
	objects only refered to through interfaces
	plannned future: built-in ways of specifying opacity/purity
	mixed static and dynamic typing
	number literals are BigNums
	better string abstractions than many languages provide
		length doesn't count astral characters twice like e.g. Java and JavaScript do
	planned future: good parallel programming support
	allows global functions and objects
		like C++ and unlike Java/C#
	non-nullable parameters
		sorely needed in C#
	no value types (only reference types)
		distinction causes big problems C#


----- IDE/AGENT GUIDELINES

option: warn when finding closures

define syntax highling for strings where spaces are colored and spaces next to each other are colored differently

spec out that IDEs should have option to show default values for function calls
	when a function has a default value and a call to that function doesn't specify an argument,
	show the default argument as if it was specified, perhaps grayed out or colored differently or boxed or something


----- DESAL AGENT/IMPLEMENTATION 001

be sure that nodes which should have scope, do

If an object is not a function, and it's called like a function, you want to get the same error every time. This means every implementation of IObject should not be handling being called like a function, because each implementation of IObject may handle the error differently. Also, DRY.


Many things in Desal are just implementations of interfaces.
Because client code can implement these interfaces,
there often needs to be:
	* an interface for the item
	* a class for native items
		created manually in C# or by a construct in client
		ex: wrapping a C# int
		ex: an integer node
	* a class for items created manually by client
		ex: implementing the Int interface
	* a class to make items appear as objects
		though items created manually by client are already objects
For example:
	* IInterface
		a Desal interface
	* Interface
		a Desal interface created:
			* manually in C#
			* through an "interface" Desal node
	* InterfaceFromValue
		a Desal interface created by client code implementing Interface
	* InterfaceWrapper
		to make an Interface look like a Desal object

For functions, there's also the NativeFunction class, which makes
a C# function look like a Desal function.

The conversion functions (*FromValue, *Wrapper) are factories that
just return the unwrapped object when possible.


PROBLEM: Dictionaries are used for interface implementations, but multiple methods can be bound to the same identifier! This means we need something like multi_map from C++, or we need to bind identifiers to a list of functions.



----- NOTES

tree -
	1) a graphical representation of a hierachy
	2) a computer data structure
hierarchy -
	objects ranked so that every one but the topmost is subordinate to a specified one above it

hierarchies are abstract while trees are concrete


ultimate optimizer test:
	replace slow sorting algorithm with fast sorting algorithm
	bubble sort -> quick/heap/merge sort


lookup modern opcodes (MMX, SSE, etc) and see if any describe actions that can't be explicitly stated with Desal
	if so, add stuff to Desal to support the opcodes


define memory representation
	for machine code implementations to speak to each other


