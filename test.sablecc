
package Dextr.SableCC;

Tokens
DOCUMENT_OPEN
DOCUMENT_CLOSE
INDENT_OPEN
INDENT_CLOSE
NEWLINE
IDENTIFIER
INTEGER
RATIONAL
STRING
KEYWORD_IN = "in"
KEYWORD_OUT = "out"
KEYWORD_INOUT = "inout"
KEYWORD_EXPOSE = "expose"
KEYWORD_IMPORT = "import"
KEYWORD_USING = "using"
KEYWORD_AS = "as"
KEYWORD_OWN = "own"
KEYWORD_SHARE = "share"
KEYWORD_DO = "do"
KEYWORD_WHILE = "while"
KEYWORD_TIMES = "times"
KEYWORD_FOR = "for"
KEYWORD_KEY = "key"
KEYWORD_PAIR = "pair"
KEYWORD_FROM = "from"
KEYWORD_TO = "to"
KEYWORD_IN = "in"
KEYWORD_INCLUSIVE = "inclusive"
KEYWORD_LOOP = "loop"
KEYWORD_BREAK = "break"
KEYWORD_CONTINUE = "continue"
KEYWORD_RETURN = "return"
KEYWORD_YIELD = "yield"
KEYWORD_THROW = "throw"
KEYWORD_DECL = "decl"
KEYWORD_DECLFIRST = "declfirst"
KEYWORD_AUTO = "auto"
KEYWORD_DYN = "dyn"
KEYWORD_BLOCK = "block"
KEYWORD_IF = "if"
KEYWORD_ELIF = "elif"
KEYWORD_ELSE = "else"
KEYWORD_SELECT = "select"
KEYWORD_CASE = "case"
KEYWORD_TRY = "try"
KEYWORD_CATCH = "catch"
KEYWORD_OBSERVE = "observe"
KEYWORD_FINALLY = "finally"
KEYWORD_AND = "and"
KEYWORD_NAND = "nand"
KEYWORD_OR = "or"
KEYWORD_NOR = "nor"
KEYWORD_XOR = "xor"
KEYWORD_XNOR = "xnor"
KEYWORD_LT = "lt"
KEYWORD_LTE = "lte"
KEYWORD_EQL = "eql"
KEYWORD_GTE = "gte"
KEYWORD_GT = "gt"
KEYWORD_DNE = "dne"
KEYWORD_ARRAY = "array"
KEYWORD_CHAIN = "chain"
KEYWORD_GENERATOR = "generator"
KEYWORD_CLASS = "class"
KEYWORD_COMPREHENSION = "comprehension"
KEYWORD_DICTIONARY = "dictionary"
KEYWORD_ENUM = "enum"
KEYWORD_FUNC = "func"
KEYWORD_GENERIC = "generic"
KEYWORD_INTERFACE = "interface"
KEYWORD_IMPLS = "impls"

Productions


Expression
	= Simple
	| Add
	| BooleanLogic
	| DeclareFirst
	| IfElse
	| Test ;

Identifier
	= ( "$" )? FREE ;

Primary
	= Identifier
	| INTEGER
	| RATIONAL
	| STRING
	| Parenthetical ;

Parenthetical
	= "(" Expression ")" ;

Simple
	= Block
	| Call
	| ExtractMember
	| Primary ;

Call
	= Simple "(" ArgumentList ")" ;

ArgumentList
	= ( Expression ( "," Expression )* )? ;

ExtractMember
	= Simple "." Identifier ;

Mult
	= Simple ( ("*" | "/") Simple )* ;

Add
	= Mult ( ("+" | "-") Mult )* ;

BooleanLogic
	= Simple ("and" | "nand" | "or" | "nor" | "xor" | "xnor") Simple ;

DeclareFirst
	= DeclareFirstNormal
	| FunctionDeclaration ;

DeclareFirstNormal
	= "decl" Identifier "=" Expression ;

FunctionDeclaration
	= "func" Identifier "(" ParameterList ")" Block ;

ParameterList
	= ( Parameter ( "," Parameter )* )? ;

Parameter
	= Identifier ;

Block
	= BraceBlock
	| TabBlock
	| BraceTabBlock ;

//to ensure this starts and ends on the same line,
//test lineNumber of "{" and "}" tokens
//this can't be easily stated in BNF
BraceBlock
	= "{" ( Expression ( "," Expression )* )? "}" ;

//the tokenizer ensures a newline comes before every indent open
//the newline is declared optional to allow, e.g.: NEWLINE TabBlock
TabBlock
	= ( NEWLINE )? INDENT_OPEN ( Expression NEWLINE )* INDENT_CLOSE ;

BraceTabBlock
	= "{" TabBlock "}" ;

Test
	= Simple ("lt" | "lte" | "eql" | "gte" | "gt" | "dne") Simple ;

IfElse
	= "if" (Simple | Test) Block ( ( "elif" (Simple | Test) Block )* "else" Block )? ;

BundleDocument
	=
		DOCUMENT_OPEN
		( "expose" Identifier | NEWLINE )*
		( "plane" STRING | NEWLINE )*
		( DeclareFirst | NEWLINE )*
		DOCUMENT_CLOSE
	;

PlaneDocument
	=
		DOCUMENT_OPEN
		( DeclareFirst | NEWLINE )*
		DOCUMENT_CLOSE
	;



