
//This file was created programmatically, so
//DO NOT EDIT THIS FILE DIRECTLY.

Package Dextr.Sablecc;

Helpers
	char = [0..0x10FFFF] ;
	illegal = [0..8] ;
	legal = [char - illegal] ;
	reserved = [[[[[[[[[[[[[[[[[[[[[
		0x09 + //tab
		0x0A ]+ //linefeed
		0x0D ]+ //carriage return
		0x20 ]+ //space
		'+' ]+
		'-' ]+
		'*' ]+
		'/' ]+
		'.' ]+
		',' ]+
		'=' ]+
		'"' ]+
		''' ]+
		'#' ]+
		'(' ]+
		')' ]+
		'{' ]+
		'}' ]+
		'<' ]+
		'>' ]+
		'[' ]+
		']' ] ;
	newline_chars = [0x0A + 0x0D] ;
	legalline = [legal - newline_chars] ;
	numerical = ['0' + ['1'..'9']] ;
	free = [[legal - reserved] - numerical] ;

Tokens
	
	operator_minus = '-' ;
	operator_plus = '+' ;
	operator_closing_parenthesis = ')' ;
	keyword_lt = 'lt' ;
	keyword_for = 'for' ;
	keyword_or = 'or' ;
	keyword_dyn = 'dyn' ;
	operator_times = '*' ;
	keyword_dne = 'dne' ;
	keyword_nand = 'nand' ;
	keyword_gte = 'gte' ;
	keyword_plane = 'plane' ;
	operator_closing_brace = '}' ;
	keyword_from = 'from' ;
	keyword_else = 'else' ;
	keyword_elif = 'elif' ;
	operator_divide = '/' ;
	keyword_declfirst = 'declfirst' ;
	keyword_gt = 'gt' ;
	operator_opening_brace = '{' ;
	keyword_if = 'if' ;
	operator_opening_parenthesis = '(' ;
	keyword_void = 'void' ;
	keyword_and = 'and' ;
	keyword_xnor = 'xnor' ;
	keyword_xor = 'xor' ;
	keyword_nor = 'nor' ;
	keyword_eql = 'eql' ;
	keyword_to = 'to' ;
	operator_assign = '=' ;
	keyword_decl = 'decl' ;
	keyword_func = 'func' ;
	keyword_lte = 'lte' ;
	keyword_expose = 'expose' ;
	operator_extract_member = '.' ;
	operator_comma = ',' ;
//stage 1 and stage 2
	newline = newline_chars ;
	identifier = free (free | numerical)* ;
	integer = numerical+ ;
	rational = numerical+ '.' numerical+ ;
	string = '"' [[free + reserved] - '"']* '"' ;
	
	//stage 1 only -- removed by hand-written code
	tab = 0x09 ;
	space = 0x20 ;
	line_comment
		= '/*' [legalline - '*']+ '*'+ ([[legalline - '*'] - '/'] [legalline - '*']* '*'+)* '/'
		| '#' legalline* ;
	multiline_comment = '/*' [legal - '*']+ '*'+ ([[legal - '*'] - '/'] [legal - '*']* '*'+)* '/' ;
	
	//stage 2 only -- inserted by hand-written code
	indent_open = 'xxxIndentOpen' ;
	indent_close = 'xxxIndentClose' ;

Productions


document
	=  [a]:newline? expose* documentinside  [b]:newline? ;
expose
	= keyword_expose identifier newline ;
documentinside
	= {a}  planereference+
	| {b}  declarefirstlist
	| {c}  planereference+ declarefirstlist ;
planereference
	= keyword_plane string newline ;
declarefirstlist
	= {a}  declarefirst
	| {b}  declarefirstlist newline declarefirst ;

add
	= {a}  mult
	| {b}  add operator_plus mult
	| {c}  add operator_minus mult ;

argumentlist
	= {a}  expression
	| {b}  argumentlist operator_comma expression ;

block
	= {a}  braceblock
	| {b}  tabblock
	| {c}  bracetabblock ;

braceblock
	= operator_opening_brace braceblockinside? operator_closing_brace ;
	
/*xxx
braceblockinside is currently very limited because the original
was ambiguous with bracetabblock.
to fix, need to define a lineexpression production that
cannot contain newlines, and use it in place of expression.
braceblockinside
	= {a}  expression
	| {b}  braceblockinside operator_comma expression ;
*/
braceblockinside
	= primary ;

//the tokenizer ensures a newline comes before every indent open
//the newline is declared optional to allow, e.g. newline tabblock
tabblock
	=  [a]:newline? indent_open tabblockinside?  [b]:newline? indent_close ;
tabblockinside
	= {a}  expression
	| {b}  tabblockinside newline expression ;

bracetabblock
	= operator_opening_brace  [a]:newline tabblock  [b]:newline operator_closing_brace ;

booleanlogic
	=  [a]:simple booleanfunction  [b]:simple ;
booleanfunction
	= {a}  keyword_and
	| {b}  keyword_nand
	| {c}  keyword_or
	| {d}  keyword_nor
	| {e}  keyword_xor
	| {f}  keyword_xnor ;

call
	= simple operator_opening_parenthesis argumentlist? operator_closing_parenthesis ;

declareassign
	= keyword_decl simple? identifier operator_assign expression ;

declareempty
	= keyword_decl simple? identifier ;

declarefirst
	= {a}  declarefirstnormal
	| {b}  functiondeclaration ;

declarefirstnormal
	= keyword_declfirst identifier operator_assign expression ;

expression
	= {a}  add
	| {b}  booleanlogic
	| {c}  declareassign
	| {d}  declareempty
	| {e}  declarefirst
	| {f}  forrange
	| {g}  function
	| {h}  ifelse
	| {i}  test ;

extractmember
	= simple operator_extract_member identifier ;

forrange
	= keyword_for identifier keyword_from  [a]:simple keyword_to  [b]:simple block ;

function
	= keyword_func operator_opening_parenthesis operator_closing_parenthesis type? block ;
type
	= {a}  keyword_dyn
	| {b}  keyword_void ;

functiondeclaration
	= keyword_func identifier operator_opening_parenthesis parameterlist? operator_closing_parenthesis block ;

ifelse
	= if elif? else? ;
ifexpr
	= {a}  simple
	| {b}  test ;
if
	= keyword_if ifexpr block ;
elif
	= {a}  keyword_elif ifexpr block
	| {b}  elif keyword_elif ifexpr block ;
else
	= keyword_else block ;

mult
	= {a}  simple
	| {b}   [a]:simple operator_times  [b]:simple
	| {c}   [a]:simple operator_divide  [b]:simple ;

parameter
	= identifier ;

parameterlist
	= {a}  parameter
	| {b}  parameterlist operator_comma parameter ;

parenthetical
	= operator_opening_parenthesis expression newline? operator_closing_parenthesis ;

primary
	= {a}  identifier
	| {b}  integer
	| {c}  rational
	| {d}  string
	| {e}  parenthetical ;

simple
	= {a}  block
	| {b}  call
	| {c}  extractmember
	| {d}  primary ;

test
	=  [a]:simple comparisonfunction  [b]:simple ;
comparisonfunction
	= {a}  keyword_lt
	| {b}  keyword_lte
	| {c}  keyword_eql
	| {d}  keyword_gte
	| {e}  keyword_gt
	| {f}  keyword_dne ;


