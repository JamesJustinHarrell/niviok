2008-07-07
	func active`face
		( ?any -> Interface )
	func is?
		( ?any, Type -> Bool )
	func can`cast? #also consider "impls?"
		( ?any, Type -> Bool )
	func can`downcast? #also consider "downimpls?" and "dimpls?"
		( ?any, Type -> Bool )
	func cast
		( ?any, Type -> ?any )
	func downcast
		( ?any, Type -> ?any )
	func rootcast
		( ?any -> ?any )
	func same? #formerly "isSameObject?"
		( ?any, ?any -> Bool )
	func equal? #different from calling .equals? method since it works for nulls
		( ?any, ?any -> Bool )

2008-07-04
	Desible serializer adds whitespace in <string/> elements
	e.g. "" serialized to:
								<string label="value">
								</string>
	which would then be parsed very differently.
	It may be enough just to add xml:whitespace="pre" to string elements before serializing.
	Otherwise, I won't be able to use pretty printing.
	This problem only seems to occur with empty strings.

2008-07-03
	consider this:
		var foo bar
	is that equivalent to this:
		var foo = bar
	or this:
		var foo bar = null

2008-07-03
	Consider the case of two declare-first nodes in the same scope both declaring a function with the same name, but different types.
	func ( Int -> Int ) foo = getFoo(Int)
	func ( String -> String ) foo = getFoo(String)
	The current algorithm is pretty fucked up when it comes to this area.

2008-07-03
	func break { throw Break() }
	func continue { throw Continue() }
	func return { throw Return() }
	func return { x | throw Return x }
	Break, Continue, and Return are interfaces that inherit from RareOccurence
		they also have associated constructors
	rename SpecialCase to RareOccurrence
	rationale for having more than one Break/Continue object: agent will add stack info as exception raises through stack

2008-06-14
	Need to replace "identikey" with "scidentre" in specs and in comments in Acrid.

2008-06-12
	idea: merge GenericFunction and GenericInterface into e.g. Generic
	example use case: Array
		const Array<Int> numbers = Array<Int>(12, 34, 56)
	activeInterface( Array<Int> ) == Interface + ( params Int -> Array<Int> )

2008-05-30
	make plans for "Browser REPL"
	Niviok interpreter that runs in the browser
		does not send code back to server for execution
	ability to switch between representations, to see how the same code looks in various representations
	determine how to implement
		various types of bytecode can be translated into JavaScript to run in the browser
		find out which ones can
		CIL, PIR, LLVM bytecode, Java bytecode
	implemenation should try to share most of the code with the desktop implementation

2008-05-25
	consider changing "identikey" to something not derived from "identifier", like "holder"
	rationale: the same identikey may be referred to from identifiers in different scopes, especially with namespaces
	consider the effects of the expose node, especially on "outer" namespaces
	compound[
		var num = 123
		compound[
			var num = 456
			compound[
				expose outer:outer
				num = 789
			]
			println(num) #456
		]
		println(num) #789
	]


Need to consider a standalone library module that is not part of a larger library.
If it defines a standard namespace, how should it do so?
There are two obvious ways.

How to deal with multi-threading and modules?
Some modules may support multi-threading, and allow multiple programs to make calls into the library at the same time.
Other modules may not support multi-threading.
Should modules be able to declare whether they are thread safe?



BELOW: REALLY OLD STUFF (pre 2008-05-25)

----- DESAL SEMANTICS -----

terms
	infoset
	structure
	layout
	tree
	semantics
	data model
	abstract infoset/structure/tree/etc
	hierarchy
	leaf/terminal nodes
	tree nodes
	layout
	objects
	values
	scope
	closures

generators
yield statement
generators should be a different node from function, so it is easier to tell whether something is a generator or a function

say that a "Desal agent" is something that undertands Desal and can work with it
	parsing agent
	processing agent
	execution agent

say which nodes have scope

generics
something like C++'s template specialization
how can generics be instantiatiated with "dyn" as an interface?
	interface Array<I>
	Int[] is the same as Array<Int> is the same as Array.instantiate(Int)
	dyn[] would be what? Array<null> i.e. Array.instantiate(null) ?
	perhaps nullable type parameters, just like nullable function parameters
	interface Array<nullable I> i.e. func instantiate(nullable Interface face)

interfaces that require that (implementations of the interface also (implement other specified interfaces))
	interface Foo
		require Bar
	An implementation of Foo must also implement Bar.
	That way, a Foo can be cast to a Bar without producing a warning about an unsafe cast.
	This is different from inheritance, in that a reference to Foo can't user Bar members directly.
		Foo foo = ...
		foo.methodOfBar() //error
		(foo as Bar).methodOfBar() //known during processing to be okay

conversion methods
	interface Foo
		convert String
	Foo foo = ...
	String string = (foo to String)
	(foo sameobject string) == false, even if Foo inherited from String

const/immutable objects/values
see if const would be a good thing to add
some people are outspoken against it


multiple dispatch
	made possible with dynamic identikeys
	Do I need to say anything? I should probably mention it, although multiple dispatch should exist without specifically specifying it.
	Dyn a = ..., b = ..., c = ...
	doSomething(a, b, c) //type of a,b,c used to decide what method to call

requirements on arguments
	func doStuff(Int a where (3 < a and a < 10), Int b where (a < b))
	func doStuff(Foo foo where testArg(foo))

requirements on identifiers
	Foo foo where foo impls Bar = getFoo()
		//or: Foo|Bar foo = getFoo()
	Bar bar = foo //safe cast

adding interfaces
	//adding 2 interfaces must always produce same interface
	Foo+Bar obj = getFooBar()
	obj.propOfFoo()
	obj.propOfBar()
	Foo foo = obj
	Bar bar = obj

conversions
	Int a = 3
	Rat b = (a as Rat)

performance interfaces
	that tells the growth rate of various actions
	example: an array would implement the List interface and specify with an object that implements the performance interface that the array supports O(1) (constant time) key lookups (ie. random access)

how does the return statement work?

come up with better name for parameter directions
	in
	in-mutable
	out
	inout
	in-mutbale-out

add Reference to builtin library
or add reference types
example
	$decl Reference<Int> a = ReferenceClass<Int>(8)
	println a.val
	a.val = 936
	println a.val
add WeakReference to builtin library

nullable in/inout parameters
	it must be explicit, and not by default
	func foo(null Int value) ...
		...

consider: objects can't be immutable, but values can
implementing const/immutable versions of interfaces that aren't normally const/immutable
	Q: should the mutable version of the interface inherit from the immutable one?
immutable object references can only be cast to immutable object references
Q: how to cast a mutable type to an immutable type?
immutability and generics need much more specing
encouragement:
	mode where any dynamic typing produces a warning, like for/when
	Dyn identifiers
	generics use methods not defined by Desal (eg add, add!)
	object identifiers are cast to interfaces that are not inherited by the previous interface
the "!" part of identifiers is syntax
	it should not be a part of Desal semantics
	mutator methods should only be a way for Dextr to specify that the method produces mutations
	in Desal, there should be some other way
	it shouldn't be part of the identifiers!
adding interfaces
make object identifiers and function identifiers more similar
	make sure functions can be boud to function identifiers in child scopes
identifier declarations
	take place before scope is executed
	binding may also occur here
	differentiate between bindings that happen later
	warn when identifier is referenced before being bound to a value
		//okay - bound at decl time
		Int a = b * 2
		def Int b = 5
		//produce warning - not bound yet
		Int a = b * 2
		Int b = 5

const function identikeys
	can't have further functions bound
		rational: call on that identifier may change when a function is added that requires fewer casts
	can't unbind functions
		rational: call on identifiers that were valid may become invalid
Decide how multiple functions could be bound to a const function identikey.

unbinding functions
	(from non-const identikeys only)

decide if interfaces can be sealed/closed
	* all interfaces are implementable, even enums, function interfaces and Object
	* If there are multiple interfaces user code can't implement, create a section that refers to all of them.

binding to nth parameters
decl func doStuff( Int a, Rat b, String c ) {...}
decl f = doStuff:( 3 = "bar" )


spec out the identikeys created by parameters


create an "expression-output" node that tells what kind of values can be given when an expression node is evaluated
like identikeys and function calls
expression-output ::=
	boolean nullable
	boolean automatic
	? expression interface
	? expression test
merge dynamic and strict identikeys
identikey-type ::=
	identikey-category (function/single/in-param/)
	type
	boolean constant
automatic means there's a static type, but it should be determine by the agent during processing
if it can't be determined during processing, no interface restriction is placed on it and an error is output
func foo( Int i where smToLg(5, i, 20) ) { ... }
(parameter
	(identifier i)
	(expression-output
		(.nullable false)
		(.automatic false)
		(identifier.interface Int)
		(call.test
			(identifier.value smToLg)
			(integer.argument 5)
			(idenifier.argument i)
			(integer.argument 20)))
	(block ...))


give block nodes an optional expression-output member
	if given, the block evaluates to the contents of an "eval" node that evaluates the parent to the given value
		like return, but more general
decl Int v = Int {
	if a < b : eval 5
	eval 9
}
decl foo = * {
	if a < b : eval getDyn()
	eval getDyn()
}


spec out identifiers
list of 1+ Unicode code points
agents must support code points outside the BMP
no reserved characters, control characters or whitespace
what is reserved/control/whitespace is not defined, but should include:
surrogate pairs
chars used for BOM
null, bell
space, tab, vertical tab, form feed, carriage return, paragraph separator, line separator, nell
can't start with 0-9 \/`[]~!@#$%^&*(){?+ etc
can't contain ( ) . : - * / + ' "
case sensitive, though agents are encouraged to give suggestions of differently-cased identifiers when an identikey/property/method is not found


remove the dynCall method from the Function interface
functions can already be called dynamically. This method is not needed and only gets in the way.




after adding opacity information, put the call node in a new category:
"sometimes executable, sometimes evaluatable"

If the opacity information for a function/method specifies that calling the function has no side effects, then the function/method can't be in a call that is executed. If this is determined at runtime, a warning is output and no exception is produced, but during processing, this results in an error.

Whether the function is evaluatable depends on whether the function returns anything.



instructions for execution/evaluation assume no processing has been done
	* involve runtime checks and throwing exceptions	
define processing as:
	* find code that can produce errors during execution/evaluation (besides explict throw nodes)
		- when found, alert of the error and don't run the program
	* notice that:
		- the outcome of runtime checks can sometimes be determined during processing
		- agents are allowed to change or do anything as they please as long as the results stay the same (make sure this is speced somewhere and linked to from here)
		- therefore, agents can remove runtime checks where the outcome can be deteremined during processing, as it it has no result on the outcome
		- say that agents should remove such runtime checks



warning supression
$decl ? foo = doSomething() :suppress "always null"

warning-supress ::=
	expression
	+ string

string "all" suppresses all warnings

create section with some warnings
say that agents are encouraged to create additional warnings

warnings
	"always null" - a node that never produces a value when executed, is being used as an expression - e.g. the output is assigned to something or passed as an argument


spec out phrases/terms:
	using a node as an expression
	using a node as a statement
	expression
	statement
	execution
	evaluation




spec out partial template specialization
come up with better name (partial generics specialization?)

ensure that substition failure is not an error for generics
this page explains that:
http://boost.org/libs/utility/enable_if.html



define complex string literals and string formatting
"x: ${x}"
"x: %" % x
http://boost.org/libs/format/doc/format.html
http://docs.python.org/lib/typesseq-strings.html
consider making it an island instead, like regular expressions


Desal supports some dynamic features, but is in several ways a very static language.
dynamic:
	dynamic typing (a.k.a. duck typing)
	dynamic creation of interfaces, classes, and interface implementations
static:
	Scope formulas/trees (a tree of scopes and identikeys) can always be entirely known before runtime. Identikeys cannot be declared conditionally.
	Members of interfaces/classes/values cannot be added or removed.
	An "eval" command could not be supported in Desal without major changes and/or extreme limitations.


define how assignment to namespaced identikeys can occur
possibility:
	assign ::=
		* identifier namespaces
		identifier identikey name
		expression value
possibility:
	assign ::=
		namespaced-identikey
		expression value
	namespaced-identikey ::=
		* identifier namespaces
		identifier identikey name
possibility:
	assign ::=
		identifier|namespace-identikey
		expression value
	namespaced-identikey ::=
		+ identifier namespaces
		identifier identikey name



remove all instances of "evaluate" from the Desal semantics spec (there are a lot)



define how a class's private value is used to implement an interface for the class

class Foo {
	Bar _bar
	
	...
	
	impl Bar {
		//use of Bar members goes to _bar unless overridden
		delegate _bar
		
		//override one of Bar's members
		func doSomething() {...}
	}
}



consider merging planes and namespaces
remember to keep semantics and representation separate
	but also keep performance in mind (compiling separate files/chunks individually)
make a list of the purposes of each and what each is good and bad at
	


define a "function" namespace of the standard library

map, fold, anyTrue?, forEach, filter, everyTrue?, etc


func collectWhile( producer, test ) {
	List list = List()
	while test() : list << producer()
	return list
}

list = [] # start with empty list and fill it
while Something :
	list.append( next_thing() )

list = collectWhile( next_thing, ||Something )

string = '' # start with empty string and fill it
while Something:
	string = string + next_token() 

string = collectWhile( next_thing, ||Something )



spec that the interface of a value produced by a function identikey is the same as addition of the function interfaces

$declfunc foo = $func()Int {...}
$declfunc foo = $func(Int)Int {...}
$declfunc foo = $func(Int,Int)Int {...}

$decl fooValue = foo
activeInterface(fooValue) ==
	( $func()Int + $func(Int)Int + $func(Int,Int)Int ) //true




Define how the automatic iteration loops work. Generators? Iterators? Either/or/both?



Say that instructions in spec for how to do stuff are intended to be understandable by people, and not intended to have full mathematical or other type of riguor. Or something like that. Basically, if instructions are understandable to people, they're good enough, even if they make no sense in a mathematical way.



An agent is allowed to refuse to handle a Desal bundle if the agent can determine that any of the nodes, when executed, would throw an exception (besides the throw node). For example:

decl Int foo = 3
println fooo

If "fooo" was not defined, the agent would have reason to refuse to handle the bundle. "Handling" may refer to executing the bundle or translating it, e.g. to machine code, bytecode, or another language.

Once an agent has begun execution, such reasons are not valid reasons for not continuing execution. Execution must continue normally as described.

Desal spec should define things as if entirely dynamic, but should note that it doesn't have to be treated as dynamic.



production:

Nodes "produce" a "product" when executed. This may be a value, or it may be null. Null can be thought of as a lack of a value, or as a special value that behaves differently from all other values.


block node execution:

Execute each [member] in order.
Produce the product of the last [member].


weave ::=
	2+ expression
Executes all child nodes in parallel. Every node other than a weave node is a transaction.


write rational for the layout of if-else
why are these two things different?
one:
	if a {...}
	elif b {...}
	else c {...}
two:
	if a {...}
	else {
		if b {...}
		else c {...}
	}
consider: semantics, XML representation, shallow hierarchy, ease of implementation, how easy it is to describe, that there are 2 nodes (possibility, conditional) instead of 1



Specify the way to determine the type of various things.

Example:
	decl auto foo = ( if a < b { 123 } )

What is the type of foo? Probably nullable Int.






consider: Rename "loop" node to something like "infinite-loop" or "unchecked-loop" or "unconditional-loop" or something to make it's behavior more obvious.
Dextr might change the "loop" keyword to "infloop"




idea: Instead of each node declaring what kind of barriers it has, each "event" should declare what nodes it can or cannot travel through.
Example: break must be within an iteration node. Between the break and iteration node can be: possibility, if-else, try-catch (and exception-handler), block



Make all types associated with number literals immutable.
For opertors like these:
	*= -= += /= ++ --
make them like equivalent assignments.
	e.g. You couldn't do "getInt()++" because that would be like "getInt().increment!()" and no "increment!" method would exists.
but you could do:
	number++
which would be the same as:
	number = number + 1

Then using LimInt instead of BigInt wouldn't have any performance advantage.

(You'd still want LimInt! and BigInt! for mutable integers.)


this format for spec:
summary
purpose
scope
body
glossary
appendices/references


specify term for child nodes, of a node instance, that were optional (they're given, but they didn't haven to given)
use only that term
examples: present, set, given, provided


clarify whether "identikey" only refers to {scope+identifier} which can be bound to values, or whether it also includes namespaces. Is there such a thing as a "namespace identikey"?



The standard library is already going to have "magic" functionality that can't be implemented by normal Desal code (e.g. value-builder API as alternative to classes) so go ahead and convert nodes, that can be implemented as functions, to functions. Example: the same-object node, the object-id node. Previously, I wanted to use nodes for all functionality that couldn't be implemented by normal code.


note that the id() function can't be implemented by just returning the address because the CLI functions for getting an object's address don't guarantee that the object won't be moved
possible implementation:
Dict<WeakRef, Int> ids;
int nextID = 0;
func id(IValue val) {
	WeakRef wr = new WeakRef(val);
	if( ! ids.contains(wr) ) {
		ids.add(wr, nextID);
		nextID++;
	}
	return ids[wr];
}
requirements:
(new WeakRef(a)).Equals(new WeakRef(a)) must be true
notes:
without periodically removing GCed values from the ids collection, the ids collection will grow extremely large.
As the program runs, nextID will grow larger and larger.


come up with a better term for "value"
because "value" is used way to often to mean other things
possibilities:
	view - because it's just one way of looking at a particular object
		i.e. can see an object as a Square, a Rectangle, a Shape, or an Object




To obtain information from client implementations of native types:

Collections contain a finite number of elements. Collections know how many elements they contain. However, collections are not required to have a value in memory for every element they contain. This means a collection of the numbers from 1 through 1 trillion is possible, even when only a few megabytes are available. Of course, the collection must be capable of yielding every element when iterated over.

Note that although strings inherit Collection<UnicodeCodePoint>, strings do not have to be implemented as a group of UnicodeCodePoint values. They may decide to instead create UnicodeCodePoint values as needed when being iterated over. This means a string could be stored in memory as UTF-8 and merely create UnicodeCodePoint values from the octets when needed.

Question: Should string instead inherit from Collection<Int> even though the range of possible values of the Ints is limited? Perhaps it could inherit from Collection<LimInt>. Int could be any integer, while LimInt is limited to certain values.

interface<T> Collection {
	func createIterator() Iterator<T>
	get Bool isEmpty?
	get Int count
}
interface Int/Rat {
	convert Collection<Bool>
}
interface String {
	inherit Collection<UnicodeCodePoint>
}
interface UnicodeCodePoint {
	get Int value
}

for Bool bit in (123 to Collection<Bool>)
	print (bit ? 1 : 0)
println()

decl String str = "this is some text"
for UnicodeCodePoint codePoint in str
	for Bool bit in (codePoint.value to Collection<Bool>)
		print (bit ? 1 : 0)
	println()

split iterators into Iterator, ConstIterator, and MutatingIterator

Question: Why do Int and Rat not inherit from Collection, while String does?
Answer: Integers and rational numbers can be represented as bitstrings, but they are not thought of as always *being* bitstrings. Strings are abstractly thought of as *being* collections of Unicode code points, even if they are not represented internally that way. Numbers are not thought of as collections, while strings are thought of as collections. The inherit/convert distinction is not made due to how the types of represented, but due to how they are thought of. They are not usually thought of in the same way, so they did not do this in the same way.






As the above shows, generic interfaces/classes need non-interface parameters. This would allow for the creation of something like LimInt<10, 99> (perhaps an integer from 10 to 99).

But then what becomes the difference between e.g. a generic interface and a function that returns an interface? (LimInt<10, 99> versus LimInt(10, 99)) The difference is that the generic interface more explicitly declares that:
* its purpose is to create interfaces that differ only by the arguments given to it. A function like GetFace(Int n) could just return the nth interface from an ordered collection, and thus the various interfaces could be completely different, while the generic interfaces MyFace<0> and MyFace<1> should have the same number of callees, convertees, methods, and properties, and with the same names.
* it will return the same interface for every call that has equivalent arguments. (E.g. LimInt<10, 99> will always be the same as LimInt<10, 99>)

Also important for this: Array. For example: decl Int[300] numbers
However, its still important to be able to do: decl Int[] numbers
For that, Array might be declared like this:
generic <Interface ? face, Int ? count> interface Array
Array.instantiate( String, 500 )
Array.instantiate( null, 9 )
Array.instantiate( String, null )



Clarify that a value cannot gain or lose members. After a value is created, the members it has at that time are the only members it will ever have, and it will always have those members. This is common in static languages like C/++/# and Java, but uncommon in dynamic languages like Python and JavaScript. Desal is like this because although it supports dynamic (duck) typing, it is otherwise mostly a very static language. Also, the interfaces an object implements (and the structure of the interface implementation tree) cannot be changed.

Relatedly, interfaces are also immutable. Eventually, the Interface interface should contain causality information stating such. Perhaps agent authors should be encouraged to call every member of an Interface implementation as soon as it is created, and cache the result for future calls? This would ensure that interfaces don't change, even when implemented by client code.



figure out if this optimization is possible:
Instead of Int identikeys being pointers to an object, each identikey holds a copy of the number.

Example:
	decl Int a = 123
	decl Int b = a
	decl Int c = a
a, b, and c each hold the value "123" instead of pointing to the same object with holds the value.

Problems:
* The id() function and same-object node or sameObject?() function would show that these identikeys do not point to the same object. This could be fixed by expanding Int identikeys to also store the id along with the value.
* User implementations of the Int interface. This could be fixed by expanding the Int identikeys to also a pointer to an object, which would by default be null.
struct IntIdentikey {
	uint64 id;
	uint64 value;
	IntObject * object;
}

This could be easily compressed to 128 bits:
struct IntIdentikey {
	bit storedLocally?;
	uint63 id;
	union {
		uint64 value;
		IntObject * object;
	}
}

Or even to 64 bits:
struct IntIdentikey {
	bit storedLocally?;
	union {
		struct {
			uint31 id;
			uint32 value;
		}
		struct {
			uint63 objectAddress;
		}
	}
}

Both of these types of compression would only work if IntObjects were only allowed to be placed on address that are divisible by two. This would likely be the case anyway, but I'd need to be sure it was actually guaranteed to happen.



Problem: How to implement the id() function with a moving garbage collector?



clarify why the term "list" is not used for a node or interface name
	- ambiguity between:
		* linked lists
		* numerically indexed collection, often implemented with arrays
note that the term "chain" is used by Desal for a linked-list





note that Desal does not have an arbitrary split between different types of functions/subroutines, like many languages do
	methods and delegates in C#
	methods and blocks in Ruby
	functions and lambda in Python/Lisp



at one time, identifiers ending in "!" had special meaning recognized by the language
this has since been replaced with causality notations
ensure that all references to the "!" having meaning have been removed



Write rational for the more complicated system of parameters/arguments that Desal has. The traditional way of only allowing default values after non-default values leads to arranging parameters based on whether each parameter has a default value. When defaults added/removed, order of parameters changed.



remove requirement that representations can represent all semantics
add this requirement to desible
speak of "directions" of representations
	concrete representation translated to abstract semantics
	abstract semantics translated to concrete representation
	both




reference types: Ref, MaskRef, WeakRef
---
interface<T> Ref {
	get+set T target
}
func<T> Ref() Ref<T> {...} //shouldn't exist if T is not nullable
func<T> Ref(T value) Ref<T> {...}

(Note that T could be nullable, e.g. "Int ?" for "Ref<Int ?>")

Ref<Int> number = new Ref<Int>(555)
number.target = 123
println( number.target.lessThan?(987) )
---
A MaskRef exposes the interface of the value it refers to. The MaskRef interface exists mainly to avoid having to write e.g. "Int+Ref<Int>" instead of "MaskRef<Int>". The MaskRef function would still be important even if the MaskRef interface wasn't used. (Note that MaskRef could be defined by client code, though it has a dependency on Ref, which couldn't.)

interface<T> MaskRef {
	inherit T
	inherit Ref<T>
}
func<T> MaskRef() MaskRef<T> {...} //shouldn't exist if T is nullable
func<T> MaskRef(T value) MaskRef<T> {...}

MaskRef<Int> number = new MaskRef<Int>(555)
number.target = 123
println( number.lessThan?(987) )
---
interface<T> WeakRef {
	get Bool alive?
	get+set T target
	get EventDispatcher<XXX> onDelete
	get EventDispatcher<XXX> onSave
}
WeakRef<Int> number = new WeakRef<T>(123)
number.onDelete.addListener( func(XXX) { println("number GCed") } )
number.onSave.addListener( func(XXX) { println("number safe for now") } )
---
What about soft references? (GCed only when need memory.) Should WeakRef be a soft reference?



interface<T> EventDispatcher {
	func addListener( func(T)void callback ) void
	func removeListener( func(T)void callback ) void
	func containsListener?( func(T)void callback) Bool
}
(T is the type of value sent to the callback functions)




When executing a node with scope:
	* execute the using/expose nodes
	* reserve the identikeys specified by child declare-first nodes
	* execute declare-first nodes
	* execute the normal nodes








See in anything in LINQ (esp in C#) could inspire new ideas for Desal. See "higher-order functions.txt" for a bind operator based on type that was inspired by LINQ.





block {
	decl foo = 123
	block {
		println( foo ) //error - foo declared in this scope, but used before declaration
		decl foo = 789
		println( foo ) //okay
	}
}

block {
	decl foo = 123
	block {
		println( outer:foo ) //okay
		decl foo = 789
		println( foo ) //okay
	}
}




Pragma Namespaces
In C++, what if multiple standards want to use the same pragma name? This is avoided in Desal by the programmer being able to determine what name is given to each standard.

bundle {
	pragma_namespace omp = "OpenMP"
	pragma_namespace html = "http://www.w3.org/1999/xhtml"
	pragma_namespace foo = "{0454-64113-54-7-984-13213213-3133333}"
	
	plane {
		func main() {
			pragma omp parallel for
			for i from 0 to 100
				println i
		}
	}
}

(bundle
	pragma_namespace omp = "OpenMP"
	pragma_namespace html = "http://www.w3.org/1999/xhtml"
	pragma_namespace foo = "{0454-64113-54-7-984-13213213-3133333}"
	
	(plane
		(func main()
			pragma omp parallel for
			(for i from 0 to 100
				(println i)))))




Ensure Desal supports contract programming. Add as many contract programming features as you can find from other languages. Also ensure Desal has good asert() functions, including one that is disabled for builds, one that is enabled for all builds, and one that only outputs warnings (e.g. debugAssert, assert, and warnAssert).





Explain typing in Desal.

static typing where possible, dynamic typing elsewhere

static typing -
	checking type safety before execution
	requiring types are known before execution
	type information stripped away before execution
dynamic typing -
	checking type safety during execution
	allowing types to be defined/modified during execution
	type information available during execution

Desal does not require types be known before execution (unlike statically type languages). However, it intends to facilitate static type checking (unlike dynamically typed languages). Type information can only be stripped away during static type checking if that information would not be beneficial during execution. Desal intends to be capable of being compiled or interpreted without differing semantics or behavior.





Writing an interpreter/compiler is hard. See http://www.python.org/dev/peps/pep-0339/ in case you weren't already convinced. My Dextr implementations should try to shove all the work onto something else ASAP. That means targeting a common bytecode (probably CLI/Mono, but maybe also Java) or a compiler (like GCC's GENERIC/GIMPLE), instead of trying to do anything myself. A Desal implementation should do nothing more than parse, validate, translate, and hand off work to others.

Hand-writing a class for each node type, that can possible .execute(), is not a good idea. Instead, the layout should be stored in a file (e.g. XML) and the code to deal with the layout should be generated automatically. A node class should not have an .execute() method. If I insist on writing my own interpreter, it should be separate. Also, much of the Desible parser should be generated automatically.

Here's what desal001 should be able to do:
* output information about a representation (Desible, Dextr)
	- is it valid?
	- Dextr: list of tokens
* translate between representations (Dextr to Desible, Desible to executable)
* execute a representation

CLI interface:
1) Create a string->string dict. Set "mode" equal to "execute".
2) Read all arguments that begin with a dash until the first argument that does not begin with a dash (ignore arguments that begin with a dash after that argument).
3) For each argument, strip the initial dash. Then split whats left around the first equals sign. If an equals sign is not present, throw an error. Add the pair to a dict with the first part as the key and the second part as the value.
4) Create a sequence of the remaining arguments (the ones that did not start with a dash or came after an argument that did not start with a dash).
4) Continue according to the mode.

Mode can be "info", "execute", or "translate".

desal001 -mode=info -repr=dextr -infomode=tokenlist "test.dextr" > file
desal001 -mode=info -repr=dextr -infomode=tokenlist -outpath="tokenlist.txt" "test.dextr"

if mode is info:
	First non-dash argument is the input file. There should be no other non-dash arguments.

if mode is execute:
	First non-dash argument is the path of the input file. Rest of the non-dash arguments are the arguments to the bundle represented by the input file.


Could something refer to an outer identifier before declaring its own?
	func foo() {
		println( something ) //outer
		decl something = 123
		println( something ) //inner
	}
	I'm thinking no, but this needs to be speced. However, this would be okay:
	func foo() {
		println( outer:something ) //outer
		decl something = 123
		println( something ) //inner
	}


Note that in Desal, everything that can be a function should be, to facilitate functional programming. (e.g. map(), filter())
Q: What about caller, breed, and cast?

Make Desal declare-first nodes scope-alteration nodes, but no longer expressions.
class Node_DeclareFirst : INode_ScopeAlteration {...}


























=============  Dextr  ================

make "dyn ?" the default return type for functions
func foo() {...} //same as below
func foo()dyn ? {...} //nullable dyn
func foo()dyn {...} //non-nullable dyn
func foo()void {...} //always null


--- Dextr tokenization

Define the first two stages of the three-stage process of extracting Desal semantics from Dextr:
1) tokenization
2) fixup
(parsing the tokens would come next)

The first stage should be specified using BNF. It takes in a string (a sequence of Unicode code points) and outputs a sequence of tokens, including space, tab, and comment tokens.

The second stage should be specified using English. It removes the space and comment tokens, throwing an error when they appear where they shouldn't. It also replaces tabs with indent_open and indent_close tokens.

This two-stage process allows much of the heavy lifting to be done by automatically generated tokenizers, so that the hand-coded portion can be much simpler.




namespaced-value-identikey
	identifier:identfier:identifier
	decl Int a = foo:bar:miz

call
	expr()

curry
	expr~()

extract-named-member
	expr.identifier


decl a = ns:ns:val
a()
b()()()
a.foo()
a.foo()()().bar().alpha()
decl a = val.foo
decl b = a.bar.alpha.beta
decl a = foo.bar
decl a = foo~(123, "text")
decl b = foo.bar~(123, "text")
a = ns:ns:val.prop.prop.meth.foo
b = a~(123)
decl foo = a.b.c.d.e




Determine how the [should call] child of the curry node should be expressed in Dextr. Should there be two different operators for curry nodes?
	a~(123) //don't call
	a=>(123) //call




assign a copy
$decl Int a = b //no copy
$decl Int c := d //copy
translates to:
$decl Int c = $copy d
translates to:
(declaration-assign
	(identifier.interface Int)
	(identifier.name c)
	(copy.value
		(identifier.value d)))

possible syntax for nullability:
	"*" for any interface and not nullable
	"?" for any interface and nullable
	"Type" for a particular interface and not nullable
	"Type ?" for a particular interface and nullable
decl Int ? a = null
decl ? b = null
note: for this, you'd have to declare that identifiers can't start with a "?", which would be good anyway for conditional expressions (a ? b : c)


specify that
	decl Foo foo(...)
is just a shorter way of saying
	decl Foo foo = Foo(...)

that means that
	decl Foo ? foo
is different from
	decl Foo ? foo()
as the first one is the same as
	decl Foo ? foo = null
while the second one is the same as
	decl Foo ? foo = Foo()

this produces an error:
	decl Int number
because number is not nullable, and this is the same as
	decl Int number = null
this is fine:
	decl Int number()
assuming the "Int" identikey could be called with zero arguments


determining charset in agent:
* if BOM is present, go along with the BOM
	note that there is something import with the order, like testing for UTF-32 before testing for UTF-16 or something
* assume UTF-8
Dextr isn't just a syntax, it also defines a file format. The character encoding of those files is UTF-8 by default, but can also be UTF-16(LE/BE) or UTF-32(LE/BE) if stated explicitly. UTF-8 can also be stated explicitly.


-----




See how ML and Haskell handle returning multiple values.




Desal:
	try {
		...
	}
	catch( Exception e where e impls InstantiationException or e impls IllegalAccessException ) {
		...
	}
Try to make this more compact. For example, I think C# has this:
catch( Exception : InstantiationException, IllegalAccessException e )



instead of
	$try {
		doStuff()
	}
	$catch FooError e {
		errors.logError(e)
		$throw e
	}
add something to make it cleaner
	$try {
		doStuff()
	}
	$notice FooError e {
		logger.logError(e)
	}
$notice blocks can't return or evaluate. However, a try-catch node with a notice block can still evaluate, since whenever execution goes into the notice block, the exception that took it there will raise up out of the node so that it wouldn't evaluate anyway. Also spec that a try-catch node can still evaluate if some $catch blocks throw errors instead of evaluating.
	$decl foo = {
		$eval doStuff()
	}
	$catch XmlError e {
		$throw ParseError(e)
	}


keep in mind: Code is usually read several more times than it is written. Therefore, when choosing between something that is easier to write but harder to read, or something that is harder to write but easier to read, chose the one that is harder to write but easier to read.

possibly spec out common conventions, at least for builtin library
	Interface
	returnsBoolean?
	FooFactory / CFoo / ClassFoo
	other

ensure Desal has all features of lambda calculus

add processing step to Desal
create ScopeFormulas from declarations
check all interfaces to ensure correctness

add to rationale section
	why lang?
	why split between semantics and syntax?
	why not use technology XXX (like ASN.1, LaTeX, etc)

rename Desal Interpreter 001 to Desal Agent 001

spec out function identikeys that can refer to functions with different return types
spec out methods with the same name that have different return types

write style guidelines for specs
separate (what stuff *should* do) from (what stuff should *not* do)


Every class node's interface implementations should be reduced to a single interface implemenatation of the interface that is produced by adding together the interfaces of the provided interface implementations.
class
	faceimpl Foo
	faceimpl Bar
__priv = Foo + Bar
class
	faceimpl __priv


figure out how to create closed/sealed interfaces -- interfaces that are inherited already, but can't be inherited any more
example: a Node interface that is inherited by Tree and Leaf interfaces, but no others
(decl-first
	(identifier.name Node)
	(interface
		/* ... */
		(boolean.sealed true)))
(decl-first
	(identifier.name Tree)
	(interface
		/* ... */
		(identifer.inheritee Node)))
(decl-first
	(identifier.name Leaf)
	(interface
		/* ... */
		(identifer.inheritee Node)))
Note: For global identikeys, need to prevent other planes from inheriting interface.


spec out creating objects without classes (singletons)

Look at Java's way of handling multiple source files and libraries:
	import java.util.Random;

Spec out binding namespaces to identifers

write up rational for allowing classes to implement the same interface multiple times in different ways

test how other languages treat it
	interface Base
	interface Parent1 : Base
	interface Parent2 : Base
	class {
		Parent1 {...}
		Parent2 {...}
	}


many important libraries should be accessible from Desal Implementation 001
	standard libraries
		Java (see Mozilla's Java<->JavaScript bridge)
		Perl
		PHP
		Python
		Ruby
		Visual Basic (not VB.NET)
	component models
		Bonobo
		CLI (Common Language Infrastructure)
		COM
			ActiveX
			OLE
		CORBA
		D-Bus
		DCOP
		KPart
		Kross
		XPCOM
	libraries with bindings
		GObject
			maybe other stuff from GLib
		GTK
		Mono/DotGNU/.NET
		Qt
		WxWidgets

NOTE: The interfaces of most of these types will have to be "sealed" or "closed" or something. If a library function takes an instance of the Foo class, Desal code cannot create another implementation of the same interface and send an instance of that in. This is extremely bad for Desal, and has huge repercussions. It means that Desal agents cannot rely on preexisting libraries. Instead, new libraries will have to be created that focus on open interfaces and avoid sealed interfaces. Previously, I thought Desal could save a lot of time and effort by using the preexisting large and complex libraries, but I now understand that I was wrong. Desal will need brand new libraries.

Possible solution: Automatically translate the implementation of these libraries into Desal. That way, the libraries will support open interfaces, without having to be completely rewritten.




implementation:
	when handling a Desible element, mark it as handled
	after parsing Desible, go through every element
	throw error or warn if any of the elements haven't been handled

divide expression nodes into only-expression nodes and dual expression/statement nodes
dual expression/statement nodes "do something" when executed
only-expression nodes cannot be executed


Q: Why are namespaces not values? Everything else is. Interfaces, classes, functions, and generics of them are all values, but namespaces aren't?
Write up rationale. Create for/against list.


spec out representing numbers in bases besides base 10
should NOT be a part of semantics - only representations
Dextr:
	8x123 (base 8)
	0xF00 (base 16)
	16xDeAd (base 16)
	2x110101001010 (base 2)
	1234567890 (base 10)
	10x123 (base 10)
Desible:
	<integer>123</integer> (base 10)
	<integer base="8">444</integer> (base 8)
	<integer base="2">10101000101</integer>
	<integer base="10">567</integer>
	<integer base="16">CAFE</integer>

similarly to above:
	<string escaped="true">null: \000000</string>
	<string escaped="true">one slash: \\</string>
	<string escaped="false">two slashes: \\</string>
	<string>two slashes: \\</string>


//declaration:
func Rat square

//declaration:
def func square(Rat n) Rat {
	return n * 2
}

//not declaration:
square = func(Rat n) Rat {
	return n * 2
}


impl: add "immutable" attribute to ObjectReference class

implement prevalent identifiers
	func bindIdent(string ident)
		if identIsPrevalent(ident)
			throw error
		...
	func identIsPrevalent(string ident)
		if parent == null
			return prevalentIdents.contains(ident)
		return top.identIsPrevalent(ident)
	top get
		if parent == null
			return this
		return parent

ensure this is possible:
	take a value of any type and wrap it so you get 2 values:
		* a value that implements the same interface
		* a value used for event registration
	Int a = 8
	Listener l
	(l, a) = wrap(a)
	l.addMethodCallListener("add", func(event){...})
	Int b = a + 80 //listener gets called

interface Int
	Bool negative?
	Bool positive?

interface Interface
	func add(Interface) Interface

search for XXX in all specs and work on fixing problems

check Desal specs and implementation into version control
look at version control systems

lookup license of GPL
lookup extremely permissive licenses
see about making Desal Spec license more permissive

make sure my Desal implementation isn't affecting the spec in negative ways
It's okay for them to differ, even greatly!

emphasize that the rational for creating this language was to create a better separation between interface and implementation

further separate interface from implementation
	licensing libraries
		It should be easy to separate a public library interface from everything else and license it under a permissive license, while licensing the implementation of the library under a copyleft license.
		problem: Enum values must be part of the public library interface.
	loading libraries
		Should be possible to specify a library interface (and version) and get an implementation of it, both for static and dynamic linking. Should also be possible to specify several implementations to try first. If none of the implementations are available, programmer should be able to prevent a different implementation from being used.

spec out dynamically loading a library as a meta object

Desal implementation
	divide into these parts:
		library interface
		library implementation
		command line wrapper around library
		GUI wrapper around library

Desal implementation defines a way of declaring a class so bindings can be created automatically
make class node and children like that
copy the syntax/format

spec out enums
	are they even possible with all this interface business?
	see how enums work in other languages (especially highly OOP ones)
should Bool be an enum?
Bool could also be an interface that user code could not implement, and true and false the only implementations.

many things that should be function identifiers look like object identifiers
make it clear they are function identifiers, not obect identfiers

create specification for ASN.1 representation (Desasn) of Desal Semantics
modify Desible specification so it uses ASN.1 representation

need some way to access iterators (or functionality of iterators) in loops
	clean, easy, simple for loops that need it
	not show up for loops that don't need it


$decl foo =
if a : "text"
else : 12345

The if-else node shouldn't have a type of "dyn". Instead, it should have a type of something like "String or Int" or perhaps something like "dyn o where o impls String or o impls Int".


define a few things for the examples in the spec
	like what comments look like
add lots more comments to describe what's going on


---




make list of significant features
	specifications
		permissive license
	working implementation
		GPL/BSD license
		planned future: access to many libraries
	syntax separated from semantics
		no reserved words in semantics
	objects only refered to through interfaces
	plannned future: built-in ways of specifying opacity/purity
	mixed static and dynamic typing
	number literals are BigNums
	better string abstractions than many languages provide
		length doesn't count astral characters twice like e.g. Java and JavaScript do
	planned future: good parallel programming support
	allows global functions and objects
		like C++ and unlike Java/C#
	non-nullable parameters
		sorely needed in C#
	no value types (only reference types)
		distinction causes big problems C#


----- IDE/AGENT GUIDELINES

option: warn when finding closures

define syntax highling for strings where spaces are colored and spaces next to each other are colored differently

spec out that IDEs should have option to show default values for function calls
	when a function has a default value and a call to that function doesn't specify an argument,
	show the default argument as if it was specified, perhaps grayed out or colored differently or boxed or something


----- DESAL AGENT/IMPLEMENTATION 001

be sure that nodes which should have scope, do

If an object is not a function, and it's called like a function, you want to get the same error every time. This means every implementation of IObject should not be handling being called like a function, because each implementation of IObject may handle the error differently. Also, DRY.


Many things in Desal are just implementations of interfaces.
Because client code can implement these interfaces,
there often needs to be:
	* an interface for the item
	* a class for native items
		created manually in C# or by a construct in client
		ex: wrapping a C# int
		ex: an integer node
	* a class for items created manually by client
		ex: implementing the Int interface
	* a class to make items appear as objects
		though items created manually by client are already objects
For example:
	* IInterface
		a Desal interface
	* Interface
		a Desal interface created:
			* manually in C#
			* through an "interface" Desal node
	* InterfaceFromValue
		a Desal interface created by client code implementing Interface
	* InterfaceWrapper
		to make an Interface look like a Desal object

For functions, there's also the NativeFunction class, which makes
a C# function look like a Desal function.

The conversion functions (*FromValue, *Wrapper) are factories that
just return the unwrapped object when possible.


PROBLEM: Dictionaries are used for interface implementations, but multiple methods can be bound to the same identifier! This means we need something like multi_map from C++, or we need to bind identifiers to a list of functions.



In many compilers, objects that implement interfaces are implemented by expanding the size of the object and storing pointers to functions in this extra space. In Desal, interfaces are so common that this could be very detrimental to performance. For example, every instance of Int will contain a pointer to every method of the Int interface. So instead of storing a pointer to every method, objects should store a single pointer to an array of pointers somewhere. That way, every Int object would just point to this single table, instead of every Int object having a duplicate of this table. This also means that adding methods to an interface would have no effect on performance, just like methods on non-interface classes.




----- NOTES

tree -
	1) a graphical representation of a hierachy
	2) a computer data structure
hierarchy -
	objects ranked so that every one but the topmost is subordinate to a specified one above it

hierarchies are abstract while trees are concrete


ultimate optimizer test:
	replace slow sorting algorithm with fast sorting algorithm
	bubble sort -> quick/heap/merge sort


lookup modern opcodes (MMX, SSE, etc) and see if any describe actions that can't be explicitly stated with Desal
	if so, add stuff to Desal to support the opcodes


define memory representation
	for machine code implementations to speak to each other










After Dextr and Desal are well implemented:
* create tutorial showing how to write macros, with a few examples
* create tutorial showing how to alter the Dextr syntax description and parser to make macros look built-in, like the identifier-chain (formerly "chain"), with a few examples
This will make Dextr/Desal excellent for people who want to quickly and easily test out a new language construct they've thought up.

Possible idea: Create option for Agent to use custom funsynn syntax description file at runtime. Agent would produce parser, then use it, dynamically at runtime. The agent could then parse and run a bundle normally. This would be easier than producing code from the funsynn and copying it into the Agent code, then recompiling the Agent. This is a really stupid idea because the agent would still have to be recompiled to update the parser.




Horrifying idea:
Develop an API for modifying funsynn syntax descriptions (or whatever syntax description I use)
A Dextr bundle could include a script that modifies the Dextr syntax description, and adds hooks to the parser.
This would allow any Desal bundle to seemlessly integrate new language constructs.
This would also be absolutely terrible and very very scary.




Standardize the identifiers used in the Desal Agent.
<modifier><base>
	ReturnNode
<base>_<modifier>
	Node_Return
When to use which?



define Desexp (Desal S-Expressions) ?





