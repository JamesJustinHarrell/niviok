using System.Collections.Generic;

//this file automatically generated by Coco/R

namespace CocoR {


using System;



class Parser {
	const int _EOF = 0;
	const int _INDENTOPENt = 1;
	const int _INDENTCLOSEt = 2;
	const int _NEWLINEt = 3;
	const int _BRACKETOPENt = 4;
	const int _BRACKETCLOSEt = 5;
	const int _NUMBERt = 6;
	const int _STRINGt = 7;
	const int _WORDt = 8;
	const int _OTHERt = 9;
	const int maxT = 20;

	const bool T = true;
	const bool x = false;
	const int minErrDist = 2;
	
	public Scanner scanner;
	public Errors  errors;

	public Token t;    // last recognized token
	public Token la;   // lookahead token
	int errDist = minErrDist;

public Bridge bridge;
	public Node_Bundle bundle;
	public Node_Plane plane;
	public bool shouldParseBundle;



	public Parser(Scanner scanner) {
		this.scanner = scanner;
		errors = new Errors();
	}

	void SynErr (int n) {
		if (errDist >= minErrDist) {
			errors.SynErr(la.line, la.col, n);
			errors.errorStream.WriteLine(
				"(t.kind={0} t.val='{1}' la.kind={2} la.val='{3}')",
				t.kind, t.val, la.kind, la.val );
		}
		errDist = 0;
	}

	public void SemErr (string msg) {
		if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
		errDist = 0;
	}
	
	void Get () {
		for (;;) {
			t = la;
			la = scanner.Scan();
			if (la.kind <= maxT) { ++errDist; break; }

			la = t;
		}
	}
	
	void Expect (int n) {
		if (la.kind==n) Get(); else { SynErr(n); }
	}
	
	void ExpectLiteral (string text, int n) {
		if (la.val==text) Get(); else { SynErr(n); }
	}
	
	bool StartOf (int s) {
		return set[s, la.kind];
	}
	
	void ExpectWeak (int n, int follow) {
		if (la.kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}


	bool WeakSeparator(int n, int syFol, int repFol) {
		int kind = la.kind;
		if (kind == n) {Get(); return true;}
		else if (StartOf(repFol)) {return false;}
		else {
			SynErr(n);
			while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind])) {
				Get();
				kind = la.kind;
			}
			return StartOf(syFol);
		}
	}

	
	void Dextr() {
		if (shouldParseBundle == true) {
			BundleDocument();
		} else if (la.kind == 0 || la.kind == 3 || la.val == "decl" || la.val == "func") {
			PlaneDocument();
		} else SynErr(21);
	}

	void BundleDocument() {
		Node_DeclareFirst declFirst;
		IList<Node_DeclareFirst> declFirstList = new List<Node_DeclareFirst>(); 
		if (la.kind == 3) {
			Get();
		}
		while (la.val == "expose") {
			Get();
			Expect(8);
			Expect(3);
		}
		while (la.val == "decl" || la.val == "func") {
			DeclareFirst(out declFirst);
			declFirstList.Add(declFirst); 
			if (la.kind == 3) {
				Get();
			}
		}
		Expect(0);
		plane = new Node_Plane(declFirstList);
		bundle = new Node_Bundle(new Node_Plane[]{plane}); 
	}

	void PlaneDocument() {
		Node_DeclareFirst declFirst;
		IList<Node_DeclareFirst> declFirstList = new List<Node_DeclareFirst>(); 
		while (la.kind == 3 || la.val == "decl" || la.val == "func") {
			if (la.val == "decl" || la.val == "func") {
				DeclareFirst(out declFirst);
				declFirstList.Add(declFirst); 
			} else {
				Get();
			}
		}
		Expect(0);
		plane = new Node_Plane(declFirstList); 
	}

	void DeclareFirst(out Node_DeclareFirst declFirst) {
		declFirst = null; /* In case neither type of declare-first is found */ 
		if (la.val == "decl") {
			DeclareFirstNormal(out declFirst);
		} else if (la.val == "func") {
			FunctionDeclaration(out declFirst);
		} else SynErr(22);
	}

	void DeclareFirstNormal(out Node_DeclareFirst declFirst) {
		Node_Identifier ident; INode_Expression expression; 
		ExpectLiteral("decl", 11);
		Identifier(out ident);
		ExpectLiteral("=", 12);
		Expression(out expression);
		declFirst = new Node_DeclareFirst(
		ident,
		new Node_IdentikeyType(
			new Node_IdentikeyCategory(IdentikeyCategory.DYNAMIC),
			new Node_NullableType(
				null,
				new Node_Boolean(false)),
			new Node_Boolean(false)),
		expression); 
	}

	void FunctionDeclaration(out Node_DeclareFirst declFirst) {
		Node_Identifier ident; IList<Node_Parameter> prams; Node_Block block; 
		ExpectLiteral("func", 13);
		Identifier(out ident);
		ExpectLiteral("(", 14);
		ParameterList(out prams);
		ExpectLiteral(")", 15);
		Block(out block);
		declFirst = new Node_DeclareFirst(
		ident,
		new Node_IdentikeyType(
			new Node_IdentikeyCategory(IdentikeyCategory.DYNAMIC),
			new Node_NullableType(
				null,
				new Node_Boolean(false)),
			new Node_Boolean(false)),
		new Node_Function(
			prams,
			new Node_NullableType(
				null,
				new Node_Boolean(false)),
			block )); 
	}

	void Identifier(out Node_Identifier ident) {
		Expect(8);
		ident = new Node_Identifier(new Identifier(t.val)); 
	}

	void Expression(out INode_Expression expression) {
		expression = null;
		Node_Call call;
		Node_ExtractMember extract; 
		if (scanner.Peek().val == "(") {
			Call(out call);
			expression = call; 
		} else if (scanner.Peek().val == ".") {
			ExtractMember(out extract);
			expression = extract; 
		} else if (la.kind == 7 || la.kind == 8) {
			SimpleExpression(out expression);
		} else SynErr(23);
	}

	void ParameterList(out IList<Node_Parameter> prams ) {
		Node_Parameter param;
		prams = new List<Node_Parameter>(); 
		if (la.kind == 8) {
			Parameter(out param);
			prams.Add(param); 
			while (la.val == ",") {
				Get();
				Parameter(out param);
				prams.Add(param); 
			}
		}
	}

	void Block(out Node_Block block) {
		block = null; 
		if (la.kind == 3) {
			Get();
			TabBlock(out block);
		} else if (la.val == "{") {
			BraceTabBlock(out block);
		} else SynErr(24);
	}

	void Parameter(out Node_Parameter param) {
		Node_Identifier ident; 
		Identifier(out ident);
		param = new Node_Parameter(
		new Node_NullableType(
			null,
			new Node_Boolean(false)),
		ident,
		new Node_Boolean(false),
		null ); 
	}

	void TabBlock(out Node_Block block) {
		INode_Expression expr;
		IList<INode_Expression> exprList = new List<INode_Expression>(); 
		Expect(1);
		if (la.kind == 7 || la.kind == 8) {
			Expression(out expr);
			exprList.Add(expr); 
			Expect(3);
			while (la.kind == 7 || la.kind == 8) {
				Expression(out expr);
				exprList.Add(expr); 
				Expect(3);
			}
		}
		Expect(2);
		block = new Node_Block(exprList); 
	}

	void BraceTabBlock(out Node_Block block) {
		block = null; 
		ExpectLiteral("{", 17);
		Expect(3);
		TabBlock(out block);
		ExpectLiteral("}", 18);
	}

	void Call(out Node_Call call) {
		INode_Expression val;
		IList<INode_Expression> args; 
		SimpleExpression(out val);
		ExpectLiteral("(", 14);
		ArgumentList(out args);
		ExpectLiteral(")", 15);
		call = new Node_Call(val, args); 
	}

	void ExtractMember(out Node_ExtractMember extract) {
		INode_Expression expr;
		Node_Identifier ident; 
		SimpleExpression(out expr);
		ExpectLiteral(".", 19);
		Identifier(out ident);
		extract = new Node_ExtractMember(expr, ident); 
	}

	void SimpleExpression(out INode_Expression expression) {
		expression = null;
		Node_Identifier ident;
		Node_String str; 
		if (la.kind == 8) {
			Identifier(out ident);
			expression = ident; 
		} else if (la.kind == 7) {
			String(out str);
			expression = str; 
		} else SynErr(25);
	}

	void String(out Node_String str) {
		Expect(7);
		str = new Node_String(t.val); 
	}

	void ArgumentList(out IList<INode_Expression> args ) {
		INode_Expression arg;
		args = new List<INode_Expression>(); 
		if (la.kind == 7 || la.kind == 8) {
			Expression(out arg);
			args.Add(arg); 
			while (la.val == ",") {
				Get();
				Expression(out arg);
				args.Add(arg); 
			}
		}
	}



	public void Parse() {
		la = null;
		Get();
		Dextr();

		Expect(0);
	}
	
	bool[,] set = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x}

	};
} // end Parser


class Errors {
	public int count = 0;                                    // number of errors detected
	public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
	public string errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text
  
	public void SynErr (int line, int col, int n) {
		string s;
		switch (n) {
			case 0: s = "EOF expected"; break;
			case 1: s = "INDENTOPENt expected"; break;
			case 2: s = "INDENTCLOSEt expected"; break;
			case 3: s = "NEWLINEt expected"; break;
			case 4: s = "BRACKETOPENt expected"; break;
			case 5: s = "BRACKETCLOSEt expected"; break;
			case 6: s = "NUMBERt expected"; break;
			case 7: s = "STRINGt expected"; break;
			case 8: s = "WORDt expected"; break;
			case 9: s = "OTHERt expected"; break;
			case 10: s = "\"expose\" expected"; break;
			case 11: s = "\"decl\" expected"; break;
			case 12: s = "\"=\" expected"; break;
			case 13: s = "\"func\" expected"; break;
			case 14: s = "\"(\" expected"; break;
			case 15: s = "\")\" expected"; break;
			case 16: s = "\",\" expected"; break;
			case 17: s = "\"{\" expected"; break;
			case 18: s = "\"}\" expected"; break;
			case 19: s = "\".\" expected"; break;
			case 20: s = "??? expected"; break;
			case 21: s = "invalid Dextr"; break;
			case 22: s = "invalid DeclareFirst"; break;
			case 23: s = "invalid Expression"; break;
			case 24: s = "invalid Block"; break;
			case 25: s = "invalid SimpleExpression"; break;

			default: s = "error " + n; break;
		}
		errorStream.WriteLine(errMsgFormat, line, col, s);
		count++;
	}

	public void SemErr (int line, int col, string s) {
		errorStream.WriteLine(errMsgFormat, line, col, s);
		count++;
	}
	
	public void SemErr (string s) {
		errorStream.WriteLine(s);
		count++;
	}
	
	public void Warning (int line, int col, string s) {
		errorStream.WriteLine(errMsgFormat, line, col, s);
	}
	
	public void Warning(string s) {
		errorStream.WriteLine(s);
	}
} // Errors


class FatalError: Exception {
	public FatalError(string m): base(m) {}
}


} //namespace CocoR

