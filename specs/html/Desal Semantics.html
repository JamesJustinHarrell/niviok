<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Desal Semantics 1.0</title>
        <link href="styling.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <h1>Desal Semantics 1.0</h1>
        <h2>Edition 1 Draft 20071018</h2>
        <p>Copyright Â© 2007 James Justin Harrell</p>
        <p>Permission is granted to use, copy, display, modify, sell, and distribute this document. This document is provided "as is" without warrany of any kind. In no event shall anyone be liable for any damages or other liability arising from use of this document.</p>
        <ol class="toc">
            <li>
                <a href="#introduction">1. Introduction</a>
                <ol>
                    <li>
                        <a href="#specification-version">1.1. Version</a>
                    </li>
                    <li>
                        <a href="#specification-scope">1.2. Scope</a>
                    </li>
                    <li>
                        <a href="#compliance">1.3. Compliance</a>
                    </li>
                    <li>
                        <a href="#executing-desal-tree-rep">1.4. Executing a Desal tree representation</a>
                    </li>
                    <li>
                        <a href="#definitions">1.5. Definitions</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#overview">2. Overview</a>
                <ol>
                    <li>
                        <a href="#ext-namespace">2.1. ext namespace</a>
                    </li>
                    <li>
                        <a href="#expressions">2.2. Expressions</a>
                    </li>
                    <li>
                        <a href="#references">2.3. references</a>
                        <ol>
                            <li>
                                <a href="#value-identifiers">2.3.1. value identifier</a>
                            </li>
                            <li>
                                <a href="#reference-identifiers">2.3.2. Reference identifiers</a>
                            </li>
                            <li>
                                <a href="#function-identifiers">2.3.3. function identifier</a>
                            </li>
                            <li>
                                <a href="#namespace-identifiers">2.3.4. namespace identifier</a>
                            </li>
                            <li>
                                <a href="#dynamic-identifiers">2.3.5. dynamic identifier</a>
                            </li>
                            <li>
                                <a href="#meta-identifiers">2.3.6. meta identifier</a>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#execution">2.4. Execution</a>
                    </li>
                    <li>
                        <a href="#builtin-numbers">2.5. Built-in numbers</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#objects">3. Objects</a>
            </li>
            <li>
                <a href="#functions">4. Functions</a>
            </li>
            <li>
                <a href="#interfaces">5. Interfaces</a>
                <ol>
                    <li>
                        <a href="#adding-interfaces">5.1. Adding and Subtracting Interfaces</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#special-members">6. Special members</a>
                <ol>
                    <li>
                        <a href="#member.add">6.1. add</a>
                    </li>
                    <li>
                        <a href="#member.equals">6.2. equals?</a>
                    </li>
                    <li>
                        <a href="#member.extract">6.3. extract</a>
                    </li>
                    <li>
                        <a href="#member.insert">6.4. insert</a>
                    </li>
                    <li>
                        <a href="#member.throwDivide">6.5. throwDivide</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#object-references">7. Object references</a>
            </li>
            <li>
                <a href="#scopes">8. Scopes</a>
            </li>
            <li>
                <a href="#nodes">9. Nodes</a>
                <ol>
                    <li>
                        <a href="#node-terminology">9.1. Node terminology</a>
                    </li>
                    <li>
                        <a href="#tree-node-layout">9.2. Tree node layout</a>
                    </li>
                    <li>
                        <a href="#node-supertypes">9.3. Node supertypes</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#node-types">10. Node types</a>
                <ol>
                    <li>
                        <a href="#base-node-types">10.1. Base node types</a>
                    </li>
                    <li>
                        <a href="#tree-node-layout-representation">10.2. Tree node layout representation</a>
                    </li>
                    <li>
                        <a href="#nonexecuted-node-types">10.3. Nonexecuted node types</a>
                        <ol>
                            <li>
                                <a href="#node.comment">10.3.1. comment</a>
                            </li>
                            <li>
                                <a href="#node.namespace-reference">10.3.2. namespace-reference</a>
                            </li>
                            <li>
                                <a href="#node.reference-type">10.3.3. reference-type</a>
                            </li>
                            <li>
                                <a href="#node.reference-category">10.3.4. referenc-category</a>
                            </li>
                            <li>
                                <a href="#node.identifier-category">10.3.5. identifier-category</a>
                            </li>
                            <li>
                                <a href="#node.parameter">10.3.6. parameter</a>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#node.statement">10.4. Statement node types</a>
                        <ol>
                            <li>
                                <a href="#node.block">10.4.1. block</a>
                            </li>
                            <li>
                                <a href="#node.conditional-block">10.4.2. conditional-block</a>
                            </li>
                            <li>
                                <a href="#node.declaration">10.4.3. declaration</a>
                            </li>
                            <li>
                                <a href="#node.do-while">10.4.4. do-while</a>
                            </li>
                            <li>
                                <a href="#node.do-times">10.4.5. do-times</a>
                            </li>
                            <li>
                                <a href="#node.enum">10.4.6. enum</a>
                            </li>
                            <li>
                                <a href="#node.for">10.4.7. for</a>
                            </li>
                            <li>
                                <a href="#node.for-key">10.4.8. for-key</a>
                            </li>
                            <li>
                                <a href="#node.for-pair">10.4.9. for-pair</a>
                            </li>
                            <li>
                                <a href="#node.for-range">10.4.10. for-range</a>
                            </li>
                            <li>
                                <a href="#node.for-value">10.4.11. for-value</a>
                            </li>
                            <li>
                                <a href="#node.if-else">10.4.12. if-else</a>
                            </li>
                            <li>
                                <a href="#node.import">10.4.13. import</a>
                                <ol>
                                    <li>
                                        <a href="#node.alias-member">10.4.13.1. alias-member</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.import-all">10.4.14. import-all</a>
                            </li>
                            <li>
                                <a href="#node.loop">10.4.15. loop</a>
                            </li>
                            <li>
                                <a href="#node.return">10.4.16. return</a>
                            </li>
                            <li>
                                <a href="#node.while">10.4.17. while</a>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#node.expression">10.5. Expression tree node types</a>
                        <ol>
                            <li>
                                <a href="#boolean-logic-nodes">10.5.1. Boolean logic nodes</a>
                                <ol>
                                    <li>
                                        <a href="#node.and">10.5.1.1. and</a>
                                    </li>
                                    <li>
                                        <a href="#node.nand">10.5.1.2. nand</a>
                                    </li>
                                    <li>
                                        <a href="#node.or">10.5.1.3. or</a>
                                    </li>
                                    <li>
                                        <a href="#node.nor">10.5.1.4. nor</a>
                                    </li>
                                    <li>
                                        <a href="#node.xor">10.5.1.5. xor</a>
                                    </li>
                                    <li>
                                        <a href="#node.xnor">10.5.1.6. xnor</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.array">10.5.2. array</a>
                            </li>
                            <li>
                                <a href="#node.bind">10.5.3. bind</a>
                            </li>
                            <li>
                                <a href="#node.bind-meta">10.5.4. bind-meta</a>
                            </li>
                            <li>
                                <a href="#node.bool">10.5.5. bool</a>
                            </li>
                            <li>
                                <a href="#node.method-call">10.5.6. method-call</a>
                                <ol>
                                    <li>
                                        <a href="#node.labeled-argument">10.5.6.1. labeled-argument</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.cast">10.5.7. cast</a>
                            </li>
                            <li>
                                <a href="#node.class">10.5.8. class</a>
                                <ol>
                                    <li>
                                        <a href="#node.declaration-class">10.5.8.1. declaration-class</a>
                                    </li>
                                    <li>
                                        <a href="#node.declaration-any">10.5.8.2. declaration-any</a>
                                    </li>
                                    <li>
                                        <a href="#node.declaration-const-empty">10.5.8.3. declaration-const-empty</a>
                                    </li>
                                    <li>
                                        <a href="#node.interface-implementation">10.5.8.4. interface-implementation</a>
                                    </li>
                                    <li>
                                        <a href="#node.named-function">10.5.8.5. named-function</a>
                                    </li>
                                    <li>
                                        <a href="#node.class-property">10.5.8.6. class-property</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.conditional">10.5.9. conditional</a>
                            </li>
                            <li>
                                <a href="#node.declaration-bind">10.5.10. declaration-bind</a>
                            </li>
                            <li>
                                <a href="#node.declaration-pervasive">10.5.11. declaration-pervasive</a>
                            </li>
                            <li>
                                <a href="#node.function">10.5.12. function</a>
                            </li>
                            <li>
                                <a href="#node.function-call">10.5.13. function-call</a>
                            </li>
                            <li>
                                <a href="#node.function-interface">10.5.14. function-interface</a>
                            </li>
                            <li>
                                <a href="#node.function-template-instantion">10.5.15. function-template-instantion</a>
                            </li>
                            <li>
                                <a href="#node.identifier">10.5.16. identifier</a>
                            </li>
                            <li>
                                <a href="#node.curry-function">10.5.17. curry-function</a>
                            </li>
                            <li>
                                <a href="#node.bind-method">10.5.18. bind-method</a>
                            </li>
                            <li>
                                <a href="#node.namespaced-identifier">10.5.19. namespaced-identifier</a>
                            </li>
                            <li>
                                <a href="#node.chain">10.5.20. chain</a>
                            </li>
                            <li>
                                <a href="#node.implements">10.5.21. implements?</a>
                            </li>
                            <li>
                                <a href="#node.integer">10.5.22. integer</a>
                            </li>
                            <li>
                                <a href="#node.interface">10.5.23. interface</a>
                                <ol>
                                    <li>
                                        <a href="#node.callee">10.5.23.1. callee</a>
                                    </li>
                                    <li>
                                        <a href="#node.property">10.5.23.2. property</a>
                                    </li>
                                    <li>
                                        <a href="#node.method">10.5.23.3. method</a>
                                    </li>
                                    <li>
                                        <a href="#node.access">10.5.23.4. access</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.interface-template-instantion">10.5.24. interface-template-instantion</a>
                            </li>
                            <li>
                                <a href="#node.same-object">10.5.25. same-object</a>
                            </li>
                            <li>
                                <a href="#node.list">10.5.26. list</a>
                            </li>
                            <li>
                                <a href="#node.object-number">10.5.27. object-number</a>
                            </li>
                            <li>
                                <a href="#node.rational">10.5.28. rational</a>
                            </li>
                            <li>
                                <a href="#node.get-property">10.5.29. get property</a>
                            </li>
                            <li>
                                <a href="#node.string">10.5.30. string</a>
                            </li>
                            <li>
                                <a href="#node.unbind">10.5.31. unbind</a>
                            </li>
                            <li>
                                <a href="#node.unbind-function">10.5.32. unbind-function</a>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#unsorted-tree-node-types">10.6. Unsorted tree node types</a>
                        <ol>
                            <li>
                                <a href="#node.global">10.6.1. global</a>
                            </li>
                            <li>
                                <a href="#node.alias">10.6.2. alias</a>
                            </li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#prevalent-identifiers">11. Prevalent identifiers</a>
                <ol>
                    <li>
                        <a href="#object.cast">11.1. func{I}(obj)I cast</a>
                    </li>
                    <li>
                        <a href="#object.generator">11.2. interface generator</a>
                    </li>
                    <li>
                        <a href="#object.implements_q">11.3. func(obj, interface)bool implements?</a>
                    </li>
                    <li>
                        <a href="#ident.Int">11.4. interface Int</a>
                    </li>
                    <li>
                        <a href="#object.BigInt">11.5. interface BigInt</a>
                    </li>
                    <li>
                        <a href="#object.BigRat">11.6. interface BigRat</a>
                    </li>
                    <li>
                        <a href="#ident.Interface">11.7. interface Interface</a>
                    </li>
                    <li>
                        <a href="#object.Object">11.8. interface Object</a>
                    </li>
                    <li>
                        <a href="#interface.rat">11.9. interface rat</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#preexisting-global-identifiers">12. Other preexisting global identifiers</a>
                <ol>
                    <li>
                        <a href="#InterfaceBuilder">12.1. InterfaceBuilder</a>
                    </li>
                    <li>
                        <a href="#Iterator">12.2. Iterator</a>
                    </li>
                    <li>
                        <a href="#CInterfaceBuilder">12.3. CInterfaceBuilder</a>
                    </li>
                    <li>
                        <a href="#getFuncInterface">12.4. getFuncInterface</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#evaluation">13. Evaluation</a>
                <ol>
                    <li>
                        <a href="#error-handling">13.1. Error handling</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#unsorted-stuff">14. unsorted stuff</a>
                <ol>
                    <li>
                        <a href="#closures">14.1. Closures</a>
                    </li>
                    <li>
                        <a href="#tree-examples">14.2. Tree examples</a>
                        <ol>
                            <li>
                                <a href="#tree-example-1">14.2.1. Example 1</a>
                            </li>
                            <li>
                                <a href="#tree-example-2">14.2.2. Example 2</a>
                            </li>
                            <li>
                                <a href="#tree-example-3">14.2.3. Example 3</a>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#get-interface">14.3. get interface</a>
                    </li>
                    <li>
                        <a href="#obj-interface">14.4. obj interface</a>
                    </li>
                    <li>
                        <a href="#identifier-binding">14.5. Binding to identifiers</a>
                    </li>
                    <li>
                        <a href="#print-println-return-interfaces">14.6. Return interfaces of print and println</a>
                    </li>
                    <li>
                        <a href="#adjuncts">14.7. Adjuncts</a>
                    </li>
                    <li>
                        <a href="#runtime-inteface">14.8. runtime interface implementation</a>
                    </li>
                    <li>
                        <a href="#runtime-interface-creation">14.9. Runtime interface creation</a>
                    </li>
                    <li>
                        <a href="#self-return-type">14.10. "self" return type</a>
                    </li>
                    <li>
                        <a href="#bind">14.11. Bind</a>
                    </li>
                    <li>
                        <a href="#classes">14.12. Classes</a>
                    </li>
                    <li>
                        <a href="#noninstantiated-interface-templates">14.13. Noninstantiated interface templates</a>
                    </li>
                    <li>
                        <a href="#dynamic-library-loading">14.14. Dynamic library loading</a>
                    </li>
                    <li>
                        <a href="#static-typing">14.15. Static typing</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#rationales">15. Rationales</a>
                <ol>
                    <li>
                        <a href="#rationale.dynamic-static-typing">15.1. Dynamic static typing</a>
                    </li>
                    <li>
                        <a href="#rationale.terms">15.2. Terms</a>
                        <ol>
                            <li>
                                <a href="#rationale.get-set">15.2.1. get/set</a>
                            </li>
                        </ol>
                    </li>
                </ol>
            </li>
        </ol>
        <div id="introduction">
            <h1>Chapter 1. Introduction</h1>
            <div id="specification-version">
                <h2>1.1. Version</h2>
                <p>Each version of Desal Semantics has a major version number and a minor version number, both integers incrementing by one. When the major version number is incremented, the minor version number is reset to 0.</p>
                <p>All versions of Desal Semantics should be backwards compatible with previous versions that have the same major version number. That means the major version number should be changed when changes are made that break backwards compatibility.</p>
                <p>Example: Something that is valid Desal Semantics 5.3 will also be valid Desal Semantics 5.4, 5.5, 5.6, etc.</p>
                <p>Each specification describing a version of Desal Semantics may have multiple editions, each represented by an integer that's incremented by one. The first finalized specification for a version of Desal Semantics is the first edition, or edition one. Creating a new edition is a revision. Revisions should serve to clarify, add guidance, and correct errors in the specification, not to add or remove functionality. Revisions should not attempt to correct errors in Desal Semantics, only errors in describing Desal Semantics. Implementations should target the latest finalized edition of the version they are targeting.</p>
                <p>Each edition may have multiple drafts before being finalized. Each draft is represented by a date around the time it was published. Implementations and specifications should not target drafts.</p>
                <p>A version of Desal Semantics may be represented as "Desal Semantics X.Y" where X is the major version number and Y is the minor version number. A finalized specification for Desal Semantics may be represented as "Desal Semantics X.Y Edition A" where A is the edition number. A draft of a specification may be represented as "Desal Semantics X.Y Edition A Draft B" where B is the date in YYYYMMDD format.</p>
                <p>This specification describes Desal Semantics 1.0. This specification has never been finalized, so is working towards the first edition. It is still in the draft stages.</p>
                <p>When this specification is finalized, it will be Edition 1 (instead of Edition 1 Draft YYYYMMDD). If the finalized specification is revised, the next finalized edition will be Edition 2.</p>
            </div>
            <div id="specification-scope">
                <h2>1.2. Scope</h2>
                <p>This document defines Desal semantics, but not how to represent them.</p>
            </div>
            <div id="compliance">
                <h2>1.3. Compliance</h2>
                <p>This specification provides a definition of compliance. Other definitions of compliance may exist outside of this specification, but to be compliant as defined by this specification, these requirements must be met.</p>
                <p>For an implementation to be "base compliant", it must meet all the "must" requirements listed in this spec. If this spec says an implementation "must" do something, the implementation will not be considered base compliant according to this specification if it does not do it.</p>
                <p>Above base compliance, there are further levels of compliance. Each correct implementation of a "should" requirement increases the compliance level, and each failure to implement a "should" requirement decreases the compliance level. Two different compliance levels can only be compared if one is a subset of the other.</p>
                <p>For example, consider an implementation Alpha that meets all the "must" requirements and three of the the "should" requirements, and an implementation Beta that meets all the "must" requirements and five of the "should" requirements. If Beta does not meet the three "should" requirements that Alpha meets, Aplha is not a subset of Beta, so it cannot be said that Beta is more compliant than Alpha. But if Beta meets the same three "should" requirements as Alpha (in addition to the other two), then Alpha is a subset of Beta, so it can be said that Beta is more compliant than Alpha.</p>
                <p>This specification also has "encourgements". These encouragements are considered good ideas by the specficiation author(s), but may not always be appropriate or may not be necessary for interoperability. Complying with these encouragements does not increase an implementation's compliance.</p>
            </div>
            <div id="executing-desal-tree-rep">
                <h2>1.4. Executing a Desal tree representation</h2>
                <p>Note: This section is very new. Its contents might not be reflected yet in other sections.</p>
                <p>Remember: The main tree might not have a main function. The main tree might just expose it's members, such as for scripting or a library.</p>
                <p>interpreted:</p>
                <ol>
                    <li>a Desal tree representation is parsed to extract a Desal Semantics tree</li>
                    <li>tree is processed 
                    <ol>
                        <li>imported files are parsed into trees</li>
                        <li>libraries are loaded and linked</li>
                    </ol></li>
                    <li>optimization</li>
                    <li>execution of main global node, which produces an exit status</li>
                </ol>
                <p>runtime compilation:</p>
                <ol>
                    <li>a Desal tree representation is parsed to extract a Desal Semantics tree</li>
                    <li>tree is processed 
                    <ol>
                        <li>imported files are parsed into trees</li>
                        <li>libraries are loaded and linked</li>
                    </ol></li>
                    <li>optimization</li>
                    <li>trees translated to bytecode and/or machine code</li>
                    <li>execution of bytecode and/or machine code, which produces an exit status</li>
                </ol>
                <p>beforehand compilation:</p>
                <ol>
                    <li>a Desal tree representation is parsed to extract a Desal Semantics tree</li>
                    <li>tree is processed 
                    <ol>
                        <li>imported files are parsed into trees</li>
                        <li>static libraries are loaded and linked</li>
                        <li>information about shared libraries is loaded and linked</li>
                    </ol></li>
                    <li>optimization</li>
                    <li>trees translated to bytecode and/or machine code and stored</li>
                    <li>code is loaded and processed 
                    <ol>
                        <li>shared libraries are loaded and linked</li>
                    </ol></li>
                    <li>execution of bytecode and/or machine code, which produces an exit status</li>
                </ol>
                <p>This specification is defined with an interpreter in mind. This spec will define how to:</p>
                <ul>
                    <li>process a tree. a fully processed tree should contain no identifiers. identifier nodes should be replaced with direct associations with references.</li>
                    <li>execute/evaluated nodes of a processed tree</li>
                    <li>execute a processed main global tree</li>
                </ul>
                <p>Implementations that aren't interpreters must produce equivalent behavior when being executed.</p>
            </div>
            <div id="definitions">
                <h2>1.5. Definitions</h2>
                <dl>
                    <dt>expression</dt>
                    <dd>When "evaluated", they produce a value</dd>
                    <dt>object</dt>
                    <dd>A collection of data that holds state. Created by a class. Only the class that created it can access an object's state. Values are associated with objects.</dd>
                    <dt>reference</dt>
                    <dd>References can be bound to one or more values. An identifier in a certain scope is often associated with references, although they aren't always.</dd>
                    <dt>value</dt>
                    <dd>Associated with an object and an interface implementation, except for the null value, which is associated with an interface.</dd>
                    <dt>prevalent</dt>
                    <dd>Immutable objects bound to the global scope that exist before source begins execution. No other objects may be bound to the same identifiers, even in inner scopes.</dd>
                    <dt>element</dt>
                    <dd>A value stored in a container.</dd>
                    <dt>member</dt>
                    <dd>A property or method of an interface.</dd>
                    <dt>method</dt>
                    <dd>A member function of an interface.</dd>
                </dl>
            </div>
        </div>
        <div id="overview">
            <h1>Chapter 2. Overview</h1>
            <p>Desal semantics are represented by a node tree. The way this node tree is represented is not covered in this specification. This specification explains what kind of node tree a representation can represent, the meaning of the nodes in a Desal node tree, and how to evaluate the node tree.</p>
            <p>This node tree has scopes attached at various places. These scopes contain identifiers that are bound to namespaces and references. Thus, a Desal implementation must code for a node tree, scopes, objects, and functions.</p>
            <div id="ext-namespace">
                <h2>2.1. ext namespace</h2>
                <p>Unofficial features of Desal should appear in the "ext" namespace when possible. Implementations do not have to recognize extensions or support them, although they are encouraged to at least recognize them in order to give more useful error messages.</p>
                <code xml:space="preserve">
import atExit from ext

atExit.add(myfunc)
</code>
            </div>
            <div id="expressions">
                <h2>2.2. Expressions</h2>
                <p>Expressions evaluate to an value.</p>
            </div>
            <div id="references">
                <h2>2.3. references</h2>
                <p>Identifiers can be associated with values, references, and namespaces. There are multiple types of references. References are created by declaration nodes that associate an identifier with a new reference. Declarations specify what the reference can be bound to.</p>
                <div id="value-identifiers">
                    <h3>2.3.1. value identifier</h3>
                    <p>A value identifier is a associated with a value. It can never be reassociated with a different value.</p>
                </div>
                <div id="reference-identifiers">
                    <h3>2.3.2. Reference identifiers</h3>
                    <p>A reference identifier is associated with a reference. That reference can be bound to values with with the active interface specified by the associated declaration. (i.e. The associated identifier declaration specifies an interface, and the reference can only be bound to values with that interface as the active interface.) References can also be unbound i.e. bound to nothing i.e. bound to null. The identifier can only ever be bound to one object reference at a time.</p>
                </div>
                <div id="function-identifiers">
                    <h3>2.3.3. function identifier</h3>
                    <p>Function identifiers are associated with references that can be bound to multiple values with a specified function interface as the active interface.</p>
                </div>
                <div id="namespace-identifiers">
                    <h3>2.3.4. namespace identifier</h3>
                    <p>Namespace identifiers can be associated with a namespace. (Only 1 at any time.) These and alias identifiers are the only types of identifiers that cannot be evaluated.</p>
                </div>
                <div id="dynamic-identifiers">
                    <h3>2.3.5. dynamic identifier</h3>
                    <p>Dynamic identifiers are associated with references that can be bound to any value, with any active interface. (Only 1 at any time.)</p>
                    <code xml:space="preserve">
interface Foo
        func fooMeth()

interface Bar
        func barMeth()

Dyn obj = getFoo()
obj.fooMeth()
obj = getBar()
obj.barMeth()
</code>
                    <p>Dyn identifiers are associated with references that can point to values. At all times, one of the interface implementations of the object's class is the active interface. When accessing properties of the pointed-to-object, which properties are available and what they do is determined by the active interface. The active interface and the pointed-to object can both be changed.</p>
                    <code xml:space="preserve">
dyn foo //same as: dyn foo = null
foo = getBar()
foo.barProp
foo = 3
foo.minus(5)
foo = "test"
foo.toUpperCase()
foo = CMyClass()
foo.myClassProp
foo = cast {BazInterface} alpha
foo.bazProp
foo = cast {MazInterface} alpha
foo.mazProp
foo = cast {GazInterface} alpha
foo.gazProp
(BazInterface foo) .bazProp
(MazInterface foo) .mazProp
</code>
                </div>
                <div id="meta-identifiers">
                    <h3>2.3.6. meta identifier</h3>
                    <p>Meta identifiers are associated with references that can be bound to vaules with MetaObject as the active interface. The difference between this identifier type and the reference identifier type is that members of the MetaObject (xxx link to MetaObject spec) are not exposed through this reference. Instead, any attempted member access calls methods of the MetaObject implementation.</p>
                    <code xml:space="preserve">
interface MetaObject
        func handleCall(String identifier, Dyn[] arguments) Dyn
        func handlePropGet(String identifier) Dyn
        func handlePropSet(String identifier, Dyn value)
        func handleCallMethod(String identifier, Dyn[] arguments) Dyn
        func handleCast(Interface iface) Dyn

class CMeta
        interface MetaObject
                ...

Meta obj = CMeta()
obj.foo = "hey hey he"
obj.foo = [1, 2, 3]
obj.bar = obj.notheutnhoetnhu
obj.heyPeople()
obj.HowsItGoing?(obj.n789, obj.immaGoNow())
</code>
                </div>
            </div>
            <div id="execution">
                <h2>2.4. Execution</h2>
                <p>Some nodes can be executed.</p>
            </div>
            <div id="builtin-numbers">
                <h2>2.5. Built-in numbers</h2>
                <p>The built-in implementations of the Int and Rat interfaces must be able to handle numbers of an arbitrary complexity. Built-in libraries should handle numbers of an arbitrary complexity. Desal implementations must not ever introduce rounding errors or otherwise introduce numerical errors without being explicitly told that such errors may occur.</p>
                <p>For example, pow(10, pow(10,100)), must correctly return an Int object reference that accurately represents a googolplex, and must be able to perform operations on this number with perfect accuracy.</p>
                <p>Implementations may throw errors when they are unable to perfectly represent a number. This is the only alternative to perfectly representing the number, unless user code has explicitly allowed the implementation to introduce errors. Implementations must not introduce errors by default.</p>
                <p>For example, if the implementation was directed by user code to print a googolplex without using scientific notation (i.e. a "1" followed by a googol "0"), the implementation may throw an error specifying that it is unable to create such a representation.</p>
            </div>
        </div>
        <div id="objects">
            <h1>Chapter 3. Objects</h1>
            <p>Objects have state which is modified through interfaces. Every object has an ID that never charges. Objects implement interfaces. Each interface implementation consists of the implementation of the members of that interface.</p>
            <p>Every objects implements one or more interfaces. Interfaces are objects. Objects are accessed through interfaces.</p>
        </div>
        <div id="functions">
            <h1>Chapter 4. Functions</h1>
            <p>Functions have an associated object. When identifiers that are bound to functions are evaluated, they evaluted to this object.</p>
            <p>Functions have a return interface and parameters. Parameters have an interface and an optional default value.</p>
        </div>
        <div id="interfaces">
            <h1>Chapter 5. Interfaces</h1>
            <p>Interfaces define a means of interacting with an object. Interfaces declare that implementations will be able to provide object references with specified interfaces when asked for the object reference bound to identifiers specified by the interface and/or that implementations will be able to bind object references with specified interfaces to specified identifiers. Methods are a type of property. Methods are callable and cannot be assigned, only retrieved.</p>
            <p>Interfaces can declare that properties are "read only", "write only", or "read+write".</p>
            <p>Interface member functions can have default values. This differs from a class with abstract members because interfaces cannot have any private members, so these default functions can not store or extract state in the object. These functions are only intended to call other member functions or throw errors.</p>
            <p>There are two kinds of interfaces: object interfaces (Interface) and function interfaces (FuncInterface). Object interfaces define properties and methods. Function interfaces define parameters and a return type. An interface cannot be a function interface and an object interface, though an object interface can have call methods that allow implementations to be used like functions. A function interface can be wrapped to an object interface with a single call method.</p>
            <p>Interface callees and members may refer to the interface. This is useful when an interface wants to define a method that returns an object reference with itself as the active interface. For generic interfaces, it is also possible to refer to the generic template.</p>
            <code xml:space="preserve">
interface Int
        func power(Self) Self
        r Self timesTwo

//some representations may be able to translate the below example as well

iterface Int
        func power(Int) Int
        r Int timesTwo

//note that the interface node will have no knowledge of the identifier it is being bound to

//generics:

interface&lt;T&gt; Print
        callee(T) Self

Print&lt;Int&gt; print = getIntPrinter()
print(3)(5)(8) //the print callee returns a Print&lt;Int&gt; object reference

//refering to Generic interface

interface&lt;T&gt; Print
        callee(T) GenericSelf

Print print = getGenericPrinter()
print &lt;Int&gt;(3) &lt;String&gt;("foo") &lt;Rat&gt;(1.23)

//some representations may also allow:
print 3 "foo" 1.23
</code>
            <div id="adding-interfaces">
                <h2>5.1. Adding and Subtracting Interfaces</h2>
                <p>Interfaces can be added together to produce other interfaces. How this addition occurs depends on whether the operands were produce through addition, and the inherited interfaces of the operands.</p>
                <p>If an interface is "fromAddition", it was produced through addition and/or subtract. The 
                <a href="#ident.Interface">Interface interface</a>exposes this information as a property.</p>
                <p>Interfaces produced from addition don't define any members themeselves; they only inherit from other interfaces.</p>
                <p>No interface can inherit from an interface that is fromAddition. When a fromAddition interface is an operand of interface addition, the inheritees of the fromAddition interface are copied into the produced interface, but the produced interface does not inherit from the fromAddition operands.</p>
                <p>No interface that is fromAddition can inherit from a single interface. When subtracting from a fromAddition interface, and the produced interface would have otherwise only inherited from a single interface, the produced interface is actually that single interface that it would have inherited from.</p>
                <pre>
interface A
        fromAddition = false

interface B
        fromAddition = false

interface C
        fromAddition = true

interface D
        fromAddition = true

interface A+B
        inherit A
        inherit B

interface A+C
        inherit A
        C's inheritees (doesn't inherit from C)

interface A+D
        inherit A
        D's inheritees (doesn't inherit from D)

interface B+C
        inherit B
        C's inheritees (doesn't inherit from C)

interface B+D
        inherit B
        D's inheritees (doesn't inherit from D)

interface C+D
        C's inheritees (doesn't inherit from C)
        D's inheritees (doesn't inherit from D)

(A+B)-B must be A, not a fromAddition interface that inherits only from A.

consider this expression:
        (A+B+C)-(B+C)
if:
        * C is fromAddition
        * A and B are not fromAddition
        * C inherits from C1, C2, and C3
then the expresison is equal to:
        (A+B+C1+C2+C3)-(B+C1+C2+C3)
        (A+B+C1+C2+C3)-B-C1-C2-C3
        A
</pre>
                <p>xxx ENSURE ORDER DOESN'T MATTER</p>
                <p>Addition with operands A and B:</p>
                <ol>
                    <li>Create an interface, PRODUCT, where fromAddition is true.</li>
                    <li>If A is fromAddition, copy the inheritees of A to PRODUCT. If A is not fromAddition, add A as an inheritee to PRODUCT.</li>
                    <li>If B is fromAddition, copy the inheritees of B to PRODUCT. If B is not fromAddition, add B as an inheritee to PRODUCT.</li>
                    <li>If PRODUCT has only one inheritee, evaluate this addition to that inheritee. Otherwise, evaluate this addition to PRODUCT.</li>
                </ol>
                <p>Note: An example of when PRODUCT would only have one inheritee from addition is when an interface that is not fromAddition is added to itself. i.e. A + A = A</p>
                <p>Subtraction with operands A and B:</p>
                <ol>
                    <li>If A is not fromAddition, throw an error.</li>
                    <li>Copy A as PRODUCT. (i.e. Copy A. We'll refer to this copy as PRODUCT.)</li>
                    <li>If B is fromAddition, remove every inheritee of B from the inheritees of PRODUCT. If any of the inheritees of B is not an inheritee of PRODUCT, throw an error.</li>
                    <li>If B is not fromAddition, remove B from the inheritees of PRODUCT. If B is an inheritee of PRODUCT, throw an error.</li>
                    <li>If PRODUCT has only one inheritee, evaluate this subtraction to the inheritee. If PRODUCT does not have any inheritees, throw an error. Otherwise, evaluate this subtraction to PRODUCT.</li>
                </ol>
            </div>
        </div>
        <div id="special-members">
            <h1>Chapter 6. Special members</h1>
            <p>Some identifiers can only be bound to certain types of properties and methods, and have a predefined meaning. Thus, the semantics of a member with one of these identifiers is already predefined by this specification.</p>
            <p>Many of these special predefined members come in mutating and non-mutating forms. In these cases, the mutating form modifies the object and returns nothing while the non-mutating form returns a copy of the object with the mutation.</p>
            <p>Implementations must prevent identifiers from being bound to other types. Implementations are encouraged to provide shortcuts for accessing/using these members. Some examples in this section show a possible usage of the methods with and without shortcuts.</p>
            <p>add, subtract, multiply, divide, add!, subtract!, multiply!, divide!, equals?, lessThan?, lessThanOrEqual?, equal?, greaterThanOrEqual?, greaterThan?, unequal?, remainder, remainder!, floorDivide, floorDivide!, power, power!, absolute, absolute!, positive?, negative?, concat, concat!, remove, remove!</p>
            <div id="member.add">
                <h2>6.1. add</h2>
                <pre>
func add(Self) Self
</pre>
                <pre>
func add!(Self)
</pre>
                <p>Inserts an object into a container, joins data together, sends an object to something, etc. This method should only be used when order is not significant, such as when adding integers. When order is significant, such as when concatenating strings, the 
                <a href="#member.insert">insert method</a>would be more appropriate.</p>
                <code xml:space="preserve">
Int a = 1.add(2)
a.add!(3)

Int a = 1 + 2
a += 3
</code>
            </div>
            <div id="member.equals">
                <h2>6.2. equals?</h2>
                <pre>
func equals?(Self o) Bool
</pre>
                <p>Tells whether the owner value and the argument value both have state for the interface that, from the outside, appears the same.</p>
                <code xml:space="preserve">
if( a == b )
        print "they equal each other"
</code>
            </div>
            <div id="member.extract">
                <h2>6.3. extract</h2>
                <p>
                <pre>
func extract!() Foo
</pre>Throws if there is nothing to extract.</p>
                <p>
                <pre>
func extract!(out Foo) Bool
</pre>Returns false if there is nothing to extract.</p>
                <code xml:space="preserve">
println container.extract!()
while container &gt;&gt; obj
        println obj
</code>
            </div>
            <div id="member.insert">
                <h2>6.4. insert</h2>
                <pre>
func insert(Self) Self
</pre>
                <pre>
func insert!(Self)
</pre>
                <p>Inserts an object into a container, joins data together, sends an object to something, etc. This method should only be used when order is significant, such as when concatenating strings. When order is not significant, such as when adding integers, the 
                <a href="#member.add">add method</a>would be more appropriate.</p>
                <code xml:space="preserve">
String a = "foo".insert("bar")
a.insert!("gaz")

String a = "foo" &amp; "bar"
a &lt;&lt; "gaz"
</code>
            </div>
            <div id="member.throwDivide">
                <h2>6.5. throwDivide</h2>
                <pre>
func throwDivide(Int) Int
</pre>
                <pre>
func throwDivide(Rat) Int
</pre>
                <pre>
func throwDivide!(Int)
</pre>
                <pre>
func throwDivide!(Rat)
</pre>
                <p>Throws an error if the result is not an integer.</p>
            </div>
        </div>
        <div id="object-references">
            <h1>Chapter 7. Object references</h1>
            <p>Objects are referred to through references. A reference is associated with an interface and an object. Objects may implement multiple interfaces with the same property names, so reference serve to declare from which interface properties can be accessed. References can be cast to other references that are associated with the same object but a different interface to allow accessing properties .</p>
        </div>
        <div id="scopes">
            <h1>Chapter 8. Scopes</h1>
            <p>Scopes consist of a collection of identifiers and an optional association with a parent scope. Each identifier is declared to be capable of pointing to one of: a namespace, objects with a certain interface, functions with a certain return interface. Identifiers are also capable of pointing to null. Each identifier is either bound to: a namespace/object/function (depending on which it can point to), or null. Scopes may be associated with a single parent scope.</p>
            <p>xxx should namespace identifiers and function identifiers be able to point to null?</p>
        </div>
        <div id="nodes">
            <h1>Chapter 9. Nodes</h1>
            <p>Desal semantics are represented by a tree of nodes. How this tree and its nodes are represented is outside the scope of this specification. Many means may exist of representing a Desal tree.</p>
            <p>Nodes are either base nodes or tree nodes. Tree nodes only contain other nodes, and their entire meaning is derived from their child nodes. Base nodes do not contain any other child nodes, and must is some way encode their meaning themselves.</p>
            <p>When a node has multiple child nodes with equivalent meaning, the order of those child nodes is significant, so their order must be specified by some means. The order of nodes of different meaning in relation to each other is not significant, and must not have any observable side effects.</p>
            <p>The child nodes of tree nodes are sometimes executed in order, such as statements in blocks and arguments in function calls. This means the order of the child nodes is sometimes significant and thus should always be preserved.</p>
            <p>How ordering is represented has no effect on the semantics (left-to-right, numbered, linked list, etc) as long as there is a specified order. Each representation should specify how nodes are ordered.</p>
            <p>Node type names are nouns or noun phrases. XXX find correct English terminology</p>
            <div id="node-terminology">
                <h2>9.1. Node terminology</h2>
                <p>If a node can contain other nodes, it is a tree node. If a node is contained directly inside another node, the inner node is the child of the outer node, and the outer node is the parent of the inner node. If a node is contained inside another node, but not directly, the inner node is the descendant of the outer node, and the outer node is the ancestor of the inner node.</p>
                <p>Statement nodes can be executed. When statements are executed, they may perform some kind of action. Statements can have side effects.</p>
                <p>Expressions can also be executed, but in addition, after execution an object reference is produced (xxx object reference = object + interface ie struct of pointers).</p>
            </div>
            <div id="tree-node-layout">
                <h2>9.2. Tree node layout</h2>
                <p>The number, type, and order of a tree nodes children is determined by the tree node's layout.</p>
            </div>
            <div id="node-supertypes">
                <h2>9.3. Node supertypes</h2>
                <p>The "Expression" and "Statement" types are each actually a family of types. Where the layout for a tree node specifies that a child node is an Expression node, that child node can be any expression in section XXX. Similarly, when the layout for a tree node specifies that a child node is a Statement node, that child node may be of any type in section XXX.</p>
            </div>
        </div>
        <div id="node-types">
            <h1>Chapter 10. Node types</h1>
            <p>This chapter describes the various types of nodes.</p>
            <div id="base-node-types">
                <h2>10.1. Base node types</h2>
                <p>These node types do not contain child nodes, and are thus the only nodes that must encode information themselves (as opposed to containing child nodes which together provide information).</p>
                <ul>
                    <li>
                        <a href="#node.access">access</a>
                    </li>
                    <li>
                        <a href="#node.bool">bool</a>
                    </li>
                    <li>
                        <a href="#node.identifier">identifier</a>
                    </li>
                    <li>
                        <a href="#node.reference-category">reference-category</a>
                    </li>
                    <li>
                        <a href="#node.identifier-category">identifier-category</a>
                    </li>
                    <li>
                        <a href="#node.integer">integer</a>
                    </li>
                    <li>
                        <a href="#node.rational">rational</a>
                    </li>
                    <li>
                        <a href="#node.string">string</a>
                    </li>
                </ul>
            </div>
            <div id="tree-node-layout-representation">
                <h2>10.2. Tree node layout representation</h2>
                <p>This section describes how the layout of a node type is represented in this specification.</p>
                <p>The layout for a node type is represented in this specification as a list of items. Each item represents a child node or multiple child nodes with the same meaning. Nodes represented by different items are considered to have different meaning.</p>
                <p>Each item in these lists first specifies how many child nodes with that meaning may appear, or it says nothing about the number, which means there must be one (and only one). The ways of representing these amounts is described below.</p>
                <dl>
                    <dt>?</dt>
                    <dd>0 or 1</dd>
                    <dt>*</dt>
                    <dd>0 or more</dd>
                    <dt>+</dt>
                    <dd>1 or more</dd>
                    <dt>2</dt>
                    <dd>2 (used only for the 
                    <a href="#node.enum">enum</a>node)</dd>
                </dl>
                <p>Next comes the name of a node type. The child node represented by that list item must be of that type, unless the type is Expression or Statement, in which case the child node's type must be a member of the Expression on Statement family, respectively. See section XXX for more information.</p>
                <p>Lastly comes a label for refering to the child nodes with that meaning. These labels carry no semantic information, and are only a means used to refer to specific nodes. The meaning of child nodes can certainly be represented by other means. However, people creating representations for Desal trees are encouraged to at least consider using these same labels when it makes sense to do so.</p>
            </div>
            <div id="nonexecuted-node-types">
                <h2>10.3. Nonexecuted node types</h2>
                <p>These nodes cannot be executed (and thus also cannot be evaluated).</p>
                <div id="node.comment">
                    <h3>10.3.1. comment</h3>
                    <p>Comments are text nodes. Comments nodes may appear as children of any tree node. Comment nodes describe the node that they are contained in. Comment nodes must not have any affect on execution or evaluation.</p>
                </div>
                <div id="node.namespace-reference">
                    <h3>10.3.2. namespace-reference</h3>
                    <ul class="layout">
                        <li>+ 
                        <a href="#node.identifier">identifier</a></li>
                    </ul>
                    <p>Used to refer to a namespace that is the child of another namespace.</p>
                </div>
                <div id="node.reference-type">
                    <h3>10.3.3. reference-type</h3>
                    <ul class="layout">
                        <li>
                            <a href="#node.reference-category">reference-category</a>
                        </li>
                        <li>? 
                        <a href="#node.expression">expression</a>interface</li>
                    </ul>
                    <p class="process">If [reference-category] is dyn, [interface] must not be present. (If [reference-category] is function or value, [interface] may be required by a parent node, but not necesarrily, so its not required here.)</p>
                </div>
                <div id="node.reference-category">
                    <h3>10.3.4. referenc-category</h3>
                    <p>Specifies one of: value, function, dyn</p>
                </div>
                <div id="node.identifier-category">
                    <h3>10.3.5. identifier-category</h3>
                    <p>Specifies one of: value, function, dyn, namespace, alias</p>
                </div>
                <div id="node.parameter">
                    <h3>10.3.6. parameter</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.identifier">identifier</a>name</li>
                        <li>
                        <a href="#node.expression">expression</a>interface</li>
                        <li>? 
                        <a href="#node.expression">expression</a>default-value</li>
                    </ul>
                    <p>A function parameter.</p>
                </div>
            </div>
            <div id="node.statement">
                <h2>10.4. Statement node types</h2>
                <div id="node.block">
                    <h3>10.4.1. block</h3>
                    <ul class="layout">
                        <li>* 
                        <a href="#node.statement">statement</a>statements</li>
                    </ul>
                    <p>Has scope.</p>
                    <p>Note: This node type is different from the Dextr concept of blocks. To differentiate between the two, nodes of this type can be called "node blocks", "statement blocks", or "semantic blocks". The syntactic construct can be called "Dextr blocks" or "syntatic blocks".</p>
                </div>
                <div id="node.conditional-block">
                    <h3>10.4.2. conditional-block</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>test</li>
                        <li>
                        <a href="#node.block">block</a>action</li>
                    </ul>
                    <p class="process">An error results if the implementation knows the test will never evaluate to a value with Bool as the active interface.</p>
                    <p class="exec">Evaluate the test. If the active interface isn't Bool, raise an error. If it is true, execution the action.</p>
                </div>
                <div id="node.declaration">
                    <h3>10.4.3. declaration</h3>
                    <ul class="layout">
                        <li>
                            <a href="#node.identifier">identifier</a>
                        </li>
                        <li>
                            <a href="#node.reference-type">reference-type</a>
                        </li>
                    </ul>
                    <p>Declares an identifier in the current scope. The reference-type must declare an interface if the category is function or value.</p>
                    <p>when [reference-type] is function:</p>
                    <p>Declares a variable function identifier in the current scope, which can later be bound and unbound from various functions. A function identifier can be bound to multiple functions (objects that implement the function interface) at the same time. Every function it is bound to must have the return type specified by this node.</p>
                    <p>After this node executes, identifier does not yet point to a function object; i.e. it "points at" null. A function identifier can never be bound to multiple functions with the same interface (meaning each function must have different parameters).</p>
                    <code xml:space="preserve">
decl func int foo //function-identifier-declaration
foo = func()int { return 3 }
foo = func(int a)int { return a * 2 }
print foo() //prints 3
print foo(2) //prints 4
foo = func()int { return 5 } //error - already pointing at function with this interface
</code>
                    <p>when [reference-type] is value:</p>
                    <p>Declares a variable object identifier in the current scope. It does not yet point at on object; i.e. it "points at" null. The identifier can only refer to values that implement the interface specified by the [reference-type].</p>
                    <code xml:space="preserve">
func()int foo //object-identifier-declaration
foo = func()int { return 3 }
print foo() //prints 3
foo = func()int { return 5 }
print foo() //prints 5
foo = func(int a)int { return a * 2 } //error - interface mismatch
</code>
                    <p>when [reference-type] is dyn:</p>
                    <p>Declares a variable object identifier in the current scope. It does not yet point at on object; i.e. it "points at" null. The identifier can refer to any value.</p>
                </div>
                <div id="node.do-while">
                    <h3>10.4.4. do-while</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>test</li>
                        <li>
                        <a href="#node.block">block</a>block</li>
                    </ul>
                </div>
                <div id="node.do-times">
                    <h3>10.4.5. do-times</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[times]</li>
                        <li>
                            <a href="#node.block">block</a>
                        </li>
                    </ul>
                </div>
                <div id="node.enum">
                    <h3>10.4.6. enum</h3>
                    <p>An enum is similar to an immutable dict.</p>
                    <pre>
interface&lt;T, U&gt; Enum
        inherit Collection&lt;T&gt;
        r Int size
        func key(String str) T
        func fromValue(U val) T

interface&lt;T&gt; EnumElement
        inherit Stringable
        r T value

interface Stringable
        r String str

Enum and EnumElement cannot be implemented manually.

These two interfaces are used in the examples below:

interface {{AnimalInterface}}
        inherit EnumElement&lt;Int&gt;

interface {{Properties}}
        inherit Enum&lt; {{AnimalInterface}}, Int &gt;
        r {{AnimalInterface}} dog
        r {{AnimalInterface}} cat
        r {{AnimalInterface}} fish
        r {{AnimalInterface}} parrot
        r {{AnimalInterface}} ferret
        r {{AnimalInterface}} gerbil
        r {{AnimalInterface}} hamster

When [value-type] is not given:
        no entries can have values
        the value property of EnumEntry will return null
        the fromValue method of Enum will return null

When a [value-type] is given, all entries must have values.

Multiple identifiers can be assigned the same value. In such a case, each identifier will refer to the same object, and the str property of that object will give the first identifier as a string.

layout:
        identifier [interface]
        ? expression [value-type]
        ? bool [expose]
        (+ identifier [name]) | (+ enum-entry [element])

enum-entry layout:
        identifier [name]
        ? expression [value]

----- example 1

enum Animal {
        dog, cat, fish, parrot, ferret, gerbil, hamster
}

Animal a = Animal.dog
Animal b = Animal["cat"]
println Animal.size

for animal in Animal
        println animal.str " " animal.value

----- example 2

enum Animal expose {
        DOG, CAT, FISH, PARROT, FERRET, GERBIL, HAMSTER
}

Animal a = Animal.DOG
Animal b = Animal["CAT"]
Animal c = FISH
println Animal.size

for animal in Animal
        println animal.str " " animal.value

-----

typeOf(Animal) == Interface + {{Properties}}
(Animal as Interface) == {{AnimalInterface}}
typeOf(DOG) == typeOf(Animal.DOG)
</pre>
                </div>
                <div id="node.for">
                    <h3>10.4.7. for</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>initializers</li>
                        <li>? 
                        <a href="#node.expression">expression</a>test</li>
                        <li>
                        <a href="#node.expression">expression</a>counters</li>
                        <li>
                            <a href="#node.block">block</a>
                        </li>
                    </ul>
                    <p>Like C(++) for loops.</p>
                </div>
                <div id="node.for-key">
                    <h3>10.4.8. for-key</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[container]</li>
                        <li>
                            <a href="#node.identifier">identifier</a>
                        </li>
                        <li>
                            <a href="#node.block">block</a>
                        </li>
                    </ul>
                    <ol class="exec">
                        <li>1. Call getKeyIterator on [container].</li>
                        <li>2. Call getNext on [1]. If an exception is thrown with an active interface of GeneratorDone, swallow it and end execution. If anything else is thrown, follow normal exception rules.</li>
                        <li>3. Create a scope.</li>
                        <li>4. Bind [2] to [identifier] in [3].</li>
                        <li>5. Execute [block] with scope [3].</li>
                        <li>6. Go to step 2.</li>
                    </ol>
                    <code xml:space="preserve">
for key x in foo
        doStuff(x)
</code>
                </div>
                <div id="node.for-pair">
                    <h3>10.4.9. for-pair</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[container]</li>
                        <li>
                        <a href="#node.identifier">identifier</a>[key-identifier]</li>
                        <li>
                        <a href="#node.identifier">identifier</a>[value-identifier]</li>
                        <li>
                            <a href="#node.block">block</a>
                        </li>
                    </ul>
                    <code xml:space="preserve">
for pair x y in coords
        drawPoint(x, y)
</code>
                </div>
                <div id="node.for-range">
                    <h3>10.4.10. for-range</h3>
                    <ul class="layout">
                        <li>? 
                        <a href="#node.identifier">identifier</a>carrier</li>
                        <li>
                        <a href="#node.expression">expression</a>start</li>
                        <li>
                        <a href="#node.expression">expression</a>limit</li>
                        <li>? 
                        <a href="#node.bool">bool</a>inclusive</li>
                        <li>? 
                        <a href="#node.expression">expression</a>test</li>
                        <li>
                            <a href="#node.block">block</a>
                        </li>
                    </ul>
                    <code xml:space="preserve">
for 0 to 100
        println "test"

for x from 0 to 100
        println x

for x from 0 to 100 inclusive
        println x

for 0 to string.length while not container.full
        container.push( string.unshift!() )

for x from 0 to 100 while not foo.done
        foo.runTest(x)
</code>
                </div>
                <div id="node.for-value">
                    <h3>10.4.11. for-value</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[container]</li>
                        <li>+ 
                        <a href="#node.identifier">identifier</a>[value-identifier]</li>
                        <li>
                            <a href="#node.block">block</a>
                        </li>
                    </ul>
                    <code xml:space="preserve">
for name in names
        println name
</code>
                </div>
                <div id="node.if-else">
                    <h3>10.4.12. if-else</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.conditional-block">conditional-block</a>possible actions</li>
                        <li>? 
                        <a href="#node.block">block</a>default action</li>
                    </ul>
                    <p>Evaluates the test of each possible action until it finds one that evaluates to true, and executes the action associated with that possible action. If none of the possible actions have a test that evaluates to true, and a default action is specified, execute the default action. If test of any of the possible actions evaluates to a value that doesn't have Bool as the active interface, an error results.</p>
                </div>
                <div id="node.import">
                    <h3>10.4.13. import</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.string">string</a>library</li>
                        <li>? 
                        <a href="#node.identifier">identifier</a>library alias</li>
                        <li>* 
                        <a href="#node.alias-member">alias-member</a></li>
                    </ul>
                    <p>The import nodes binds values from other files or libraries to in scope identifier-references.</p>
                    <code xml:space="preserve">
import "XmlLib" as Xml
/*
library: "XmlLib"
library alias: Xml */

from "XmlLib" import XmlDocument as Doc
/*
library: "XmlLib"
library alias: (not given)
alias-member: XmlDocument, Doc */

from "XmlLib" as Xml import XmlDocument as Doc
/*
library: "XmlLib"
library alias: Xml
alias-member: XmlDocument, Doc */

from "XmlLib" as Xml import XmlReader, XmlDocument as Doc, XmlElement
/*
library: "XmlLib"
library alias: Xml
alias-member: XmlReader
alias-member: XmlDocument, Doc
alias-member: XmlElement */

from "XmlLib" as Xml import
        XmlReader,
        XmlDocument as Doc,
        XmlElement
</code>
                    <div id="node.alias-member">
                        <h4>10.4.13.1. alias-member</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.identifier">identifier</a>target</li>
                            <li>? 
                            <a href="#node.identifier">identifier</a>new name</li>
                        </ul>
                    </div>
                </div>
                <div id="node.import-all">
                    <h3>10.4.14. import-all</h3>
                    <p class="layout">string library</p>
                    <p>Imports every identifier-reference in the library.</p>
                    <code xml:space="preserve">
import all from "XmlLib"
//library: "XmlLib"
</code>
                </div>
                <div id="node.loop">
                    <h3>10.4.15. loop</h3>
                    <p class="layout">block</p>
                    <p>Executes block continuously. Can only be exited by statements in the block such as break and return.</p>
                </div>
                <div id="node.return">
                    <h3>10.4.16. return</h3>
                    <p class="layout">expression</p>
                    <p>Function call ends and evaluates to expression.</p>
                </div>
                <div id="node.while">
                    <h3>10.4.17. while</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[test]</li>
                        <li>
                            <a href="#node.block">block</a>
                        </li>
                    </ul>
                </div>
            </div>
            <div id="node.expression">
                <h2>10.5. Expression tree node types</h2>
                <div id="boolean-logic-nodes">
                    <h3>10.5.1. Boolean logic nodes</h3>
                    <p>Boolean logic nodes take two boolean values and evaluate to a boolean value. During evaluation, if casting an object reference to Bool produces an error, end evaluation and allow the exception to rise. Some boolean logic nodes can do shortcutting, meaning they do not evaluate the second node if the result of the node is already known.</p>
                    <p>Boolean logic nodes have this layout:</p>
                    <ul class="layout">
                        <li>
                            <a href="#node.expression">expression</a>
                        </li>
                        <li>
                            <a href="#node.expression">expression</a>
                        </li>
                    </ul>
                    <div id="node.and">
                        <h4>10.5.1.1. and</h4>
                        <p>Evaluates to false if either child expression evaluates to false.</p>
                        <p>Evaluation:</p>
                        <ol class="eval">
                            <li>1. Evaluate the first [expression] node.</li>
                            <li>2. Cast [1] to Bool.</li>
                            <li>3. If [2] is false, evaluate this node to false.</li>
                            <li>4. Evaluate the second [expression] node.</li>
                            <li>5. Cast [4] to Bool.</li>
                            <li>6. Evaluate this node to [5].</li>
                        </ol>
                    </div>
                    <div id="node.nand">
                        <h4>10.5.1.2. nand</h4>
                        <p>Evaluates to true if either child expression evaluates to false.</p>
                        <p>Evaluation:</p>
                        <ol class="eval">
                            <li>1. Evaluate the first [expression] node.</li>
                            <li>2. Cast [1] to Bool.</li>
                            <li>3. If [2] is false, evaluate this node to true.</li>
                            <li>4. Evaluate the second [expression] node.</li>
                            <li>5. Cast [4] to Bool.</li>
                            <li>6. Evaluate this node to the inverse of [5].</li>
                        </ol>
                    </div>
                    <div id="node.or">
                        <h4>10.5.1.3. or</h4>
                        <p>Evaluates to true if either child expression evaluates to true.</p>
                        <p>Evaluation:</p>
                        <ol class="eval">
                            <li>1. Evaluate the first [expression] node.</li>
                            <li>2. Cast [1] to Bool.</li>
                            <li>3. If [2] is true, evaluate this node to true.</li>
                            <li>4. Evaluate the second [expression] node.</li>
                            <li>5. Cast [4] to Bool.</li>
                            <li>6. Evaluate this node to [5].</li>
                        </ol>
                    </div>
                    <div id="node.nor">
                        <h4>10.5.1.4. nor</h4>
                        <p>Evaluates to false if either child expression evaluates to true.</p>
                        <p>Evaluation:</p>
                        <ol class="eval">
                            <li>1. Evaluate the first [expression] node.</li>
                            <li>2. Cast [1] to Bool.</li>
                            <li>3. If [2] is true, evaluate this node to false.</li>
                            <li>4. Evaluate the second [expression] node.</li>
                            <li>5. Cast [4] to Bool.</li>
                            <li>6. Evaluate this node to the inverse of [5].</li>
                        </ol>
                    </div>
                    <div id="node.xor">
                        <h4>10.5.1.5. xor</h4>
                        <p>Evaluates to true if the child expressions evaluate to different values.</p>
                        <p>Evaluation:</p>
                        <ol class="eval">
                            <li>1. Evaluate the first [expression] node.</li>
                            <li>2. Cast [1] to Bool.</li>
                            <li>3. Evaluate the second [expression] node.</li>
                            <li>4. Cast [3] to Bool.</li>
                            <li>5. If [2] and [4] are different, evalute to true. Otherwise, evaluate to false.</li>
                        </ol>
                    </div>
                    <div id="node.xnor">
                        <h4>10.5.1.6. xnor</h4>
                        <p>Evaluates to true if the child expressions evaluate to the same value.</p>
                        <p>Evaluation:</p>
                        <ol class="eval">
                            <li>1. Evaluate the first [expression] node.</li>
                            <li>2. Cast [1] to Bool.</li>
                            <li>3. Evaluate the second [expression] node.</li>
                            <li>4. Cast [3] to Bool.</li>
                            <li>5. If [2] and [4] are the same, evalute to true. Otherwise, evaluate to false.</li>
                        </ol>
                    </div>
                </div>
                <div id="node.array">
                    <h3>10.5.2. array</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[interface]</li>
                        <li>* 
                        <a href="#node.expression">expression</a>[element]</li>
                    </ul>
                    <p>Evaluates to an object with interface array as the active interface. The object may implement other interfaces if they do not conflict with the array interface.</p>
                    <p>Each [element] is cast to [interface]. If a cast error results, it raises out of the array node, so that the array node doesn't evaluate to anything.</p>
                </div>
                <div id="node.bind">
                    <h3>10.5.3. bind</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.identifier">identifier</a>name</li>
                        <li>
                        <a href="#node.expression">expression</a>value</li>
                    </ul>
                    <p>Binds the value to the identifier. If the identifier's type is not function, the identifier will be unbound first if it is already bound to something. The identifier's type must be value, dyn, meta, or function. If the type is value, meta, or function, the identiifer must be variable. If the value does not implement the interface of the identifier, a cast error results (doesn't apply to dyn).</p>
                </div>
                <div id="node.bind-meta">
                    <h3>10.5.4. bind-meta</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.identifier">identifier</a>name</li>
                        <li>
                        <a href="#node.expression">expression</a>value</li>
                    </ul>
                    <p>Binds a value with MetaValue as the active interface to the specified name. When the value is accessed, methods are called on the MetaValue. The methods of the MetaValue cannot be accessed directly.</p>
                    <code xml:space="preserve">
singleton foo
        interface MetaValue
                func onMethodExecute(string methodName, dyn[] arguments)
                        println arguments.first
declare dyn bar
meta-bind foo to bar
bar.doStuff("test") //prints out "test"
</code>
                </div>
                <div id="node.bool">
                    <h3>10.5.5. bool</h3>
                    <p>Base node. Must specify either true or false. Evaluates to the same identifier as "true" or the same identifier as "false".</p>
                </div>
                <div id="node.method-call">
                    <h3>10.5.6. method-call</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>value</li>
                        <li>
                        <a href="#node.identifier">identifier</a>method name</li>
                        <li>? 
                        <a href="#node.bool">bool</a>mutable</li>
                        <li>* 
                        <a href="#node.expression">expression</a>arguments</li>
                        <li>* 
                        <a href="#node.labeled-argument">labeled-argument</a></li>
                    </ul>
                    <p class="process">If the implementation can determine that the method does not return a value, an error results.</p>
                    <p>If mutable isn't present, it defaults to false.</p>
                    <div id="node.labeled-argument">
                        <h4>10.5.6.1. labeled-argument</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.identifier">identifier</a>label</li>
                            <li>
                            <a href="#node.expression">expression</a>value</li>
                        </ul>
                    </div>
                </div>
                <div id="node.cast">
                    <h3>10.5.7. cast</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[object]</li>
                        <li>
                        <a href="#node.expression">expression</a>[interface]</li>
                    </ul>
                    <p>Evaluates to an object reference where the active interface is [interface] and the object is [object]. If [object] does not implement [interface], an error results.</p>
                    <code xml:space="preserve">
Int o = getIntAndString()
print (o as String).length
</code>
                </div>
                <div id="node.class">
                    <h3>10.5.8. class</h3>
                    <p>Evaluates to a value that, when called, produces other values. The interfaces supported by the produced values are implemented in the way specified by this class node. The active interface of the produced value is specified by this class.</p>
                    <ul class="layout">
                        <li>* 
                        <a href="#node.declaration-class">declaration-class</a>static declarations</li>
                        <li>? 
                        <a href="#node.block">block</a>static constructor</li>
                        <li>* 
                        <a href="#node.function">function</a>static callees</li>
                        <li>* 
                        <a href="#node.class-property">class-property</a>static properties</li>
                        <li>* 
                        <a href="#node.function">function</a>instance constructors</li>
                        <li>* 
                        <a href="#node.declaration-any">declaration-any</a>instance declarations</li>
                        <li>* 
                        <a href="#node.interface-implementation">interface-implementation</a></li>
                    </ul>
                    <p>XXX The static callees and static properties may not always be visible in the class node's scope. (An example of being visible is binding the value produced by the class node to an identifier.) Should some identifier (eg "thisClass") be introduced that evaluates to the class's value? (eg thisClass.property = foo) Or should a general means of accessing the enclosing expression node's value be introduced? (eg thisValue.property = foo)</p>
                    <p>The above is not a problem for interface implementations due to the "this" identifier-reference being bound to the active instance.</p>
                    <p>The children of class nodes can be grouped by several means.</p>
                    <p>By count:</p>
                    <table>
                        <tbody>
                            <tr>
                                <th />
                                <th>public</th>
                                <th>private</th>
                            </tr>
                            <tr>
                                <th>static - only 1</th>
                                <td>callees, getters/setters, methods, interface-implemantations</td>
                                <td>static constructor, instance constructors, static declarations, instance methods</td>
                            </tr>
                            <tr>
                                <th>instance - 1 per instance</th>
                                <td />
                                <td>instance declarations</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>By scopes: (in scope means something can be accessed through a single identifier as a free identifier-reference)</p>
                    <ul>
                        <li>static scope 
                        <ul>
                            <li>public 
                            <ul>
                                <li>defined by: static declarations (as properties and methods; must have access with get and/or set), static properties, instance constructors (as callees)</li>
                                <li>in scope: (none)</li>
                            </ul></li>
                            <li>private 
                            <ul>
                                <li>defined by: static declarations, instance constructors (as functions bound to "construct")</li>
                                <li>in scope: static constructor, callees, getters/setters, methods, expressions in static declarations</li>
                            </ul></li>
                        </ul></li>
                        <li>instance scope 
                        <ul>
                            <li>public 
                            <ul>
                                <li>defined by: interface-implementations (or really, by the interface)</li>
                                <li>in scope: (none)</li>
                            </ul></li>
                            <li>private 
                            <ul>
                                <li>defined by: instance declarations, instance methods</li>
                                <li>in scope: expressions in instance declarations, instance methods, interface implementations, instance constructors</li>
                            </ul></li>
                        </ul></li>
                    </ul>
                    <p>Note: Instance scopes are children of the static scope.</p>
                    <p class="process">Must have at least one interface-implementation. Including the interface-implementation nodes that are inherited by this class's child interface-implementation nodes, one and only one of the interface-implementation nodes must be specified as default.</p>
                    <ol class="eval">
                        <li>Create scope, STATIC_SCOPE.</li>
                        <li>Create an interface, CLASS_INTERFACE.</li>
                        <li>Add instance constructors as free functions to STATIC_SCOPE.</li>
                        <li>Add instance constructors as callees to CLASS_INTERFACE.</li>
                        <li>Evaluate every declaration-class that has a declaration-prevalent in the scope of STATIC_SCOPE. If the reference-type of the declaration-prevalent is function, and it has access of get, add a method to CLASS_INTERFACE with the same function interface and name. Otherwise, create a property with a getter if declared public.</li>
                        <li>Evaluate the rest of the declaration-class nodes in the scope of STATIC_SCOPE, except for the declaration-class nodes with a declaration-const-empty. Create properties as appropriate when the access nodes specify to do so.</li>
                        <li>In the scope of STATIC_SCOPE, evaluate the declaration-class nodes that have declaration-const-empty nodes. Create properties as appropriate when the access nodes specify to do so.</li>
                        <li>Add the static callees as free functions in STATIC_SCOPE.</li>
                        <li>Add the static callees and the static properties to CLASS_INTERFACE.</li>
                        <li>Execute the static constructor.</li>
                        <li>Seal the identifier-references created by the declaration-const-empty nodes, meaning don't allow their bound status to change.</li>
                        <li>Create a value with CLASS_INTERFACE as the active interface.</li>
                        <li>Evaluate this node to the above value.</li>
                    </ol>
                    <p>When a constructor is called:</p>
                    <ol class="eval">
                        <li>Create a scope, INSTANCE_SCOPE. Set STATIC_SCOPE as the parent scope.</li>
                        <li>Evaluate all declaration-prevalent nodes in scope of INSTANCE_SCOPE.</li>
                        <li>Execute the appropriate constructor.</li>
                        <li>Evaluate the function-call that lead to this constructor being evaluated to a value with INSTANCE_SCOPE as the object and the default interface implementation of the class as the active interface implementation.</li>
                        <li>Note: When the interface implementation is used, the value will pass the object into the interface implementation.</li>
                    </ol>
                    <div id="node.declaration-class">
                        <h4>10.5.8.1. declaration-class</h4>
                        <ul class="layout">
                            <li>
                                <a href="#node.declaration-any">declaration-any</a>
                            </li>
                            <li>? 
                            <a href="#node.access">access</a></li>
                        </ul>
                        <p class="process">If decleration-any declares a const identifier, and access is present, the access node must declared get.</p>
                    </div>
                    <div id="node.declaration-any">
                        <h4>10.5.8.2. declaration-any</h4>
                        <p>declaration-any is a family of node types, like expression or statement. The node types included in this family are:</p>
                        <ul class="family-members">
                            <li>
                                <a href="#node.declaration">declaration</a>
                            </li>
                            <li>
                                <a href="#node.declaration-bind">declaration-bind</a>
                            </li>
                            <li>
                                <a href="#node.declaration-pervasive">declaration-pervasive</a>
                            </li>
                            <li>
                                <a href="#node.declaration-const-empty">declaration-const-empty</a>
                            </li>
                        </ul>
                    </div>
                    <div id="node.declaration-const-empty">
                        <h4>10.5.8.3. declaration-const-empty</h4>
                        <ul class="layout">
                            <li>
                                <a href="#node.identifier">identifier</a>
                            </li>
                            <li>
                                <a href="#node.reference-type">reference-type</a>
                            </li>
                        </ul>
                        <p class="process">If reference-type is function, the interface is the return type. (xxx why?)</p>
                        <p>Identifiers created by this node are always const. [idenifier-type] must be value, function, or meta. The class's static constructor is allowed to bind values to static identifiers created by this node. If anthing tries to bind a value to an identifier-reference create by this node, and the identifier-reference is already bound to something, throw an error. The class's instance constructors are allowed to bind values to instance identifiers created by this node. An error results if identifier-references produced by declaration-const-empty nodes are dereferenced before being bound to anything.</p>
                    </div>
                    <div id="node.interface-implementation">
                        <h4>10.5.8.4. interface-implementation</h4>
                        <ul class="layout">
                            <li>* 
                            <a href="#node.interface-implementation">interface-implementation</a>children</li>
                            <li>
                            <a href="#node.expression">expression</a>interface</li>
                            <li>* 
                            <a href="#node.function">function</a>callee</li>
                            <li>* 
                            <a href="#node.named-function">named-function</a>getter</li>
                            <li>* 
                            <a href="#node.named-function">named-function</a>setter</li>
                            <li>* 
                            <a href="#node.named-function">named-function</a>method</li>
                            <li>? 
                            <a href="#node.bool">bool</a>default</li>
                        </ul>
                    </div>
                    <div id="node.named-function">
                        <h4>10.5.8.5. named-function</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>
                            <a href="#node.function">function</a>function</li>
                        </ul>
                    </div>
                    <div id="node.class-property">
                        <h4>10.5.8.6. class-property</h4>
                        <ul class="layout">
                            <li>
                                <a href="#node.identifier">identifier</a>
                            </li>
                            <li>
                                <a href="#node.reference-type">reference-type</a>
                            </li>
                            <li>? 
                            <a href="#node.function">function</a>getter</li>
                            <li>? 
                            <a href="#node.function">function</a>setter</li>
                        </ul>
                        <p class="process">Must have a getter and/or setter. If only identifier and reference-type are given, an error results.</p>
                    </div>
                </div>
                <div id="node.conditional">
                    <h3>10.5.9. conditional</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[test]</li>
                        <li>
                        <a href="#node.expression">expression</a>[true]</li>
                        <li>
                        <a href="#node.expression">expression</a>[false]</li>
                    </ul>
                    <p>If [test] evaluates to true, this node evaluates to [true]. If [test] evaluates to false, this node evalutes to [false].</p>
                </div>
                <div id="node.declaration-bind">
                    <h3>10.5.10. declaration-bind</h3>
                    <ul class="layout">
                        <li>
                            <a href="#node.identifier">identifier</a>
                        </li>
                        <li>
                            <a href="#node.reference-type">reference-type</a>
                        </li>
                        <li>? 
                        <a href="#node.bool">bool</a>const</li>
                        <li>
                        <a href="#node.expression">expression</a>value</li>
                    </ul>
                    <p>reference-type cannot be namespace or alias. If the reference-type comes in const and var versions, [const] determines whether the identifier-reference created is const. If reference-type is value or function, and interface is not given, the interface is determined from [value]. If reference-type is dyn, [const] must not be present. (an error results if it is)</p>
                    <p>If [const] is true, the identifier thereafter always refers to the same value. The identifier cannot be bound to a different value. The active interface also cannot be changed.</p>
                </div>
                <div id="node.declaration-pervasive">
                    <h3>10.5.11. declaration-pervasive</h3>
                    <ul class="layout">
                        <li>
                            <a href="#node.identifier">identifier</a>
                        </li>
                        <li>
                            <a href="#node.reference-type">reference-type</a>
                        </li>
                        <li>
                        <a href="#node.expression">expression</a>value</li>
                    </ul>
                    <p>reference-type cannot be dyn. If the reference-type comes in const and var versions, the identifier-reference created is const. If reference-type is value or function, and interface is not given, the interface is determined from [value].</p>
                </div>
                <div id="node.function">
                    <h3>10.5.12. function</h3>
                    <ul class="layout">
                        <li>* 
                        <a href="#node.identifier">identifier</a>[template-parameter]</li>
                        <li>* 
                        <a href="#node.parameter">parameter</a></li>
                        <li>? 
                        <a href="#node.expression">expression</a>[return-type]</li>
                        <li>
                            <a href="#node.block">block</a>
                        </li>
                    </ul>
                    <pre>
&lt;function&gt;
        &lt;identifier label='template-parameter'&gt;I&lt;/identifier&gt;
        &lt;parameter&gt;
                &lt;identifier label='name'&gt;string&lt;/identifier&gt;
                &lt;identifier label='interface'&gt;String&lt;/identifier&gt;
                &lt;string label='default-value'&gt;[default]&lt;/string&gt;
        &lt;/parameter&gt;
        &lt;identifier label='return-interface'&gt;Int&lt;/identifier&gt;
        &lt;block&gt;...&lt;/block&gt;
&lt;/function&gt;
</pre>
                    <p>When this node is evaluated, it evaluates to a function object. Only the [template-parameter], [parameter], and [return-type] nodes are evaluated at this time. When the function object is called, the [block] member is evaluated, in the scope of this function node, not the scope of the function-call node.</p>
                </div>
                <div id="node.function-call">
                    <h3>10.5.13. function-call</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>function</li>
                        <li>* 
                        <a href="#node.expression">expression</a>arguments</li>
                    </ul>
                    <p class="process">If the function does not have a return type, and this function-call node is acting as an expression, an error results.</p>
                    <ol class="exec">
                        <li>Evaluate the function expression.</li>
                        <li>If the resultant value is not callable, throw an error.</li>
                        <li>Evaluate the argument expressions in order.</li>
                        <li>Send argument values to function for execution.</li>
                    </ol>
                    <ol class="eval">
                        <li>Evaluate the function expression.</li>
                        <li>If the resultant value is not callable or does not have a return type, throw an error.</li>
                        <li>Evaluate the argument expressions in order.</li>
                        <li>Send argument values to the function for evaluation.</li>
                        <li>Evaluate this node to the value returned by the function.</li>
                    </ol>
                    <p>Note: The only time an error should be thrown in step 2 of execution/evaluation is when the expression is a dyn and processing could not determine that an error would result.</p>
                </div>
                <div id="node.function-interface">
                    <h3>10.5.14. function-interface</h3>
                    <ul class="layout">
                        <li>? 
                        <a href="#node.expression">expression</a>[template-argument-count]</li>
                        <li>* 
                        <a href="#node.expression">expression</a>[parameter-interface]</li>
                        <li>? 
                        <a href="#node.expression">expression</a>[return-interface]</li>
                    </ul>
                </div>
                <div id="node.function-template-instantion">
                    <h3>10.5.15. function-template-instantion</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[function-template]</li>
                        <li>+ 
                        <a href="#node.expression">expression</a>[template-argument]</li>
                    </ul>
                    <p>For a function with template arguments, pass template arguments in to get back a function. All required template arguments must be passed at once; Desal does not support currying of template arguments.</p>
                </div>
                <div id="node.identifier">
                    <h3>10.5.16. identifier</h3>
                    <p>Base node. Identifiers can sometimes evaluate to object references. Object references point to an object and have an active interface. Only properties declared by the active interface can be accessed, even if the object implements other interfaces.</p>
                    <p>When evaluating an identifier to an object: If the identifier is undefined in the current scope, move to the containing scope. If there is no containing scope, throw an UndefinedIdentifier error. Continue moving to outer scopes until the identifier is found or there is no containing scope. If the identifier is bound to an object, the identifier evaluates to that object. If the identifier has been declared that it can be bound to objects, but it is currently not bound to anything, return null. If the identifier is bound to a function, the identifier evaluates to the wrapper for that function, as defined in function-wrapper xxx. If the identifier is bound to a namespace, a NamespaceIdentifier error results.</p>
                </div>
                <div id="node.curry-function">
                    <h3>10.5.17. curry-function</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>function</li>
                        <li>+ 
                        <a href="#node.expression">expression</a>arguments</li>
                        <li>+ 
                        <a href="#node.labeled-argument">labeled-argument</a></li>
                    </ul>
                    <p>Evaluates to a function. The specified parameters now have values, so they do not appear on the resultant function.</p>
                    <code xml:space="preserve">
func doStuff(int a, string b, bool alpha) {...}
func doStuff2 = (curry doStuff (3, alpha=false))
doStuff2("test")
</code>
                </div>
                <div id="node.bind-method">
                    <h3>10.5.18. bind-method</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>value</li>
                        <li>
                        <a href="#node.identifier">identifier</a>method name</li>
                    </ul>
                    <p>Evaluates to a function. Calling this function is like calling the method on the value.</p>
                    <p>Example: If alpha is a value with a method bar, binding alpha and bar and calling the resultant function is like calling the bar method of alpha.</p>
                    <code xml:space="preserve">
interface Foo
        func doStuff()

Foo foo = getFoo()
func() doStuff = (bind foo doStuff)
doStuff() //same as calling foo.doStuff()
</code>
                </div>
                <div id="node.namespaced-identifier">
                    <h3>10.5.19. namespaced-identifier</h3>
                    <ul class="layout">
                        <li>+ 
                        <a href="#node.identifier">identifier</a>namespaces</li>
                        <li>
                        <a href="#node.identifier">identifier</a>identifier reference</li>
                    </ul>
                    <code xml:space="preserve">
namespace::namespace::identifier-reference

namespace foo {
        namespace bar {
                Int alpha = ...
        }
}
Int alpha = foo::bar::alpha
</code>
                </div>
                <div id="node.chain">
                    <h3>10.5.20. chain</h3>
                    <ul class="layout">
                        <li>? 
                        <a href="#node.bool">bool</a>namespaced-identifier</li>
                        <li>? 
                        <a href="#node.bool">bool</a>get-property</li>
                        <li>? 
                        <a href="#node.bool">bool</a>bind-method</li>
                        <li>? 
                        <a href="#node.expression">expression</a>starting value</li>
                        <li>+ 
                        <a href="#node.identifier">identifier</a></li>
                    </ul>
                    <p>This node exists for Desal representations that use the same syntax for different associations between identifiers. The associations supported by this node are the same as those of the 
                    <a href="#node.namespaced-identifier">namespace-reference</a>, 
                    <a href="#node.get-property">get-property</a>, and 
                    <a href="#node.bind-method">bind-method</a>nodes. The optional bool nodes are all true by default, meaning all associations are supported. If namespaced-identifier is true, the starting value must not be present.</p>
                    <p>namespaced-identifier associations can be used to evaluate namespaced identifers.</p>
                    <pre>
namespace.identifier-reference
namespace.namespace.identifier-reference
</pre>
                    <p>get-property associations can be used to get properties of values.</p>
                    <pre>
starting-value.property.property.property

if namespaced-identifier is also true:
namespace.identifier-reference.property
</pre>
                    <p>bind-method associations can be used to bind a method of a value to a value.</p>
                    <pre>
alpha.doStuff.apply
</pre>
                    <pre>
Different syntax for namespaced identifier references, getting properties, and method binding.

alpha::beta.gamma=&gt;delta

(bind-method
        (get-property
                (namespaced-identifier
                        (namespace alpha)
                        (identifier beta))
                (identifier gamma))
        (identifier delta))

Here, alpha must be a namespace, beta must be an identifier-reference, gamma must be a property, and delta must be a method.
</pre>
                    <pre>
Shared syntax for namespaced identifier references and getting properties, but different syntax for method binding.

alpha.beta.gamma:delta

(bind-method
        (chain
                (bind-method false)
                (identifier alpha)
                (identifier beta)
                (identifier gamma))
        (identifier delta))

Here, alpha could be a free identifier reference or a namespace. If alpha is a namespace, beta could be a namespace. gamma could be an identifier reference in the alpha.beta namespace, or a property of the value that beta evaluated to. delta must be a method.
</pre>
                    <pre>
Shared syntax for getting properties and method binding, but different syntax for refering to namespaced identifier references.

alpha::beta.gamma.delta

(chain
        (namespaced-identifier false)
        (starting-value
                (namespaced-identifier
                        (namespace alpha)
                        (identifier beta)))
        (identifer gamma)
        (identifer delta))

Here, alpha must be a namespace and beta must be an identifer reference within that namespace. gamma could be a property or method of beta. delta could be a property or method of gamma.
</pre>
                    <pre>
Same syntax for all.

alpha.beta.gamma.delta

(chain
        (identifier alpha)
        (identifier beta)
        (identifier gamma)
        (identifier delta))

Delta cannot be a namespace.
</pre>
                    <pre>
A representation could provide different syntax for each association, but also provide a way to specify that one of multiple assocations are allowed.

alpha :: beta {. or =&gt;} gamma . delta =&gt; epsilon

&lt;bind-method&gt;
        &lt;get-property label="value"&gt;
                &lt;chain label="value"&gt;
                        &lt;bool label="namespaced-identifer"&gt;false&lt;/bool&gt;
                        &lt;namespaced-identifer label="starting-value"&gt;
                                &lt;identifer label="namespace"&gt;alpha&lt;/identifer&gt;
                                &lt;identifer label="member"&gt;beta&lt;/identifer&gt;
                        &lt;/namespaced-identifer&gt;
                        &lt;identifer&gt;gamma&lt;/identifer&gt;
                &lt;/chain&gt;
                &lt;identifer label="property-name"&gt;delta&lt;/identifer&gt;
        &lt;/get-property&gt;
        &lt;identifier label="method-name"&gt;epsilon&lt;/identifer&gt;
&lt;/bind-method&gt;

Here, alpha must be a namespace, and beta must be an identifer-reference within that namespace. Gamma can be a property or method of beta. delta must be a property of gamma. epsilon must be a method of delta.
</pre>
                </div>
                <div id="node.implements">
                    <h3>10.5.21. implements?</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[object]</li>
                        <li>
                        <a href="#node.expression">expression</a>[interface]</li>
                    </ul>
                    <p>Returns a bool object reference to the true or false objects. True if [object] implements [interface], false otherwise.</p>
                    <code xml:space="preserve">
if (o imps Foo)
        (o as Foo).propOfFoo()
</code>
                </div>
                <div id="node.integer">
                    <h3>10.5.22. integer</h3>
                    <p>Base node. Evaluates to an object reference with BigInt as the active interface. The object may implement other interfaces if they do not conflict with the BigInt interface. Must not implement the LimInt interface.</p>
                </div>
                <div id="node.interface">
                    <h3>10.5.23. interface</h3>
                    <ul class="layout">
                        <li>* 
                        <a href="#node.expression">expression</a>inheritees</li>
                        <li>* 
                        <a href="#node.callee">callee</a>callees</li>
                        <li>? 
                        <a href="#node.reference-type">reference-type</a>return type</li>
                        <li>* 
                        <a href="#node.property">property</a>properties</li>
                        <li>* 
                        <a href="#node.method">method</a>methods</li>
                    </ul>
                    <div id="node.callee">
                        <h4>10.5.23.1. callee</h4>
                        <ul class="layout">
                            <li>* 
                            <a href="#node.parameter">parameter</a>parameters</li>
                        </ul>
                    </div>
                    <div id="node.property">
                        <h4>10.5.23.2. property</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>
                            <a href="#node.reference-type">reference-type</a>type</li>
                            <li>
                            <a href="#node.access">access</a>access</li>
                        </ul>
                    </div>
                    <div id="node.method">
                        <h4>10.5.23.3. method</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>
                            <a href="#node.expression">expression</a>interface</li>
                        </ul>
                    </div>
                    <div id="node.access">
                        <h4>10.5.23.4. access</h4>
                        <p>Access nodes must specify one of three access levels: only reading, only writing, or both reading and writing.</p>
                    </div>
                </div>
                <div id="node.interface-template-instantion">
                    <h3>10.5.24. interface-template-instantion</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[interface-template]</li>
                        <li>+ 
                        <a href="#node.expression">expression</a>[template-argument]</li>
                    </ul>
                    <p>For an interface with template arguments, pass template arguments in to get back an interface. All required template arguments must be passed at once; Desal does not support currying of template arguments.</p>
                </div>
                <div id="node.same-object">
                    <h3>10.5.25. same-object</h3>
                    <ul class="layout">
                        <li>
                            <a href="#node.expression">expression</a>
                        </li>
                        <li>
                            <a href="#node.expression">expression</a>
                        </li>
                    </ul>
                    <p>Tells whether the values are associated with the same object.</p>
                    <code xml:space="preserve">
Alpha a = getAlpha()
Beta b = getBeta()
if( a === b )
        print "same objects"
</code>
                </div>
                <div id="node.list">
                    <h3>10.5.26. list</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>[interface]</li>
                        <li>* 
                        <a href="#node.expression">expression</a>[element]</li>
                    </ul>
                    <p>Evaluates to a list, as if calling CList{ [interface] } ( [element], [element], ... )</p>
                    <p>Each [element] is cast to [interface]. If a cast error results, it raises out of the list node, so that the list node doesn't evaluate to anything.</p>
                </div>
                <div id="node.object-number">
                    <h3>10.5.27. object-number</h3>
                    <p class="layout">Expression value</p>
                    <p>Every object is associated with a constant non-negative integer. No two objects that are still accessible can have the same object number. This node evaluates to a value, with Int as the active interface, that encodes the object number for the object associated with the given value.</p>
                </div>
                <div id="node.rational">
                    <h3>10.5.28. rational</h3>
                    <p>Base node. Evaluates to an object with BigRat as the active interface. The object may implement other interfaces if they do not conflict with the BigRat interface. Must not implement the LimRat interface.</p>
                </div>
                <div id="node.get-property">
                    <h3>10.5.29. get property</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.expression">expression</a>value</li>
                        <li>
                        <a href="#node.identifier">identifier</a>property name</li>
                    </ul>
                    <p>Retrieves a property of a value. If the active interface of the value does not have a property with the specified name, an error results.</p>
                </div>
                <div id="node.string">
                    <h3>10.5.30. string</h3>
                    <p>string nodes consist of text</p>
                    <p>strings are expressions</p>
                    <p>Base node. Evaluates to an object with interface string as the active interface. The object may implement other interfaces if they do not conflict with the string interface.</p>
                </div>
                <div id="node.unbind">
                    <h3>10.5.31. unbind</h3>
                    <ul class="layout">
                        <li>
                            <a href="#node.expression">expression</a>
                        </li>
                    </ul>
                    <p>Unbinds the values bound to the given reference. If the reference is a function reference, all bound functions are unbound. XXX why not just bind null?</p>
                </div>
                <div id="node.unbind-function">
                    <h3>10.5.32. unbind-function</h3>
                    <ul class="layout">
                        <li>
                            <a href="#node.expression">expression</a>
                        </li>
                        <li>
                            <a href="#node.interface">interface</a>
                        </li>
                    </ul>
                    <p>Unbinds the function with the specified interface from the given value. XXX throw error if such a function isn't bound?</p>
                </div>
            </div>
            <div id="unsorted-tree-node-types">
                <h2>10.6. Unsorted tree node types</h2>
                <div id="node.global">
                    <h3>10.6.1. global</h3>
                    <p class="layout">+ identifier-const</p>
                    <p>has scope</p>
                    <p>xxx Some nodes, like global nodes, have scope. Spec this out and specify with nodes have scope.</p>
                    <p>The global type is the type of the root node. No node can contain a global node. All Desal nodes that are executed in any way must be part of a complete Desal tree, which means having a global node as the root node.</p>
                    <p>xxx Program arguments are no longer passed to the main function, because developers should have a choice of accessing program arguments in different ways, and some implementations may not have program arguments, or have non-string program arguments, etc. The old way just isn't flexible enough. Implementations should give program arguments through some API instead of passing them to the main function.</p>
                    <p>Unlike other nodes, the global node has a setup procedure. This setup must occur before any evaluation or execution of any nodes takes place, and must only occur once.</p>
                    <ol class="exec">
                        <li>1. Bind the global objects defined in XXX to the specified identifiers for this node's scope.</li>
                        <li>2. Bind any implementation-specific identifiers.</li>
                        <li>3. Execute each child identifier-const node in order.</li>
                    </ol>
                    <p>When the complete Desal tree is treated as a standalone program, section XXX applies. Otherwise, besides layout and setup, the abilities and behaviour of the global node is implementation-specific, and execution or evaluation of Desal nodes may occur directly, without going through the global node.</p>
                </div>
                <div id="node.alias">
                    <h3>10.6.2. alias</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.chain">chain</a>target</li>
                        <li>? 
                        <a href="#node.identifier">identifier</a>name</li>
                    </ul>
                    <p>Note: Due to the whole "everything's an object" business, this node should probably be removed. XXX But what about namespaces?!</p>
                    <code xml:space="preserve">
alias FooBarBaz as FBZ
alias Alpha.Beta.Gamma //the "as Gamma" part is implied
alias System.out.print as puts
puts( FBZ.toString(Gamma) )
</code>
                    <code xml:space="preserve">
auto FBZ = FooBarBaz
auto Gamma = Alpha.Beta.Gamma
auto puts = System.out.print
puts( FBZ.toString(Gamma) )
</code>
                    <code xml:space="preserve">
//if Gamma is a namespace
namespace Gamma = Alpha.Beta.Gamma
</code>
                </div>
            </div>
        </div>
        <div id="prevalent-identifiers">
            <h1>Chapter 11. Prevalent identifiers</h1>
            <p>Prevalent identifiers are constant identifiers in the global scope that exist before source begins execution. The objects the identifiers are bound to are immutable. Additionaly, these identifiers cannot be declared in any other scope. Therefore, referencing one of these identifiers always refers to the same object no matter the scope. The objects can, however, be bound to additional identifiers with normal scoping rules.</p>
            <ul>
                <li>interface Interface</li>
                <li>interface Object</li>
                <li>interface{I} Generator</li>
                <li>interface{I} List</li>
                <li>interface String</li>
                <li>interface Int</li>
                <li>interface Rat</li>
                <li>interface BigInt</li>
                <li>interface BigRat</li>
                <li>func{I}(obj)I cast</li>
                <li>func(obj,interface)bool implements?</li>
                <li>interface Bool</li>
                <li>bool true</li>
                <li>bool false</li>
                <li>namespace global</li>
                <li>namespace ext</li>
                <li>interface{I} weakRef</li>
                <li>interface complex</li>
                <li>interface{I} array2</li>
                <li>interface{I} array3</li>
                <li>interface{I} arrayN</li>
                <li>interface{I} vector</li>
                <li>interface{I} vector2</li>
                <li>interface{I} vector3</li>
                <li>interface{I} vectorN</li>
                <li>interface{I} slist</li>
                <li>interface{I} dlist</li>
                <li>interface{I} deque</li>
                <li>interface{I} queue</li>
                <li>interface{I} stack</li>
                <li>interface{I1,I2} map</li>
                <li>interface{I1,I2} sortedmap</li>
                <li>interface{I1,I2} multimap</li>
                <li>interface{I1,I2} sortedmultimap</li>
                <li>interface{I1,I2} bimap</li>
                <li>interface{I1,I2} sortedbimap</li>
                <li>interface{I1,I2} multibimap</li>
                <li>interface{I1,I2} sortedmultibimap</li>
                <li>interface{I} set</li>
                <li>interface{I} orderedset</li>
                <li>interface{I} multiset</li>
                <li>interface{I} orderedmultiset</li>
                <li>interface octet</li>
                <li>interface blob</li>
                <li>interface sint8</li>
                <li>interface uint8</li>
                <li>interface sint16</li>
                <li>interface uint16</li>
                <li>interface sint32</li>
                <li>interface uint32</li>
                <li>interface sint64</li>
                <li>interface uint64</li>
                <li>interface sint128</li>
                <li>interface uint128</li>
                <li>interface float8</li>
                <li>interface float16</li>
                <li>interface float32</li>
                <li>interface float64</li>
                <li>interface float128</li>
                <li>interface limitedint</li>
                <li>interface limitedrat</li>
            </ul>
            <div id="object.cast">
                <h2>11.1. func{I}(obj)I cast</h2>
                <p>The cast function returns an object cast to the specified interface, or throws a cast error. The returned object must be the same object that was passed in.</p>
                <code xml:space="preserve">
if (foo is Bar)
        (cast {Bar} foo).propOfBar()
</code>
            </div>
            <div id="object.generator">
                <h2>11.2. interface generator</h2>
                <pre>
interface{I} generator
        func next() I
</pre>
                <p>The next() method will return objects when called until it throws a GeneratorDone exception.</p>
                <p>Some looping constructs will automatically obtain a generator by calling the object's getValueIterator, getKeyIterator, or getPairIterator method, and call the next() method of the generator until the exception is thrown</p>
                <code xml:space="preserve">
MyClass[] objs
for each o in objs
        o.doStuff()
</code>
            </div>
            <div id="object.implements_q">
                <h2>11.3. func(obj, interface)bool implements?</h2>
                <p>Tells whether the object implements the interface, like the implements node.</p>
                <code xml:space="preserve">
if implements(foo, Bar)
        (foo as Bar).propOfBar()
</code>
            </div>
            <div id="ident.Int">
                <h2>11.4. interface Int</h2>
                <ul>
                    <li>func lessThan?(Int) Bool</li>
                    <li>func lessThanOrEqual?(Int) Bool</li>
                    <li>func equal?(Int) Bool</li>
                    <li>func greaterThanOrEqual?(Int) Bool</li>
                    <li>func greaterThan?(Int) Bool</li>
                    <li>func unequal?(Int) Bool</li>
                    <li>Bool positive?</li>
                    <li>Bool negative?</li>
                    <li>func add(Int) Int</li>
                    <li>func subtract(Int) Int</li>
                    <li>func multiply(Int) Int</li>
                    <li>func multiply(Rat) Rat</li>
                    <li>func divide(Int) Rat</li>
                    <li>func divide(Rat) Rat</li>
                    <li>func floorDivide(Rat) Int</li>
                    <li>func remainder(Int) Int</li>
                    <li>Int absolute</li>
                    <li>func add!(Int)</li>
                    <li>func subtract!(Int)</li>
                    <li>func multiply!(Int)</li>
                    <li>func increment!()</li>
                    <li>func decrement!()</li>
                    <li>func toBuiltin() Int</li>
                    <li>func toString() String</li>
                    <li>func toString(IntNotationMethod) String</li>
                </ul>
                <p>When Desal implementations need to determine the value of int objects that were implemented by user code, they should call the toBuiltin method to get an int object that was implemented by the implementation. If toBuiltin throws an error, it should raise into user code. If the returned int is not a built-in, an error results that should extend into user code.</p>
                <p>IntNotationMethod is an enum with "normal", "scientific10", "scientificE", "multipleScientific10", and "multipleScientificE". The toString meth may throw an error if the number cannot be represented, such as a googolplex being called with "normal". If called with multipleScientificE, "10E(10E100)" could be returned.</p>
            </div>
            <div id="object.BigInt">
                <h2>11.5. interface BigInt</h2>
                <p>Inherits from Int.</p>
            </div>
            <div id="object.BigRat">
                <h2>11.6. interface BigRat</h2>
                <p>Inherits from Rat.</p>
            </div>
            <div id="ident.Interface">
                <h2>11.7. interface Interface</h2>
                <ul>
                    <li>get Bool fromAddition?</li>
                    <li>get Set{Interface} inheritees</li>
                    <li>get List{Parameters} parameters</li>
                    <li>get Type returnType</li>
                    <li>get List{Property} properties</li>
                    <li>get List{Method} methods</li>
                    <li>func add(Interface) Interface</li>
                    <li>func subtract(Interface) Interface</li>
                </ul>
                <p>Implements itself.</p>
            </div>
            <div id="object.Object">
                <h2>11.8. interface Object</h2>
                <ul>
                    <li>Bool builtin?</li>
                    <li>Bool mutable?</li>
                    <li>Int number</li>
                    <li>func{I} cast() I</li>
                    <li>func implements? (Interface) Bool</li>
                    <li>func sameObject? (Object) Bool</li>
                </ul>
                <p>These methods expose the same functionality of some of the nodes.</p>
                <p>The builtin? property tells whether the object is implemented by the Desal implementation, such as for integers and strings. The implements? method tells whether the object implements a specified interface.</p>
            </div>
            <div id="interface.rat">
                <h2>11.9. interface rat</h2>
                <ul>
                    <li>func toInt() int</li>
                    <li>func round() int</li>
                    <li>func round!()</li>
                </ul>
                <p>toInt will throw if the represented value is not already an integer. round should not throw. round! modifies the represented value.</p>
            </div>
        </div>
        <div id="preexisting-global-identifiers">
            <h1>Chapter 12. Other preexisting global identifiers</h1>
            <p>Constant identifiers in the global scope that exist before source begins execution. The objects the identifiers are bound to are immutable. Unlike prevalent identifers, these identifers follow normal scoping rules. They can always be refered to trough the prevalent global namespace identifier.</p>
            <ul>
                <li>interface InterfaceBuilder</li>
                <li>func()InterfaceBuilder CInterfaceBuilder</li>
                <li>func(int, interface[], interface)interface getFuncInterface</li>
                <li>interface{I} Iterator</li>
                <li>func{I}(:vararg)array{I} CArray</li>
                <li>func(bool[] bits, bool positive = true)int CInt</li>
                <li>func{I}(:vararg)list{I} CList</li>
                <li>func{I}(I)SelfGen print</li>
                <li>func{I}(I)SelfGen println</li>
            </ul>
            <div id="InterfaceBuilder">
                <h2>12.1. InterfaceBuilder</h2>
                <ul>
                    <li>map{string, interface} properties</li>
                    <li>bool alwaysImmutable?</li>
                    <li>func()interface generate</li>
                </ul>
                <p>interface interface is always immutable, so InterfaceBuilder exists to allow creating interface objects procedurally.</p>
            </div>
            <div id="Iterator">
                <h2>12.2. Iterator</h2>
                <pre>
interface{I} Iterator
        //values may change
        bool first?
        bool last?
        bool hasNext?
        bool hasPrevious?
        bool between? //iterator points between 2 items (such as after the item was removed)
        bool valid?

        //capabilities of the iterator - values should not change
        bool canMoveForward? //whether the iterator can move forward
        bool canMoveBackward? //whether the iterator can move backwards
        bool canRemove?
        bool canReplace? //whether the objects can be replaced with different objects
        bool canRead?
        bool canInsertAfter?
        bool canInsertBefore?
        bool canCompareCollection?
        bool canCompareIterator? //corresponds to equal?
        bool canComparePosition? //corresponds to before? and after?

        func moveForward()
        func moveBackward()
        func remove()
        func replace(I)
        func insertAfter(I)
        func insertBefore(I)
        func sameCollection?( Iterator{I} ) bool
        func before?( Iterator{I} ) bool
        func after?( Iterator{I} ) bool
        func equal?( Iterator{I} ) bool
        
        I value
</pre>
                <p>An iterator is used to access the elements in a container. If the elements are not ordered 2-dimensionally, an 2-dimensional order must be decided for the iterator that does not change for that iterator instance. If the elements in the container are ordered 2-dimensionally, the iterator must refer the elements in that order.</p>
                <p>The equals? method returns true if both iterators are pointing to same item of the same collection. If the collection is unordered, the order the iterator moves over items must also be the same.</p>
                <p>A valid iterator either refers to an element or a position between two elements. An iterator should only refer to a position between two elements when the element the iterator currently pointed to was removed. If the iterator is not valid, or read? is false, the value property refers to null.</p>
                <p>An iterator only becomes invalid if:</p>
                <ul>
                    <li>the container contains no objects</li>
                    <li>the iterator is moved beyond all objects</li>
                    <li>a non-supported method is called (example: moveBackward() is called on an iterator that can only move forward)</li>
                </ul>
                <p>If an iterator is not valid, it may be possible to revalidate it by calling next() or previous(). For example, if the iterator refers to the last object and next is called, the iterator becomes invalid, but calling previous may make the iterator valid again. Whether an iterator can be revalidated and under what circumstances the iterator is revalidated is dependant on the implementation of the iterator.</p>
                <p>Containers should always give iterators with the same functionality. For example, if a container, when it has three elements, gives an iterator with forward? set to true, it should also give an iterator with the property forward? set to true when it has 1, even though calling moveForward() would invalidate the iterator.</p>
                <code xml:space="preserve">
Container{int} numbers;
Iterator iter = numbers.iterate();
int num = iter.value

while( iter.valid? )
        int num = iter.value
        iter.moveForward()
</code>
            </div>
            <div id="CInterfaceBuilder">
                <h2>12.3. CInterfaceBuilder</h2>
                <p>CInterfaceBuilder, when called, returns an object that can be used to procedurally and/or dynamically create interface objects.</p>
            </div>
            <div id="getFuncInterface">
                <h2>12.4. getFuncInterface</h2>
                <pre>
func getFuncInterface (
        int templateParamCount,
        interface[] params,
        interface returnInterface,
) interface
</pre>
                <p>Returns an interface specifying a call method with the specified number of template parameters, the specified parameters, and the specified return interface. If returnInterface is null, the interface specifies a void call method. Every time it is called with the same arguments, it must return the same object.</p>
            </div>
        </div>
        <div id="evaluation">
            <h1>Chapter 13. Evaluation</h1>
            <p>Some nodes, when executed, evaluate to an object reference. These are called expressions.</p>
            <p>Evaluation of a Desal node tree may begin before the tree is fully constructed.</p>
            <div id="error-handling">
                <h2>13.1. Error handling</h2>
                <p>This section explains how to handle errors.</p>
                <p>If errors occur while generating the Desal node tree, and none of the already generated nodes have been evaluated, all generated nodes in the entire Desal tree should not be used for purposes beyond explaining the source of errors. Construction of the Desal node tree may continue after errors are found. This applies even if the Desal nodes were not intended to be evaluated.</p>
                <p>If errors occur while generating the Desal node tree, and evaluation has already begun, a warning should immediately be emitted describing the error. How this warning is emitted is undefined. Generation of the Desal node tree may continue. When evaluation reaches the damaged section of the tree, an error should be thrown describing the error. If evaluation never reaches the damaged section of the tree, the error should have no effect on evaluation.</p>
            </div>
            <p>Evaluation of a Desal node tree begins with name bindings in the global namespace. Then, the object bound to "main" in the global namespace is called with an array of strings representing the arguments given to the tree. How these arguments are obtained is undefined. Evalution of the tree ends when main returns or an exception raises out of main.</p>
        </div>
        <div id="unsorted-stuff">
            <h1>Chapter 14. unsorted stuff</h1>
            <div id="closures">
                <h2>14.1. Closures</h2>
                <p>Functions and classes (amoung others) have references to their containing scope. Identifier references in these scopes can be accessed and modified by the functions/classes.</p>
                <p>Copy closures create copies of specific values when a function node is evaluated. Modifying this copy does not modify the captured scope.</p>
                <code xml:space="preserve">
//regular closures

func makePrinters(Int max) func()void[] {
        func()void[] printers = new func()void[]
        Int i = 1
        while i &lt;= max {
                printers &lt;&lt; func()void {
                        print i + ' '
                }
                i++
        }
        return printers
}

//array of functions that have no parameters and return nothing
func()void[] printers = makePrinters(10)
for printer in printers {
        printer()
}

//output
10 10 10 10 10 10 10 10 10 10 

Each of the anonymous functions held a reference to the same scope where i was defined. Because i held 10 when the functions were called, each output 10.
</code>
                <code xml:space="preserve">
//copy closures

func makePrinters(Int max) func()void[] {
        func()void[] printers = new func()void[]
        Int i = 1
        while i &lt;= max {
                printers &lt;&lt; func()void {
                        copyclosure i
                        print i + ' '
                }
                i++
        }
        return printers
}

//array of functions that have no parameters and return nothing
func()void[] printers = makePrinters(10)
for printer in printers {
        printer()
}

//output
1 2 3 4 5 6 7 8 9 10

Each of the anynonymous functions held a copy of the value of i at the time the function was created.
</code>
            </div>
            <div id="tree-examples">
                <h2>14.2. Tree examples</h2>
                <div id="tree-example-1">
                    <h3>14.2.1. Example 1</h3>
                    <code xml:space="preserve">
global
        identifier-const-definition
                identifier
                        "main"
                expression [value] (function-definition)
                        function-parameter
                                identifier
                                        "args"
                                expression [interface] (interface-template-instantiation)
                                        expression [interface-template] (identifier)
                                                "array"       
                                        expression [template-argument] (identifier)
                                                "string"
                        expression [return-interface] (identifier)
                                "int"
                        statement (return)
                                expression (integer)
                                        0

func main(string[] args) int
        return 0
</code>
                </div>
                <div id="tree-example-2">
                    <h3>14.2.2. Example 2</h3>
                    <code xml:space="preserve">
global (global)
        declaration (declaration &gt; function-declaration)
                name (string)
                        "main"
                return (expression &gt; object-reference)
                        name (string)
                                "int"
                item (item &gt; return)
                        value (expression &gt; integer)
                                0

func main() int
        return 0

&lt;global type="global"&gt;
        &lt;declaration type="function-declaration"&gt;
                &lt;name type="string"&gt;main&lt;/name&gt;
                &lt;return type="object-reference"&gt;
                        &lt;name type="string"&gt;int&lt;/name&gt;
                &lt;/return&gt;
                &lt;item type="return"&gt;
                        &lt;value type="integer"&gt;0&lt;/value&gt;
                &lt;/item&gt;
        &lt;/declaration&gt;
&lt;/global&gt;
</code>
                </div>
                <div id="tree-example-3">
                    <h3>14.2.3. Example 3</h3>
                    <code xml:space="preserve">
global (global)
        name-bind (name-bind)
                identifier (identifier)
                        "main"
                expression (function-definition)
                        parameter (parameter)
                                interface (interface &gt; function-call)
                                        function (function &gt; identifier)
                                                "array"
                                        argument (expression &gt; identifier)
                                                "string"
                                identifier (identifier)
                                        "args"
                return-interface (interface &gt; identifier)
                        "int"
                statement (statement &gt; return)
                        expression (expression &gt; literal-integer)
                                0

func main(string[] args) int
        return 0

&lt;global type="global"&gt;
        &lt;name-bind type="name-bind"&gt;
                &lt;identifier type="identifier"&gt;main&lt;/identifier&gt;
                &lt;expression type="function-definition"&gt;
                        &lt;parameter-list type="parameter-list"&gt;
                                &lt;parameter type="parameter"&gt;
                                        &lt;identifier type="identifier"&gt;args&lt;/identifier&gt;
                                        &lt;expression type="function-call"&gt;
                                                &lt;identifier type="identifier"&gt;array&lt;/identifier&gt;
                                                &lt;argument-list type="argument-list"&gt;
                                                        &lt;identifier type="identifier"&gt;string&lt;/identifier&gt;
                                                &lt;/argument-list&gt;
                                        &lt;/expression&gt;
                                &lt;/parameter&gt;
                        &lt;/parameter-list&gt;
                        &lt;return-interface type="identifier"&gt;int&lt;/return-interface&gt;
                        &lt;statement-list type="statement-list"&gt;
                                &lt;statement type="return"&gt;
                                        &lt;expression type="literal-integer"&gt;0&lt;/expression&gt;
                                &lt;/statement&gt;
                        &lt;/statement-list&gt;
                &lt;/function&gt;
        &lt;/name-bind&gt;
&lt;/global&gt;
</code>
                </div>
            </div>
            <div id="get-interface">
                <h2>14.3. get interface</h2>
                <p>It's always possible to bind the interface of an object to an identifier.</p>
                <code xml:space="preserve">
func getInterface{I}(I o) {
return I;
}

dynref o = getMysteryObj()
interface i = getInterface(o)
i o2 = o
</code>
            </div>
            <div id="obj-interface">
                <h2>14.4. obj interface</h2>
                <p>All objects automatically implement the "obj" interface.</p>
                <code xml:space="preserve">
obj foo = getAnObject()
(myinterface foo) .doStuff 3
</code>
            </div>
            <div id="identifier-binding">
                <h2>14.5. Binding to identifiers</h2>
                <code xml:space="preserve">
int alpha
</code>
                <p>Declares that "alpha" can refer to objects that implement the "int" interface. alpha currently doesn't refer to anything; i.e. it refers to null.</p>
                <code xml:space="preserve">
alpha = 3
</code>
                <p>Creates an object that implements the int interface and makes alpha refer to it</p>
                <code xml:space="preserve">
int beta = 5
</code>
                <p>Declares that "beta" can refer to objects that implement the "beta" interface. Creates an object that implements the int interface. Binds the object to "beta".</p>
                <p>Multiple identifiers can refer to the same object.</p>
                <code xml:space="preserve">
obj o = getObj()
int a = o
rat b = o
</code>
            </div>
            <div id="print-println-return-interfaces">
                <h2>14.6. Return interfaces of print and println</h2>
                <p>Below, [unbound] means the interface is not bound to an identifier. However, these interfaces can be bound to identifiers and used like any user-created interface, and they have no special properties.</p>
                <ul>
                    <li>func{I}(I)[unbound] print</li>
                    <li>func{I}(I)[unbound] println</li>
                </ul>
                <pre>
interface{I} Print
        func call(I) Print

interface{I} PrintLine
        func call(I) PrintLine
</pre>
                <p>When print is called, it returns an object that implements an interface like Print. When println is called, it returns an object that implements an interface like PrintLine. Neither interface is bound to an identifier when execution begins. They are not the same interface, meaning print(1).interface == println(1).interface evaluates to false.</p>
                <pre>
println 1 2 3 "a" "b" "c" 4.5 6.7 8.9
</pre>
            </div>
            <div id="adjuncts">
                <h2>14.7. Adjuncts</h2>
                <code xml:space="preserve">
interface IMyInterface
        public func doStuffA()
        public func doStuffB()

class MyClass
        :implements(IMyInterface)
        ...

func IMyInterface.doAB()
        this.doStuffA()
        this.doStuffB()

func testThing(ref IMyInterface arg)
        arg.doAB()

MyClass inst
testThing(inst)
</code>
            </div>
            <div id="runtime-inteface">
                <h2>14.8. runtime interface implementation</h2>
                <p>With Desal, you should be able to write a function that takes an interface (foo) and returns a function that takes an object of that interface (foo) and returns an object that implements that same interface (foo), but with an implementation that writes to a log anytime a method is called.</p>
                <pre>
log l = Log()
foo o = Foo()
foo wrapped = wrap(o, l)
doStuffWithAFoo(wrapped)
</pre>
                <p>Now anytime a method is called on the object, a log entry could be written.</p>
                <pre>
func{I} wrap(I o, log l) I
objbuilder wrapper = newObjbuilder()
wrapper.implement(I)
for prop in I.props
wrapper.interfaces[I].setProp( prop.name,
func(:vararg)obj

interface i = newInterface()
i.inherit(I)
for prop in 

wrap(...) takes an interface and returns a function
wrap(foo)(...) takes a foo and returns a foo
</pre>
            </div>
            <div id="runtime-interface-creation">
                <h2>14.9. Runtime interface creation</h2>
                <pre>
func createInterface( map{string,dyn} methods ) interface
        interface rv = newInterface()
        for (name, meth) in methods
                rv.methods.add( pair(name, meth.functionSignature) )
        return rv

func foo(int b) string
...

func bar(float c, float d) myClass
...

func baz(widget1 e, widget4 f)
...

map(string, func) table = {
"methA": foo,
"methB": bar,
"methC": baz
}
interface myinterface = createInterface(table)

func alpha(int g) string
...

func beta(float h, float i) myClass
...

func gamma(widget1 j, widget4 k)
...

myinterface myobj = {
methA: alpha,
methB: beta,
methC: gamma
}
string str = obj.methA(3)
myClass val = obj.methB(5.5, 7.7)
obj.gamma( createWidget1(), Widget4Factory.makeOne() )
</pre>
            </div>
            <div id="self-return-type">
                <h2>14.10. "self" return type</h2>
                <pre>
func(int,float)self

is the same as

interface __foo__
        func call(int,float) __foo__

func example(int num) self
        ...
        
example 1 2 3 4 5 6 7 8 9 0 //calls the example function 10 times
</pre>
            </div>
            <div id="bind">
                <h2>14.11. Bind</h2>
                <pre>
interface foo
        ...

func bar(foo o, int num)
        ...

foo fooInst = getAFoo()
bar(fooInst, 3)
(fooInst =&gt; bar) 3
func() funcy = (fooInst =&gt; bar)
funcy(3)
</pre>
                <p>obj =&gt; func</p>
                <p>The "=&gt;" operator binds the obj to the first argument of the function. It evaluates to a function. Semantically this creates a function-definition with a closure of the obj and func.</p>
            </div>
            <div id="classes">
                <h2>14.12. Classes</h2>
                <p>Classes produce functors that, when called, create objects. If a class implements more than 1 interface, it can declare which of the implemented interfaces is the active interface of the returned object by marking an interface as default. If no interface is marked, the active interface is obj.</p>
            </div>
            <div id="noninstantiated-interface-templates">
                <h2>14.13. Noninstantiated interface templates</h2>
                <pre>
interface list{I}
        readonly int count
        func pushFront(I o)
        func popFront() I

struct node{C}
        node{C} next = null
        node{C} value = null

class makeList{T}
        node{T} first
        
        interface list{T} #default //so makeList returns a list instead of an obj that has to be cast
                ...

list{int} nums = makeList{int}()
nums.pushFront(3)
nums.pushFront(5)
print nums.size //2

list{string} names = makeList{string}()
names.pushFront("John")
names.pushFront("Sarah")
names.pushFront("Billy")
print names.size //3

list someList = nums
print someList.size //2
someList.pushFront(5) //error
</pre>
                <p>someList may refer to any kind of list, such as list{foo}, list{bar}, etc, so only methods that have the same paramater and return interfaces for all list{}s can be called.</p>
            </div>
            <div id="dynamic-library-loading">
                <h2>14.14. Dynamic library loading</h2>
                <p>The selectLibrary function enables gaining references to objects without knowing the nodes that created the objects.</p>
                <pre>
interface Library
        readonly String path
        readonly String name
        readonly String version
        readonly Bool loaded?
        func key(String name) Dyn
        func get{I}(String name) I
        func load()
        func unload()

//prototype
func selectLibrary(string identifier, string version, bool load? = true) Library

---

string identifier
string version
if platform == platforms.MacOSX or platform == platforms.Windows
        identifier = "libxml"
        version = "2.1"
elif platform == platforms.Linux
        identifier = "/usr/lib/libxml.so"
        version = "56"
else
        throw Error("unsupported platform")

Library XmlLib = selectLibrary(identifier, version)

Interface XmlElement = XmlLib.get{Interface}("XmlElement")
Dyn XmlReader = XmlLib["XmlReader"]

XmlElement element = XmlRead.read("foo.xml").documentElement
</pre>
            </div>
            <div id="static-typing">
                <h2>14.15. Static typing</h2>
                <p>XXX spec out static typing and demand that implementations check all typing as much as possible before running anything. Note the section on dynamic static typing.</p>
            </div>
        </div>
        <div id="rationales">
            <h1>Chapter 15. Rationales</h1>
            <p>This chapter explains the decisions behind various choices made for Desal.</p>
            <div id="rationale.dynamic-static-typing">
                <h2>15.1. Dynamic static typing</h2>
                <p>Dynamic static typing refers to explicitly using and enforcing type information that isn't available until runtime. The type information isn't known until runtime, but after it's known, it's enforced and can't be changed.</p>
                <p>An example of this is loading an interface from a library and then using obtaining values with that interface through the library. The loaded interface can be used as the type for function parameters, free identifiers, etc. So although the interface wasn't known until runtime, one the information was known, it was enforced, and the values of that interface are only accessed by ensuring they are of that interface.</p>
                <p>Dynamic static typing can do nothing beforehand to ensure property/method access is correct, but it can ensure that various values are of the same type. For example, consider the case where an interface is loaded from a library and bound to an identifer. Then a free identifier is declared to be of that type, and a function is declared to accept a value of that type. An implementation will known that the free identifer and the function's parameter are of the same type, so the value bound to the free identifier can safely be passed to the function. This safety could not be ensured with fully dynamic typing.</p>
                <p>Dynamic static typing is not as safe as fully static typing, but interfaces cannot always be known before runtime, which is a requirement for fully static typing. Therefore, Desal should provide something to give more type safety for the cases when interfaces cannot be known until runtime. Dynamic static typing is safer than fully dynamic typing.</p>
                <code xml:space="preserve">
Interface Foo = lib['Foo']
Interface Bar = lib['Bar']
func()Foo getFoo = lib['getFoo']
func(Bar)Int doStuff = lib['doStuff']

Foo foo = getFoo() //static typing: known beforehand that types match
foo.somthing() //dynamic typing: don't know beforehand whether Foo declares a 'somthing' method
doStuff(foo) //static typing: known beforehand that types don't match

---

Dyn getFoo = lib['getFoo']
Dyn doStuff = lib['doStuff']

Dyn foo = getFoo() //dynamic typing: don't know beforehand whether types match
foo.somthing() //dynamic typing: don't know beforehand whether value of foo has a "somthing" method
doStuff(foo) //dynamic typing: don't know beforehand whether types match
</code>
                <p>Arguments against: Interfaces should almost always be known beforehand. Dynamic static typing may be very rarely used, and could encourage bad programming.</p>
            </div>
            <div id="rationale.terms">
                <h2>15.2. Terms</h2>
                <div id="rationale.get-set">
                    <h3>15.2.1. get/set</h3>
                    <table>
                        <tbody>
                            <tr>
                                <th>term as verb</th>
                                <th>term as noun</th>
                                <th>good points</th>
                                <th>bad points</th>
                            </tr>
                            <tr>
                                <td>get</td>
                                <td>getter</td>
                                <td>short, easy to say, easy to spell, common amoung programming languages</td>
                                <td>implies the property has been taken away</td>
                            </tr>
                            <tr>
                                <td>set</td>
                                <td>setter</td>
                                <td>short, easy to say, easy to spell, common amoung programming languages</td>
                                <td>sounds more like adding a new property than changing the value of a pre-existing property</td>
                            </tr>
                            <tr>
                                <td>access</td>
                                <td>accessor</td>
                            </tr>
                            <tr>
                                <td>retrieve</td>
                                <td>retriever</td>
                            </tr>
                            <tr>
                                <td>read</td>
                                <td>reader</td>
                            </tr>
                            <tr>
                                <td>write</td>
                                <td>writer</td>
                            </tr>
                            <tr>
                                <td>mutate</td>
                                <td>mutator</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Additional notes:</p>
                    <p>The one letter difference between "get" and "set" (and "getter" and "setter") could cause errors more easily than if the difference were greater. Also, the noun form is slightly irregular; some people may expect "geter" and "seter" to be the noun form.</p>
                </div>
            </div>
        </div>
    </body>
</html>
