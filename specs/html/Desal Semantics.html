<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Desal Semantics 1.0</title>
        <link href="styling.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <h1>Desal Semantics 1.0</h1>
        <h2>Edition 1 Draft 2008/02/01</h2>
        <p>Copyright Â© 2008 James Justin Harrell</p>
        <p>Permission is granted to use, copy, display, modify, sell, and distribute this document. This document is provided "as is" without warrany of any kind. In no event shall anyone be liable for any damages or other liability arising from use of this document.</p>
        <ol class="toc">
            <li>
                <a href="#introduction">1. Introduction</a>
                <ol>
                    <li>
                        <a href="#intro-basic">1.1. Basic</a>
                    </li>
                    <li>
                        <a href="#specification-version">1.2. Version</a>
                    </li>
                    <li>
                        <a href="#specification-scope">1.3. Scope</a>
                    </li>
                    <li>
                        <a href="#compliance">1.4. Compliance</a>
                    </li>
                    <li>
                        <a href="#executing-bundle">1.5. Executing a bundle</a>
                    </li>
                    <li>
                        <a href="#definitions">1.6. Definitions</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#overview">2. Overview</a>
                <ol>
                    <li>
                        <a href="#identikeys">2.1. identikeys</a>
                    </li>
                    <li>
                        <a href="#ext-namespace">2.2. ext namespace</a>
                    </li>
                    <li>
                        <a href="#builtin-numbers">2.3. Built-in numbers</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#values">3. Values</a>
            </li>
            <li>
                <a href="#functions">4. Functions</a>
                <ol>
                    <li>
                        <a href="#function-interfaces">4.1. Function interfaces</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#interfaces">5. Interfaces</a>
                <ol>
                    <li>
                        <a href="#interface-operations">5.1. Adding and subtracting interfaces</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#special-members">6. Special members</a>
                <ol>
                    <li>
                        <a href="#member.add">6.1. add</a>
                    </li>
                    <li>
                        <a href="#member.equals">6.2. equals?</a>
                    </li>
                    <li>
                        <a href="#member.extract">6.3. extract</a>
                    </li>
                    <li>
                        <a href="#member.insert">6.4. insert</a>
                    </li>
                    <li>
                        <a href="#member.throwDivide">6.5. throwDivide</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#scopes">7. Scopes</a>
            </li>
            <li>
                <a href="#handling-declare-first">8. Handling declare-first nodes</a>
            </li>
            <li>
                <a href="#nodes">9. Nodes</a>
                <ol>
                    <li>
                        <a href="#node-terminology">9.1. Node terminology</a>
                    </li>
                    <li>
                        <a href="#tree-node-layout">9.2. Tree node layout</a>
                    </li>
                    <li>
                        <a href="#node-supertypes">9.3. Node supertypes</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#node-types">10. Node types</a>
                <ol>
                    <li>
                        <a href="#base-node-types">10.1. Base nodes</a>
                    </li>
                    <li>
                        <a href="#tree-node-layout-key">10.2. Tree node layout key</a>
                    </li>
                    <li>
                        <a href="#non-executable">10.3. Non-executable</a>
                        <ol>
                            <li>
                                <a href="#node.argument">10.3.1. argument</a>
                            </li>
                            <li>
                                <a href="#node.boolean">10.3.2. boolean</a>
                            </li>
                            <li>
                                <a href="#node.bundle">10.3.3. bundle</a>
                            </li>
                            <li>
                                <a href="#node.direction">10.3.4. direction</a>
                            </li>
                            <li>
                                <a href="#node.generic-parameter">10.3.5. generic-parameter</a>
                            </li>
                            <li>
                                <a href="#node.identikey-category">10.3.6. identikey-category</a>
                            </li>
                            <li>
                                <a href="#node.identikey-type">10.3.7. identikey-type</a>
                            </li>
                            <li>
                                <a href="#node.import">10.3.8. import</a>
                            </li>
                            <li>
                                <a href="#node.parameter">10.3.9. parameter</a>
                            </li>
                            <li>
                                <a href="#node.plane">10.3.10. plane</a>
                            </li>
                            <li>
                                <a href="#node.return-info">10.3.11. return-info</a>
                            </li>
                            <li>
                                <a href="#node.type">10.3.12. type</a>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#non-producing-expressions">10.4. Non-producing expressions</a>
                        <ol>
                            <li>
                                <a href="#iteration">10.4.1. Iteration</a>
                                <ol>
                                    <li>
                                        <a href="#node.do-while">10.4.1.1. do-while</a>
                                    </li>
                                    <li>
                                        <a href="#node.do-times">10.4.1.2. do-times</a>
                                    </li>
                                    <li>
                                        <a href="#node.for-key">10.4.1.3. for-key</a>
                                    </li>
                                    <li>
                                        <a href="#node.for-pair">10.4.1.4. for-pair</a>
                                    </li>
                                    <li>
                                        <a href="#node.for-manual">10.4.1.5. for-manual</a>
                                    </li>
                                    <li>
                                        <a href="#node.for-range">10.4.1.6. for-range</a>
                                    </li>
                                    <li>
                                        <a href="#node.for-value">10.4.1.7. for-value</a>
                                    </li>
                                    <li>
                                        <a href="#node.loop">10.4.1.8. loop</a>
                                    </li>
                                    <li>
                                        <a href="#node.while">10.4.1.9. while</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.break">10.4.2. break</a>
                            </li>
                            <li>
                                <a href="#node.continue">10.4.3. continue</a>
                            </li>
                            <li>
                                <a href="#node.declare-empty">10.4.4. declare-empty</a>
                            </li>
                            <li>
                                <a href="#node.declare-first">10.4.5. declare-first</a>
                            </li>
                            <li>
                                <a href="#node.alias">10.4.6. alias</a>
                            </li>
                            <li>
                                <a href="#node.using">10.4.7. using</a>
                            </li>
                            <li>
                                <a href="#node.return">10.4.8. return</a>
                            </li>
                            <li>
                                <a href="#node.throw">10.4.9. throw</a>
                            </li>
                            <li>
                                <a href="#node.labeled">10.4.10. labeled</a>
                            </li>
                            <li>
                                <a href="#node.yield">10.4.11. yield</a>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#sometimes-producing-expressions">10.5. Sometimes producing expressions</a>
                        <ol>
                            <li>
                                <a href="#node.assign">10.5.1. assign</a>
                            </li>
                            <li>
                                <a href="#node.declare-assign">10.5.2. declare-assign</a>
                            </li>
                            <li>
                                <a href="#node.unassign">10.5.3. unassign</a>
                            </li>
                            <li>
                                <a href="#node.block">10.5.4. block</a>
                            </li>
                            <li>
                                <a href="#node.possibility">10.5.5. possibility</a>
                            </li>
                            <li>
                                <a href="#node.conditional">10.5.6. conditional</a>
                            </li>
                            <li>
                                <a href="#node.select">10.5.7. select</a>
                                <ol>
                                    <li>
                                        <a href="#node.case">10.5.7.1. case</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.try-catch">10.5.8. try-catch</a>
                                <ol>
                                    <li>
                                        <a href="#node.exception-handler">10.5.8.1. exception-handler</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.call">10.5.9. call</a>
                            </li>
                            <li>
                                <a href="#node.curry">10.5.10. curry</a>
                            </li>
                            <li>
                                <a href="#node.ignore">10.5.11. ignore</a>
                                <ol>
                                    <li>
                                        <a href="#node.ignore-member">10.5.11.1. ignore-member</a>
                                    </li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#always-producing-expresions">10.6. Always producing expressions</a>
                        <ol>
                            <li>
                                <a href="#boolean-logic">10.6.1. Boolean logic</a>
                                <ol>
                                    <li>
                                        <a href="#node.and">10.6.1.1. and</a>
                                    </li>
                                    <li>
                                        <a href="#node.nand">10.6.1.2. nand</a>
                                    </li>
                                    <li>
                                        <a href="#node.or">10.6.1.3. or</a>
                                    </li>
                                    <li>
                                        <a href="#node.nor">10.6.1.4. nor</a>
                                    </li>
                                    <li>
                                        <a href="#node.xor">10.6.1.5. xor</a>
                                    </li>
                                    <li>
                                        <a href="#node.xnor">10.6.1.6. xnor</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.array">10.6.2. array</a>
                            </li>
                            <li>
                                <a href="#node.cast">10.6.3. cast</a>
                            </li>
                            <li>
                                <a href="#node.chain">10.6.4. chain</a>
                            </li>
                            <li>
                                <a href="#node.class">10.6.5. class</a>
                                <ol>
                                    <li>
                                        <a href="#node.declare-class">10.6.5.1. declare-class</a>
                                    </li>
                                    <li>
                                        <a href="#node.declaration">10.6.5.2. declaration</a>
                                    </li>
                                    <li>
                                        <a href="#node.declare-const-empty">10.6.5.3. declare-const-empty</a>
                                    </li>
                                    <li>
                                        <a href="#node.interface-implementation">10.6.5.4. interface-implementation</a>
                                    </li>
                                    <li>
                                        <a href="#node.named-function">10.6.5.5. named-function</a>
                                    </li>
                                    <li>
                                        <a href="#node.class-property">10.6.5.6. class-property</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.comprehension">10.6.6. comprehension</a>
                                <ol>
                                    <li>
                                        <a href="#node.comprehension-type">10.6.6.1. comprehension-type</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.copy">10.6.7. copy</a>
                            </li>
                            <li>
                                <a href="#node.convert">10.6.8. convert</a>
                            </li>
                            <li>
                                <a href="#node.dictionary">10.6.9. dictionary</a>
                                <ol>
                                    <li>
                                        <a href="#node.dictionary-entry">10.6.9.1. dictionary-entry</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.enum">10.6.10. enum</a>
                                <ol>
                                    <li>
                                        <a href="#node.enum-entry">10.6.10.1. enum-entry</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.function">10.6.11. function</a>
                            </li>
                            <li>
                                <a href="#node.function-interface">10.6.12. function-interface</a>
                            </li>
                            <li>
                                <a href="#node.generator">10.6.13. generator</a>
                            </li>
                            <li>
                                <a href="#node.generic-class">10.6.14. generic-class</a>
                            </li>
                            <li>
                                <a href="#node.generic-function">10.6.15. generic-function</a>
                            </li>
                            <li>
                                <a href="#node.generic-interface">10.6.16. generic-interface</a>
                            </li>
                            <li>
                                <a href="#node.get-property">10.6.17. get-property</a>
                            </li>
                            <li>
                                <a href="#node.identifier">10.6.18. identifier</a>
                            </li>
                            <li>
                                <a href="#node.instantiate-generic-class">10.6.19. instantiate-generic-class</a>
                            </li>
                            <li>
                                <a href="#node.intantiate-generic-function">10.6.20. instantiate-generic-function</a>
                            </li>
                            <li>
                                <a href="#node.instantiate-generic-interface">10.6.21. instantiate-generic-interface</a>
                            </li>
                            <li>
                                <a href="#node.implements">10.6.22. implements</a>
                            </li>
                            <li>
                                <a href="#node.integer">10.6.23. integer</a>
                            </li>
                            <li>
                                <a href="#node.interface">10.6.24. interface</a>
                                <ol>
                                    <li>
                                        <a href="#node.statused-member">10.6.24.1. statused-member</a>
                                    </li>
                                    <li>
                                        <a href="#node.member-status">10.6.24.2. member-status</a>
                                    </li>
                                    <li>
                                        <a href="#node.interface-member">10.6.24.3. interface-member</a>
                                    </li>
                                    <li>
                                        <a href="#node.convertor">10.6.24.4. convertor</a>
                                    </li>
                                    <li>
                                        <a href="#node.callee">10.6.24.5. callee</a>
                                    </li>
                                    <li>
                                        <a href="#node.property">10.6.24.6. property</a>
                                    </li>
                                    <li>
                                        <a href="#node.method">10.6.24.7. method</a>
                                    </li>
                                    <li>
                                        <a href="#node.access">10.6.24.8. access</a>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <a href="#node.namespaced-identikey">10.6.25. namespaced-identikey</a>
                            </li>
                            <li>
                                <a href="#node.rational">10.6.26. rational</a>
                            </li>
                            <li>
                                <a href="#node.set-property">10.6.27. set-property</a>
                            </li>
                            <li>
                                <a href="#node.string">10.6.28. string</a>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#unsorted-nodes">10.7. Unsorted nodes</a>
                        <ol>
                            <li>
                                <a href="#node.identifier-chain">10.7.1. identifier-chain</a>
                            </li>
                            <li>
                                <a href="#node.unassign-function">10.7.2. unassign-function</a>
                            </li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#special-identikeys">11. Special identikeys</a>
            </li>
            <li>
                <a href="#standard-library">12. Standard library</a>
                <ol>
                    <li>
                        <a href="#object.activeInterface">12.1. activeInterface</a>
                    </li>
                    <li>
                        <a href="#object.cast">12.2. func{I}(dyn)I cast</a>
                    </li>
                    <li>
                        <a href="#object.generator">12.3. interface generator</a>
                    </li>
                    <li>
                        <a href="#object.id">12.4. func id</a>
                    </li>
                    <li>
                        <a href="#object.sameObject_q">12.5. func sameObject?</a>
                    </li>
                    <li>
                        <a href="#object.implements_q">12.6. func(obj, interface)bool implements?</a>
                    </li>
                    <li>
                        <a href="#ident.Int">12.7. interface Int</a>
                    </li>
                    <li>
                        <a href="#object.BigInt">12.8. interface BigInt</a>
                    </li>
                    <li>
                        <a href="#object.BigRat">12.9. interface BigRat</a>
                    </li>
                    <li>
                        <a href="#ident.Interface">12.10. interface Interface</a>
                    </li>
                    <li>
                        <a href="#object.Object">12.11. interface Object</a>
                    </li>
                    <li>
                        <a href="#interface.rat">12.12. interface rat</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#warnings-list">13. Warnings</a>
            </li>
            <li>
                <a href="#preexisting-global-identikeys">14. Other preexisting global identikeys</a>
                <ol>
                    <li>
                        <a href="#Generator">14.1. Generator</a>
                    </li>
                    <li>
                        <a href="#InterfaceBuilder">14.2. InterfaceBuilder</a>
                    </li>
                    <li>
                        <a href="#Iterator">14.3. Iterator</a>
                    </li>
                    <li>
                        <a href="#CInterfaceBuilder">14.4. CInterfaceBuilder</a>
                    </li>
                    <li>
                        <a href="#getFuncInterface">14.5. getFuncInterface</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#error-handling-processing">15. Error handling during processing</a>
            </li>
            <li>
                <a href="#warnings">16. warnings</a>
            </li>
            <li>
                <a href="#rationales">17. Rationales</a>
                <ol>
                    <li>
                        <a href="#rationale.dynamic-static-typing">17.1. Dynamic static typing</a>
                    </li>
                    <li>
                        <a href="#rationale.terms">17.2. Terms</a>
                        <ol>
                            <li>
                                <a href="#rationale.get-set">17.2.1. get/set</a>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#rationale.executing-boolean-logic">17.3. Executing boolean logic nodes</a>
                    </li>
                    <li>
                        <a href="#executing-declaration-first">17.4. Disallowing executing declaration-first</a>
                    </li>
                </ol>
            </li>
            <li>
                <a href="#unsorted-stuff">18. unsorted stuff</a>
                <ol>
                    <li>
                        <a href="#closures">18.1. Closures</a>
                    </li>
                    <li>
                        <a href="#tree-examples">18.2. Tree examples</a>
                        <ol>
                            <li>
                                <a href="#tree-example-1">18.2.1. Example 1</a>
                            </li>
                            <li>
                                <a href="#tree-example-2">18.2.2. Example 2</a>
                            </li>
                            <li>
                                <a href="#tree-example-3">18.2.3. Example 3</a>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <a href="#get-interface">18.3. get interface</a>
                    </li>
                    <li>
                        <a href="#obj-interface">18.4. obj interface</a>
                    </li>
                    <li>
                        <a href="#identifier-binding">18.5. Binding to identifiers</a>
                    </li>
                    <li>
                        <a href="#print-println-return-interfaces">18.6. Return interfaces of print and println</a>
                    </li>
                    <li>
                        <a href="#adjuncts">18.7. Adjuncts</a>
                    </li>
                    <li>
                        <a href="#runtime-inteface">18.8. runtime interface implementation</a>
                    </li>
                    <li>
                        <a href="#runtime-interface-creation">18.9. Runtime interface creation</a>
                    </li>
                    <li>
                        <a href="#self-return-type">18.10. "self" return type</a>
                    </li>
                    <li>
                        <a href="#bind">18.11. Bind</a>
                    </li>
                    <li>
                        <a href="#classes">18.12. Classes</a>
                    </li>
                    <li>
                        <a href="#noninstantiated-interface-templates">18.13. Noninstantiated interface templates</a>
                    </li>
                    <li>
                        <a href="#dynamic-library-loading">18.14. Dynamic library loading</a>
                    </li>
                    <li>
                        <a href="#static-typing">18.15. Static typing</a>
                    </li>
                </ol>
            </li>
        </ol>
        <div id="introduction">
            <h1>Chapter 1. Introduction</h1>
            <div id="intro-basic">
                <h2>1.1. Basic</h2>
                <p>Desal is a collection of abstract nodes. Nodes that can be "executed" are called "expressions". (Desal does not make use of the terms "statement", "evaluate", or "evaluation".) Some expressions "produce" a value when executed, and others do not.</p>
                <p>How Desal nodes are represented is outside the scope of this standard. Syntax and semantics are intended to be entirely separate.</p>
                <p>Desal contains some dynamic aspects, but in several ways is very static. For example, the tree of scopes ("environments" in some languages) and variables/constants ("identikeys" in Desal) can be entirely known before runtime; identikeys cannot be declared conditionally like in highly dynamic languages such as JavaScript.</p>
            </div>
            <div id="specification-version">
                <h2>1.2. Version</h2>
                <p>Each version of Desal Semantics has a major version number and a minor version number, both integers incrementing by one. When the major version number is incremented, the minor version number is reset to 0.</p>
                <p>All versions of Desal Semantics should be backwards compatible with previous versions that have the same major version number. That means the major version number should be changed when changes are made that break backwards compatibility.</p>
                <p>Example: Something that is valid Desal Semantics 5.3 will also be valid Desal Semantics 5.4, 5.5, 5.6, etc.</p>
                <p>Each specification describing a version of Desal Semantics may have multiple editions, each represented by an integer that's incremented by one. The first finalized specification for a version of Desal Semantics is the first edition, or edition one. Creating a new edition is a revision. Revisions should serve to clarify, add guidance, and correct errors in the specification, not to add or remove functionality. Revisions should not attempt to correct errors in Desal Semantics, only errors in describing Desal Semantics. Implementations should target the latest finalized edition of the version they are targeting.</p>
                <p>Each edition may have multiple drafts before being finalized. Each draft is represented by a date around the time it was published. Implementations and specifications should not target drafts.</p>
                <p>A version of Desal Semantics may be represented as "Desal Semantics X.Y" where X is the major version number and Y is the minor version number. A finalized specification for Desal Semantics may be represented as "Desal Semantics X.Y Edition A" where A is the edition number. A draft of a specification may be represented as "Desal Semantics X.Y Edition A Draft B" where B is the date in YYYYMMDD format.</p>
                <p>This specification describes Desal Semantics 1.0. This specification has never been finalized, so is working towards the first edition. It is still in the draft stages.</p>
                <p>When this specification is finalized, it will be Edition 1 (instead of Edition 1 Draft YYYYMMDD). If the finalized specification is revised, the next finalized edition will be Edition 2.</p>
            </div>
            <div id="specification-scope">
                <h2>1.3. Scope</h2>
                <p>This document defines Desal semantics, but not how to represent them.</p>
            </div>
            <div id="compliance">
                <h2>1.4. Compliance</h2>
                <p>This specification provides a definition of compliance. Other definitions of compliance may exist outside of this specification, but to be compliant as defined by this specification, these requirements must be met.</p>
                <p>For an implementation to be "base compliant", it must meet all the "must" requirements listed in this spec. If this spec says an implementation "must" do something, the implementation will not be considered base compliant according to this specification if it does not do it.</p>
                <p>Above base compliance, there are further levels of compliance. Each correct implementation of a "should" requirement increases the compliance level, and each failure to implement a "should" requirement decreases the compliance level. Two different compliance levels can only be compared if one is a subset of the other.</p>
                <p>For example, consider an implementation Alpha that meets all the "must" requirements and three of the the "should" requirements, and an implementation Beta that meets all the "must" requirements and five of the "should" requirements. If Beta does not meet the three "should" requirements that Alpha meets, Aplha is not a subset of Beta, so it cannot be said that Beta is more compliant than Alpha. But if Beta meets the same three "should" requirements as Alpha (in addition to the other two), then Alpha is a subset of Beta, so it can be said that Beta is more compliant than Alpha.</p>
                <p>This specification also has "encourgements". These encouragements are considered good ideas by the specficiation author(s), but may not always be appropriate or may not be necessary for interoperability. Complying with these encouragements does not increase an implementation's compliance.</p>
            </div>
            <div id="executing-bundle">
                <h2>1.5. Executing a bundle</h2>
                <p>Note: A bundle might not have a main function. It might just expose its members, such as for scripting or a library.</p>
                <p>interpreted:</p>
                <ol>
                    <li>a bundle representation is parsed to extract a tree of Desal Semantics nodes</li>
                    <li>libraries are loaded and linked</li>
                    <li>tree is processed</li>
                    <li>optimization</li>
                    <li>execution of the planes' declaration-first nodes</li>
                    <li>execution of the function bound to "main" attached to the bundle node's scope, which may return an exit status</li>
                    <li>returning exit status, or 0 if none specified</li>
                </ol>
                <p>runtime compilation:</p>
                <ol>
                    <li>a bundle representation is parsed to extract a tree of Desal Semantics nodes</li>
                    <li>libraries are loaded and linked</li>
                    <li>tree is processed</li>
                    <li>optimization</li>
                    <li>tree translated to bytecode and/or machine code</li>
                    <li>execution of bytecode and/or machine code, which produces an exit status</li>
                </ol>
                <p>beforehand compilation:</p>
                <ol>
                    <li>a bundle representation is parsed to extract a tree of Desal Semantics nodes</li>
                    <li>static libaries are loaded</li>
                    <li>information about shared libraries is obtained</li>
                    <li>tree is processed</li>
                    <li>optimization</li>
                    <li>tree translated to bytecode and/or machine code and stored</li>
                    <li>code is loaded</li>
                    <li>shared libraries are loaded and linked</li>
                    <li>processing</li>
                    <li>execution of bytecode and/or machine code, which produces an exit status</li>
                </ol>
                <p>This spec should define how to:</p>
                <ul>
                    <li>process a bundle (a valid tree of Desal Semantics nodes with a bundle node as the root node)</li>
                    <li>execute nodes of a processed tree</li>
                    <li>execute a bundle</li>
                </ul>
                <p>Implementations that aren't interpreters should produce equivalent behavior when being executed.</p>
            </div>
            <div id="definitions">
                <h2>1.6. Definitions</h2>
                <dl>
                    <dt>Desal agent</dt>
                    <dt>agent</dt>
                    <dd>An implementation of the Desal language. Could be a source interpreter, a bytecode intepreter, a bytecode compiler, a machine code compiler, etc. If it recognizes the semantics of what it's running, and follows the rules of this document, it could be called a Desal agent. Each agent should define what representations it supports.</dd>
                    <dt>expression</dt>
                    <dd>Nodes that can be executed.</dd>
                    <dt>object</dt>
                    <dd>A collection of data that holds state. Created by a class. Only the class that created it can access an object's state. Values are associated with objects.</dd>
                    <dt>identikey</dt>
                    <dd>bound to one or more values. An identifier in a certain scope is associated with an identikey.</dd>
                    <dt>value</dt>
                    <dd>Associated with an object and an interface implementation, except for the null value, which is associated with nothing or associated with an interface</dd>
                    <dt>active interface implementation</dt>
                    <dd>the interface implementation a value is directly associated with</dd>
                    <dt>active interface</dt>
                    <dd>the interface that the active interface implementation is associated with</dd>
                    <dt>prevalent</dt>
                    <dd>values bound to the global scope that exist before source begins execution. No other objects may be bound to the same identifiers, even in inner scopes.</dd>
                    <dt>global scope</dt>
                    <dd>the scope of the bundle node. a bundle node has one and only one scope each time the bundle is executed</dd>
                    <dt>element</dt>
                    <dd>A value stored in a container.</dd>
                    <dt>member</dt>
                    <dd>A callee, property, method, or conversion of an interface.</dd>
                    <dt>method</dt>
                    <dd>A member function of an interface.</dd>
                </dl>
            </div>
        </div>
        <div id="overview">
            <h1>Chapter 2. Overview</h1>
            <p>Desal semantics are represented by a node tree. The way this node tree is represented is not covered in this specification. This specification explains what kind of node tree a representation can represent, the meaning of the nodes in a Desal node tree, and how to execute the node tree.</p>
            <p>This node tree has scopes attached at various places. These scopes contain identikeys that are bound to namespaces and values.</p>
            <div id="identikeys">
                <h2>2.1. identikeys</h2>
                <p>An identikey is associated with a scope, an identifier, and zero or more values. An identikey may place restrictions on what values in can be associated with. It may be mutable so that what values it is associated with can change, or immutable so that in cannot be reassociated with different values.</p>
                <p>Every scope is assocciated with zero or more identikeys. Identikeys associated with the same scope must each be associated with a different identifier.</p>
                <p>When an identifier node is executed, every identikey in the scope the identifier node resides in is checked to see if the identikey is associated with an equivalent identifier. If it is, the value produce by executing the identifier node is obtained from the identikey. The identifier node execution process moves up through the scope tree (not to be confused with the scope formula tree) looking for an identikey associated with an equivalent identifier.</p>
                <pre>
dyn foo = 123
foo = "bar"
foo = getSomething()

auto foo = getSomething()

Int foo
foo = 2
foo = 89

func foo

func Int foo //bound functions must return an Int
</pre>
                <dl>
                    <dt>namespace</dt>
                    <dd>cannot be executed</dd>
                    <dt>dynamic</dt>
                    <dd>any value</dd>
                    <dt>automatic</dt>
                    <dd>interface taken from first value bound to it, then behaves like strict</dd>
                    <dt>strict</dt>
                    <dd>all values bound to it must have the specified interface as a downcast-able interface</dd>
                    <dt>function</dt>
                    <dd>any value with a function interface as the active interface, or any value with a function interface as the active interface that specifies the specified return interface</dd>
                </dl>
                <p>These identikey types come in constant and variable forms:</p>
                <ul>
                    <li>automatic</li>
                    <li>strict</li>
                    <li>function</li>
                </ul>
                <p>Dynamic identikeys are always variable.</p>
                <p>A function identikey can be bound to multiple functions (objects that implement a function interface; xxx link) at the same time. A function identikey can never be bound to multiple functions with the same interface.</p>
                <p>If the value does not implement the interface of the identifier, a cast error results (doesn't apply to dyn).</p>
                <p>If a value has multiple callees, the active interface is not a function interface, and thus it cannot be bound to a function identikey. The value must be cast to each function interface, and each resulting value bound individually to the function identikey.</p>
                <p>Overloading an identifier means binding multiple object references to it.</p>
                <p>Const identikeys can never be unbound from what they're bound to. Function, strict, and automatic identikeys can be const.</p>
                <code xml:space="preserve">interface Foo func fooMeth() interface Bar func barMeth() Dyn obj = getFoo() obj.fooMeth() obj = getBar() obj.barMeth()</code>
                <code xml:space="preserve">dyn foo //same as: dyn foo = null foo = getBar() foo.barProp foo = 3 foo.minus(5) foo = "test" foo.toUpperCase() foo = CMyClass() foo.myClassProp foo = cast {BazInterface} alpha foo.bazProp foo = cast {MazInterface} alpha foo.mazProp foo = cast {GazInterface} alpha foo.gazProp (BazInterface foo) .bazProp (MazInterface foo) .mazProp</code>
            </div>
            <div id="ext-namespace">
                <h2>2.2. ext namespace</h2>
                <p>Unofficial features of Desal should appear in the "extension" namespace when possible. Implementations do not have to recognize extensions or support them, although they are encouraged to at least recognize them in order to give more useful error messages.</p>
                <p>Normal library functions that do not portray any special action not possible with normal Desal code should not appear in the "extension" namespace.</p>
                <code xml:space="preserve">import atExit from extension atExit.addListener(myfunc)</code>
            </div>
            <div id="builtin-numbers">
                <h2>2.3. Built-in numbers</h2>
                <p>The built-in implementations of the Int and Rat interfaces must be able to handle numbers of an arbitrary complexity. Built-in libraries should handle numbers of an arbitrary complexity. Desal implementations must not ever introduce rounding errors or otherwise introduce numerical errors without being explicitly told that such errors may occur.</p>
                <p>For example, pow(10, pow(10,100)), must correctly return an Int object reference that accurately represents a googolplex, and must be able to perform operations on this number with perfect accuracy.</p>
                <p>Implementations may throw errors when they are unable to perfectly represent a number. Implementations must not silently introduce errors. This is the only alternative to perfectly representing the number.</p>
                <p>For example, if the implementation was directed by user code to print a googolplex without using scientific notation (i.e. a "1" followed by a googol "0"), the implementation may throw an error specifying that it is unable to create such a representation.</p>
            </div>
        </div>
        <div id="values">
            <h1>Chapter 3. Values</h1>
            <p>Values are associated with an object and an interface implementation.</p>
            <p>Objects hold which is used by the interface implementation. This state can only be accessed or modified by interface implementations that they object was intented to hold state for. Objects have an ID that never changes. Each interface implementation consists of the implementation of the members of that interface.</p>
            <p>This specification may speak of values implementing interfaces. In these cases, what is actually refered to is whether the interface implementation the value is associtiated with is in a tree where one of the interface implementations is an implementation of that interface. The value itself does not actually implement any interfaces.</p>
            <p>Interface implementations form a tree. Multiple interface implementations in the same tree can implement the same iterface. When a value has an active interface that has multiple implementations, the interface implementation that is used when the value is accessed is the interface implementation that the vaule is associated with.</p>
        </div>
        <div id="functions">
            <h1>Chapter 4. Functions</h1>
            <p>Functions are just values with an active interface that defines callees. Functions can be "called". Functions can have a return interface and parameters. Parameters have an interface and an optional default value.</p>
            <div id="function-interfaces">
                <h2>4.1. Function interfaces</h2>
                <p>XXX this needs a lot of work</p>
                <p>Function interfaces implement FunctionInterface instead of Interface and inherit from Function. FunctionInterface simply inherits from Interface and defines no new members. Function interfaces declare a callee and an "apply" method that hides the members of the Function interface.</p>
                <pre>
interface Function
        callee(dyn[] params) dyn
        func apply(dyn[] arguments) dyn //actually takes an array
        func bind(dyn[] params) dyn
        func call(dyn[] params) dyn
        func curry(dyn[] params) dyn
        get List&gt;Parameter&gt; parameters
        get Bool return?
        get nullable Interface returnInterface

all function interfaces
        inherit Function
        callee(...) ...
        func apply(dyn[] params) ...
        func call(...) ...

For example, for func(Int a, Rat b, String c) Bool :

interface (func(Int a, Rat b, String c) Bool)
        inherit Function
        callee(Int a, Rat b, String C) Bool
        func apply(dyn[] params) Bool
        func call(Int a, Rat b, String C) Bool
        get parameters returns List {
                Parameter { "a", Int },
                Parameter { "b", Rat },
                Parameter { "c", String } }
        get return? returns true
        get returnInterface returns Bool
</pre>
            </div>
        </div>
        <div id="interfaces">
            <h1>Chapter 5. Interfaces</h1>
            <p>Interfaces define a means of interacting with an object's state. Interfaces declare that implementations will be able to provide object references with specified interfaces when asked for the object reference bound to identifiers specified by the interface and/or that implementations will be able to bind object references with specified interfaces to specified identifiers. Methods are a type of property. Methods are callable and cannot be assigned, only retrieved.</p>
            <p>Interfaces can declare that properties are "get only", "set only", or "get and set".</p>
            <p>Interface member functions can have default values. This differs from a class with abstract members because interfaces cannot have any private members, so these default functions can not store or extract state in the object. These functions are only intended to call other member functions or throw errors.</p>
            <p>There are two kinds of interfaces: object interfaces (Interface) and function interfaces (FuncInterface). Object interfaces define properties and methods. Function interfaces define parameters and a return type. An interface cannot be a function interface and an object interface, though an object interface can have call methods that allow implementations to be used like functions. A function interface can be wrapped to an object interface with a single call method.</p>
            <p>Interface callees and members may refer to the interface. This is useful when an interface wants to define a method that returns an object reference with itself as the active interface. For generic interfaces, it is also possible to refer to the generic template.</p>
            <code xml:space="preserve">interface Int func power(Self) Self r Self timesTwo //some representations may be able to translate the below example as well iterface Int func power(Int) Int r Int timesTwo //note that the interface node will have no knowledge of the identifier it is being bound to //generics: interface&lt;T&gt; Print callee(T) Self Print&lt;Int&gt; print = getIntPrinter() print(3)(5)(8) //the print callee returns a Print&lt;Int&gt; object reference //refering to Generic interface interface&lt;T&gt; Print callee(T) GenericSelf Print print = getGenericPrinter() print &lt;Int&gt;(3) &lt;String&gt;("foo") &lt;Rat&gt;(1.23) //some representations may also allow: print 3 "foo" 1.23</code>
            <div id="interface-operations">
                <h2>5.1. Adding and subtracting interfaces</h2>
                <p>Interfaces can be added together to produce other interfaces. How this addition occurs depends on whether the operands were produce through addition, and the inherited interfaces of the operands.</p>
                <p>If an interface is "fromAddition", it was produced through addition and/or subtract. The 
                <a href="#ident.Interface">Interface interface</a>exposes this information as a property.</p>
                <p>Interfaces produced from addition don't define any members themeselves; they only inherit from other interfaces.</p>
                <p>No interface can inherit from an interface that is fromAddition. When a fromAddition interface is an operand of interface addition, the inheritees of the fromAddition interface are copied into the produced interface, but the produced interface does not inherit from the fromAddition operands.</p>
                <p>No interface that is fromAddition can inherit from a single interface. When subtracting from a fromAddition interface, and the produced interface would have otherwise only inherited from a single interface, the produced interface is actually that single interface that it would have inherited from.</p>
                <pre>
interface A
        fromAddition = false

interface B
        fromAddition = false

interface C
        fromAddition = true

interface D
        fromAddition = true

interface A+B
        inherit A
        inherit B

interface A+C
        inherit A
        C's inheritees (doesn't inherit from C)

interface A+D
        inherit A
        D's inheritees (doesn't inherit from D)

interface B+C
        inherit B
        C's inheritees (doesn't inherit from C)

interface B+D
        inherit B
        D's inheritees (doesn't inherit from D)

interface C+D
        C's inheritees (doesn't inherit from C)
        D's inheritees (doesn't inherit from D)

(A+B)-B must be A, not a fromAddition interface that inherits only from A.

consider this expression:
        (A+B+C)-(B+C)
if:
        * C is fromAddition
        * A and B are not fromAddition
        * C inherits from C1, C2, and C3
then the expresison is equal to:
        (A+B+C1+C2+C3)-(B+C1+C2+C3)
        (A+B+C1+C2+C3)-B-C1-C2-C3
        A
</pre>
                <p>xxx ENSURE ORDER DOESN'T MATTER</p>
                <p>Addition with operands A and B:</p>
                <ol>
                    <li>Create an interface, PRODUCT, where fromAddition is true.</li>
                    <li>If A is fromAddition, copy the inheritees of A to PRODUCT. If A is not fromAddition, add A as an inheritee to PRODUCT.</li>
                    <li>If B is fromAddition, copy the inheritees of B to PRODUCT. If B is not fromAddition, add B as an inheritee to PRODUCT.</li>
                    <li>If PRODUCT has only one inheritee, produce that inheritee. Otherwise, produce PRODUCT.</li>
                </ol>
                <p>Note: An example of when PRODUCT would only have one inheritee from addition is when an interface that is not fromAddition is added to itself. i.e. A + A = A</p>
                <p>Subtraction with operands A and B:</p>
                <ol>
                    <li>If A is not fromAddition, throw an error.</li>
                    <li>Copy A as PRODUCT. (i.e. Copy A. We'll refer to this copy as PRODUCT.)</li>
                    <li>If B is fromAddition, remove every inheritee of B from the inheritees of PRODUCT. If any of the inheritees of B is not an inheritee of PRODUCT, throw an error.</li>
                    <li>If B is not fromAddition, remove B from the inheritees of PRODUCT. If B is an inheritee of PRODUCT, throw an error.</li>
                    <li>If PRODUCT has only one inheritee, produce that inheritee. If PRODUCT does not have any inheritees, throw an error. Otherwise, produce PRODUCT.</li>
                </ol>
            </div>
        </div>
        <div id="special-members">
            <h1>Chapter 6. Special members</h1>
            <p>Some identifiers can only be bound to certain types of properties and methods, and have a predefined meaning. Thus, the semantics of a member with one of these identifiers is already predefined by this specification.</p>
            <p>Many of these special predefined members come in mutating and non-mutating forms. In these cases, the mutating form modifies the object and returns nothing while the non-mutating form returns a copy of the object with the mutation.</p>
            <p>Implementations must prevent identifiers from being bound to other types. Implementations are encouraged to provide shortcuts for accessing/using these members. Some examples in this section show a possible usage of the methods with and without shortcuts.</p>
            <p>add, subtract, multiply, divide, add!, subtract!, multiply!, divide!, equals?, lessThan?, lessThanOrEqual?, equal?, greaterThanOrEqual?, greaterThan?, unequal?, remainder, remainder!, floorDivide, floorDivide!, power, power!, absolute, absolute!, positive?, negative?, concat, concat!, remove, remove!</p>
            <div id="member.add">
                <h2>6.1. add</h2>
                <pre>
func add(Self) Self
</pre>
                <pre>
func add!(Self)
</pre>
                <p>Inserts an object into a container, joins data together, sends an object to something, etc. This method should only be used when order is not significant, such as when adding integers. When order is significant, such as when concatenating strings, the 
                <a href="#member.insert">insert method</a>would be more appropriate.</p>
                <code xml:space="preserve">Int a = 1.add(2) a.add!(3) Int a = 1 + 2 a += 3</code>
            </div>
            <div id="member.equals">
                <h2>6.2. equals?</h2>
                <pre>
func equals?(Self o) Bool
</pre>
                <p>Tells whether the owner value and the argument value both have state for the interface that, from the outside, appears the same.</p>
                <code xml:space="preserve">if( a == b ) print "they equal each other"</code>
            </div>
            <div id="member.extract">
                <h2>6.3. extract</h2>
                <p>
                <pre>
func extract!() Foo
</pre>Throws if there is nothing to extract.</p>
                <p>
                <pre>
func extract!(out Foo) Bool
</pre>Returns false if there is nothing to extract.</p>
                <code xml:space="preserve">println container.extract!() while container &gt;&gt; obj println obj</code>
            </div>
            <div id="member.insert">
                <h2>6.4. insert</h2>
                <pre>
func insert(Self) Self
</pre>
                <pre>
func insert!(Self)
</pre>
                <p>Inserts an object into a container, joins data together, sends an object to something, etc. This method should only be used when order is significant, such as when concatenating strings. When order is not significant, such as when adding integers, the 
                <a href="#member.add">add method</a>would be more appropriate.</p>
                <code xml:space="preserve">String a = "foo".insert("bar") a.insert!("gaz") String a = "foo" &amp; "bar" a &lt;&lt; "gaz"</code>
            </div>
            <div id="member.throwDivide">
                <h2>6.5. throwDivide</h2>
                <pre>
func throwDivide(Int) Int
</pre>
                <pre>
func throwDivide(Rat) Int
</pre>
                <pre>
func throwDivide!(Int)
</pre>
                <pre>
func throwDivide!(Rat)
</pre>
                <p>Throws an error if the result is not an integer.</p>
            </div>
        </div>
        <div id="scopes">
            <h1>Chapter 7. Scopes</h1>
            <p>Scopes consist of a collection of identikeys, and unless it is the scope of the bundle node, an association with a parent scope. Scopes form a hierarchy. When identifier nodes are executed, the current scope is searched for an identikey that is associated with that identifier. If one is not found, that scope's parent scope is searched, and so on, until a matching identikey is found. If such an identikey cannot be found, an error results.</p>
            <p>When execution enters a node that "has scope", before executing that node, all contained declare-first descendant nodes that do not have a closer "with scope" ancestor node, are handled according to 
            <a href="#handling-declare-first">this section</a>.</p>
        </div>
        <div id="handling-declare-first">
            <h1>Chapter 8. Handling declare-first nodes</h1>
            <p class="xxx">Rename this section to something like "entering node that has scope" or "creating new scope"?</p>
            <p>This section specifies the actions that must take place when execution first reaches a node that "has scope".</p>
            <ol class="exec">
                <li>Let scopeNode be the node that "has scope" that execution just reached, i.e., the node that lead to this process being performed.</li>
                <li>Let nodeList be an ordered list of all declare-first nodes that: 
                <ul>
                    <li>are descendants of scopeNode, and</li>
                    <li>do not have an ancestor node that: 
                    <ul>
                        <li>"has scope" or "has closure", and</li>
                        <li>is a descendant of scopeNode</li>
                    </ul></li>
                </ul></li>
                <li>Let listCount be the number of elements in nodeList.</li>
                <li>Let thisScope be a new scope.</li>
                <li>Add the identikeys specified by the nodes in nodeList to thisScope.</li>
                <li>Let currentNode be the first node in nodeList. If nodeList is empty, end this process and begin execution of scopeNode with thisScope as the associated scope.</li>
                <li>Begin executing the [value] member of currentNode. 
                <ul>
                    <li>If execution needs to evaluate an identikey created by this process, and the [value] member of the declare-first node associated with that identikey has not yet been evaluated and the product assigned to that identikey, pause the execution of this [value] member.</li>
                    <li>If execution completes successfully, assign the product to the associated identikey, and remove currentNode from nodeList.</li>
                </ul></li>
                <li>Set currentNode to the next node in nodeList and go to step 6. (If currentNode was removed, the next node would be the node that followed currentNode when currentNode was in the list.) If there is no next node, continue to the next step.</li>
                <li>If the number of elements in nodeList is equal to listCount, a cyclical dependency likely exists, where two or more expressions rely on the result of each other to execute. In this case, throw an error. If the number of elements in nodeList is not equal to listCount, set listCount to the number of elements in nodeList and go to step 5.</li>
            </ol>
            <pre>
Example 1 of a cyclical dependency:

declfirst a = b + 2
declfirst b = a + 3

Example 2 of a cyclical dependency:

declfirst a = b + 2
declfirst b = c + 3
declfirst c = d + 4
declfirst d = e + 5
declfirst e = a + 6

Example 1 of a non-cyclical dependency:

declfirst a = b + 2
declfirst b = c + 3
declfirst c = d + 4
declfirst d = e + 5
declfirst e = 6

Example 2 of a non-cyclical dependency:

declfirst func foo = func() {
        bar()
}

declfirst func bar = func() {
        foo()
}
</pre>
            <p>Concerning the last example: When one of these functions is called, infinite recursion occurs (negating intervention by the agent), but no such cycle is involved in just executing the function nodes. This is because the calls to foo and bar are not executed when the function nodes are executed.</p>
        </div>
        <div id="nodes">
            <h1>Chapter 9. Nodes</h1>
            <p>Desal semantics are represented by a tree of nodes. How this tree and its nodes are represented is outside the scope of this specification. Many means may exist of representing a Desal tree.</p>
            <p>Nodes are either base nodes or tree nodes. Tree nodes only contain other nodes, and their entire meaning is derived from their child nodes. Base nodes do not contain any other child nodes, and must is some way encode their meaning themselves.</p>
            <p>When a node has multiple child nodes with equivalent meaning, the order of those child nodes is significant, so their order must be specified by some means. The order of nodes of different meaning in relation to each other is not significant, and must not have any observable side effects.</p>
            <p>The child nodes of tree nodes are sometimes executed in order, such as expressions in blocks and arguments in function calls. This means the order of the child nodes is sometimes significant and thus should always be preserved.</p>
            <p>How ordering is represented has no effect on the semantics (left-to-right, numbered, linked list, etc) as long as there is a specified order. Each representation should specify how nodes are ordered.</p>
            <p>Node type names are nouns or noun phrases. XXX find correct English terminology</p>
            <div id="node-terminology">
                <h2>9.1. Node terminology</h2>
                <p>If a node can contain other nodes, it is a tree node. If a node is contained directly inside another node, the inner node is the child of the outer node, and the outer node is the parent of the inner node. If a node is contained inside another node, but not directly, the inner node is the descendant of the outer node, and the outer node is the ancestor of the inner node.</p>
                <p>Expressions can be executed. When executed, they may perform some kind of action; e.g. they can have side effects. Expressions may produce a value when executed.</p>
            </div>
            <div id="tree-node-layout">
                <h2>9.2. Tree node layout</h2>
                <p>The number, type, and order of a tree nodes children is determined by the tree node's layout.</p>
            </div>
            <div id="node-supertypes">
                <h2>9.3. Node supertypes</h2>
                <p>Where the layout for a tree node specifies that a child node is an expression, that child node can be any expression.</p>
            </div>
        </div>
        <div id="node-types">
            <h1>Chapter 10. Node types</h1>
            <p>This chapter describes the various types of nodes.</p>
            <div id="base-node-types">
                <h2>10.1. Base nodes</h2>
                <p>These node types do not contain child nodes, and are thus the only nodes that must encode information themselves (as opposed to containing child nodes which together provide information).</p>
                <ul>
                    <li>
                        <a href="#node.access">access</a>
                    </li>
                    <li>
                        <a href="#node.boolean">boolean</a>
                    </li>
                    <li>
                        <a href="#node.direction">direciton</a>
                    </li>
                    <li>
                        <a href="#node.identifier">identifier</a>
                    </li>
                    <li>
                        <a href="#node.identikey-category">identifier-category</a>
                    </li>
                    <li>
                        <a href="#node.integer">integer</a>
                    </li>
                    <li>
                        <a href="#node.rational">rational</a>
                    </li>
                    <li>
                        <a href="#node.string">string</a>
                    </li>
                </ul>
            </div>
            <div id="tree-node-layout-key">
                <h2>10.2. Tree node layout key</h2>
                <p>This section describes how the layout of a node type is represented in this specification.</p>
                <p>The layout for a node type is represented in this specification as a list of items. Each item represents a child node or multiple child nodes with the same meaning. Nodes represented by different items are considered to have different meaning.</p>
                <p>Each item in these lists first specifies how many child nodes with that meaning may appear, or it says nothing about the number, which means there must be one (and only one). The ways of representing these amounts is described below.</p>
                <dl>
                    <dt>?</dt>
                    <dd>0 or 1</dd>
                    <dt>*</dt>
                    <dd>0 or more</dd>
                    <dt>+</dt>
                    <dd>1 or more</dd>
                </dl>
                <p>Next comes the name of a node type or "expression". The child node represented by that list item must be of that type. The string "expression" means the node must be executable.</p>
                <p>Lastly comes a label for referring to the child nodes with that meaning. These labels carry no semantic information, and are only a means used to refer to specific nodes. The meaning of child nodes can certainly be represented by other means. However, people creating representations for Desal trees are encouraged to at least consider using these same labels when it makes sense to do so.</p>
            </div>
            <div id="non-executable">
                <h2>10.3. Non-executable</h2>
                <p>Nodes that cannot be executed. Most server only to group other nodes together.</p>
                <div id="node.argument">
                    <h3>10.3.1. argument</h3>
                    <ul class="layout">
                        <li>? 
                        <a href="#node.identifier">identifier</a>parameter name</li>
                        <li>? expression value</li>
                    </ul>
                    <code xml:space="preserve">func doSomething(Int a = 1, Int b = 2, Int c = 3, Int d) {...} doSomething(7, default, default, 8) doSomething(7, c = default, 8)</code>
                </div>
                <div id="node.boolean">
                    <h3>10.3.2. boolean</h3>
                    <p>Base node. Must specify either true or false.</p>
                    <p>Cannot be evaluated because that would conflict with the prevalent "true" and "false" identifiers. Use "true" and "false" identifiers for expressions instead.</p>
                </div>
                <div id="node.bundle">
                    <h3>10.3.3. bundle</h3>
                    <p>A grouping of library references (import) and groups of declarations (plane).</p>
                    <ul class="layout">
                        <li>* 
                        <a href="#node.import">import</a></li>
                        <li>* 
                        <a href="#node.alias">alias</a></li>
                        <li>* 
                        <a href="#node.using">using</a></li>
                        <li>+ 
                        <a href="#node.plane">plane</a></li>
                    </ul>
                    <p>The bundle node type is the type of the root node. No node can contain an bundle node. All Desal nodes that are executed in any way must be part of a complete Desal tree, which means having an bundle node as the root node.</p>
                    <p class="xxx">Program arguments are no longer passed to the main function, because developers should have a choice of accessing program arguments in different ways, and some implementations may not have program arguments, or have non-string program arguments, etc. The old way just isn't flexible enough. Implementations should give program arguments through some API instead of passing them to the main function.</p>
                    <ol class="exec">
                        <li>1. Create the identikeys specified in section XXX to this node's scope.</li>
                        <li>2. Create any implementation-specific identikeys.</li>
                        <li>3. Execute each child identifier-const node in order.</li>
                    </ol>
                    <p>When the complete Desal tree is treated as a standalone program, section xxx applies. Otherwise, besides layout and setup, the abilities and behavior of the bundle node is implementation-specific, and execution or evaluation of Desal nodes may occur directly, without going through the bundle node.</p>
                    <p>The section XXX mentioned above should specify a value bound to "main" with a callee that takes no arguments and either returns nothing or returns an Int.</p>
                    <p class="xxx">Need a means of hiding/showing certain child namespaces of the global namespace. For example, a bundle acting as a library may have declarations in the global namespace and in a "private" namespace. The bundle should expose the declarations in the global namespace but hide the declarations in the private namespace.</p>
                </div>
                <div id="node.direction">
                    <h3>10.3.4. direction</h3>
                    <p>Specifies the direction of a function parameter, one of: in, in-mutable, out, in-out, in-mutable-out</p>
                    <p>A value passed to a function as an "in" parameter will not be mutated by the function. This means if the function uses the value in ways that may mutate the value, the value will be copied. If an action in the function may mutate the value, and the value does not declare a copy converter, an error results.</p>
                    <p>Instances where the value may be mutated include when the interface of the value does not provide opacity information and the function calls a method, or if the interface does provide opacity information but the function calls a mutator method, or if the value is passed to another function as an in-mutable or in-mutable-out parameter.</p>
                    <code xml:space="preserve">func alpha(in Int num) { println num } func beta(in-mutable Int num) { num += 567 } func gamma(out Int num) { //num not currently assigned to anything num = 987 } func delta(in-out Int num) { println num num = 1001 } func epsilon(in-mutable-out Int num) { num += 55555 num = 19591 } Int num = 123 alpha(num) beta(num) //value mutated gamma(num) //num assigned to different value delta(num) //num assigned to different value epsilon(num) //value mutated and num assigned to different value</code>
                </div>
                <div id="node.generic-parameter">
                    <h3>10.3.5. generic-parameter</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.identifier">identifier</a>name</li>
                        <li>? expression default interface</li>
                    </ul>
                </div>
                <div id="node.identikey-category">
                    <h3>10.3.6. identikey-category</h3>
                    <p>specifies one of: namespace, dynamic, automatic, strict, function</p>
                    <p>See the 
                    <a href="#identikeys">section on identikeys</a>.</p>
                </div>
                <div id="node.identikey-type">
                    <h3>10.3.7. identikey-type</h3>
                    <ul class="layout">
                        <li>
                            <a href="#node.identikey-category">identikey-category</a>
                        </li>
                        <li>? expression interface</li>
                        <li>
                        <a href="#node.boolean">boolean</a>nullable</li>
                        <li>
                        <a href="#node.boolean">boolean</a>constant</li>
                    </ul>
                    <p class="process">[constant] must not be specified if identikey-category is namespace. [constant] must be false (or not specified) if category is dynamic. The interface must be given if the category is strict. The interface must not be given if the category is namespace, dynamic, or automatic.</p>
                    <p>If the category is strict, the active interface of any value bound to the identikey must be that interface. If the category is function, and the interface is given, functions bound to the identikey must specify that interface as the return type.</p>
                    <p>The default value of [constant] is false. If [constant] is true, the identifier thereafter always refers to the same value. The identifier cannot be bound to a different value, or unbound. The active interface also cannot be changed.</p>
                    <code xml:space="preserve">Int a = 3 func Int a = func()Int { return 3 }</code>
                </div>
                <div id="node.import">
                    <h3>10.3.8. import</h3>
                    <p>Binds a library namespace to a namespace identikey.</p>
                    <ul class="layout">
                        <li>
                        <a href="#node.string">string</a>library</li>
                        <li>
                        <a href="#node.identifier">identifier</a>alias</li>
                    </ul>
                    <code xml:space="preserve">import "XmlLib" as Xml /* library: "XmlLib" alias: Xml */</code>
                </div>
                <div id="node.parameter">
                    <h3>10.3.9. parameter</h3>
                    <p>A function parameter.</p>
                    <ul class="layout">
                        <li>
                            <a href="#node.direction">direction</a>
                        </li>
                        <li>? 
                        <a href="#node.boolean">boolean</a>nullable</li>
                        <li>? expression interface</li>
                        <li>
                        <a href="#node.identifier">identifier</a>name</li>
                        <li>? expression default value</li>
                    </ul>
                    <p class="process">[nullable] must not be specified if direction is "out".</p>
                </div>
                <div id="node.plane">
                    <h3>10.3.10. plane</h3>
                    <p>A group of declarations within a bundle.</p>
                    <ul class="layout">
                        <li>* 
                        <a href="#node.alias">alias</a></li>
                        <li>* 
                        <a href="#node.identifier">identifier</a>namespace</li>
                        <li>+ 
                        <a href="#node.declare-first">declare-first</a></li>
                    </ul>
                    <p>This node has scope, but only private identifiers are bound to it. Public and exported identifiers are bound to the scope of the bundle node.</p>
                    <p>Planes aren't expressions because their declare-first nodes might rely on declare-first nodes in other planes, so all the declare-first nodes in a single plane can't just be executed all together.</p>
                </div>
                <div id="node.return-info">
                    <h3>10.3.11. return-info</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.boolean">boolean</a>return</li>
                        <li>? expression interface</li>
                    </ul>
                    <p class="process">If [interface] is present, [return] must be true.</p>
                    <p>[return] tells whether the function returns a value. If [return] and [interface] are absent, the function does not return a value. If [return] is absent and [interface] is present, the function returns a value. If [return] is present, it's value determines whether the function returns a value (true) or doesn't (false).</p>
                </div>
                <div id="node.type">
                    <h3>10.3.12. type</h3>
                    <ul class="layout">
                        <li>? 
                        <a href="#node.interface">interface</a></li>
                        <li>
                        <a href="#node.boolean">boolean</a>nullable</li>
                    </ul>
                </div>
            </div>
            <div id="non-producing-expressions">
                <h2>10.4. Non-producing expressions</h2>
                <p>Nodes that can be executed, but never produce.</p>
                <div id="iteration">
                    <h3>10.4.1. Iteration</h3>
                    <div id="node.do-while">
                        <h4>10.4.1.1. do-while</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.block">block</a>action</li>
                            <li>expression test</li>
                        </ul>
                        <p>Has scope.</p>
                        <code xml:space="preserve">do { something() } while test()</code>
                    </div>
                    <div id="node.do-times">
                        <h4>10.4.1.2. do-times</h4>
                        <ul class="layout">
                            <li>expression times</li>
                            <li>
                            <a href="#node.block">block</a>action</li>
                            <li>? expression test</li>
                        </ul>
                        <p>Has scope.</p>
                        <code xml:space="preserve">do 8 times { something() } do 8 times { something() } while test()</code>
                    </div>
                    <div id="node.for-key">
                        <h4>10.4.1.3. for-key</h4>
                        <ul class="layout">
                            <li>expression container</li>
                            <li>? expression key interface</li>
                            <li>
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>
                            <a href="#node.block">block</a>action</li>
                        </ul>
                        <p>Has scope.</p>
                        <ol class="exec">
                            <li>1. Call getKeyIterator on [container].</li>
                            <li>2. Call getNext on [1]. If an exception is thrown with an active interface of GeneratorDone, swallow it and end execution. If anything else is thrown, follow normal exception rules.</li>
                            <li>3. Create a scope.</li>
                            <li>4. Assign [2] to [identifier] in [3].</li>
                            <li>5. Execute [block] with scope [3].</li>
                            <li>6. Go to step 2.</li>
                        </ol>
                        <code xml:space="preserve">for key x in foo doStuff(x) for key Int x in foo doStuff(x)</code>
                    </div>
                    <div id="node.for-pair">
                        <h4>10.4.1.4. for-pair</h4>
                        <ul class="layout">
                            <li>expression container</li>
                            <li>? expression key interface</li>
                            <li>
                            <a href="#node.identifier">identifier</a>key name</li>
                            <li>? expression value interface</li>
                            <li>
                            <a href="#node.identifier">identifier</a>value name</li>
                            <li>
                            <a href="#node.block">block</a>action</li>
                        </ul>
                        <p>Has scope.</p>
                        <code xml:space="preserve">for pair x y in coords drawPoint(x, y) for pair Int x, Int y in coords drawPoint(x, y)</code>
                    </div>
                    <div id="node.for-manual">
                        <h4>10.4.1.5. for-manual</h4>
                        <p>Used for manual iteration, as opposed to letting the Desal implementation deal with iteration, like with a for-value node.</p>
                        <ul class="layout">
                            <li>* expression initializers</li>
                            <li>? expression test</li>
                            <li>* expression post actions</li>
                            <li>? 
                            <a href="#node.block">block</a>action</li>
                        </ul>
                        <p>Has scope.</p>
                        <p>The initializers are executed before iteration begins. Test is evaluated before each iteration. Post actions are executed after each iteration.</p>
                        <pre>
initializers

test
action
post actions

test
action
post actions

...

test
action
post actions

test

(end of loop)
</pre>
                        <code xml:space="preserve">for( Int i = 0 ; i &lt; container.length ; i++ ) { println container[i] } for( Iterator&lt;Int&gt; iterator = container.getIterator() ; iterator.hasMore? ; iterator.moveNext() ) { println iterator.current }</code>
                    </div>
                    <div id="node.for-range">
                        <h4>10.4.1.6. for-range</h4>
                        <ul class="layout">
                            <li>? 
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>expression start</li>
                            <li>expression limit</li>
                            <li>
                            <a href="#node.boolean">boolean</a>inclusive</li>
                            <li>? expression test</li>
                            <li>
                            <a href="#node.block">block</a>action</li>
                        </ul>
                        <p>Has scope.</p>
                        <p>[inclusive] determines whether the loop should iterate one last time if the iteration value is equal to the limit, and it is false by default.</p>
                        <code xml:space="preserve">for 0 to 100 println "test" for x from 0 to 100 println x for x from 0 to 100 inclusive println x for 0 to string.length while not container.full container.push( string.unshift!() ) for x from 0 to 100 while not foo.done? foo.runTest(x)</code>
                    </div>
                    <div id="node.for-value">
                        <h4>10.4.1.7. for-value</h4>
                        <ul class="layout">
                            <li>expression container</li>
                            <li>? expression value interface</li>
                            <li>
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>
                            <a href="#node.block">block</a>action</li>
                        </ul>
                        <p>Has scope.</p>
                        <code xml:space="preserve">for name in names println name for String name in names println name</code>
                    </div>
                    <div id="node.loop">
                        <h4>10.4.1.8. loop</h4>
                        <ul class="layout">
                            <li>
                                <a href="#node.block">block</a>
                            </li>
                        </ul>
                        <p>Executes block continuously. Can only be exited by expressions in the block such as break and return.</p>
                        <code xml:space="preserve">loop { Event event = getNextEvent() switch( event ) { case Events.QUIT : break } }</code>
                    </div>
                    <div id="node.while">
                        <h4>10.4.1.9. while</h4>
                        <ul class="layout">
                            <li>expression test</li>
                            <li>? 
                            <a href="#node.block">block</a></li>
                        </ul>
                        <p>Has scope.</p>
                        <code xml:space="preserve">while printNext() while container.hasMore? print container.next</code>
                    </div>
                </div>
                <div id="node.break">
                    <h3>10.4.2. break</h3>
                    <ul class="layout">
                        <li>? 
                        <a href="#node.identifier">identifier</a>label</li>
                    </ul>
                </div>
                <div id="node.continue">
                    <h3>10.4.3. continue</h3>
                    <ul>
                        <li>? identifier label</li>
                    </ul>
                </div>
                <div id="node.declare-empty">
                    <h3>10.4.4. declare-empty</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.identifier">identifier</a>name</li>
                        <li>
                            <a href="#node.identikey-type">identikey-type</a>
                        </li>
                    </ul>
                    <p class="process">The identikey-type must not be constant.</p>
                    <p>Creates an identikey in the parent scope with the specified type. After this node executes, the produced identikey does not yet point to any values.</p>
                    <code xml:space="preserve">decl func Int foo foo = func()Int { return 3 } foo = func(Int a)Int { return a * 2 } print foo() //prints 3 print foo(2) //prints 4 //xxx does this produce error or replace? foo = func()Int { return 5 }</code>
                    <code xml:space="preserve">decl func()Int foo foo = func()Int { return 3 } print foo() //prints 3 foo = func()Int { return 5 } print foo() //prints 5 foo = func(Int a)Int { return a * 2 } //error - interface mismatch</code>
                </div>
                <div id="node.declare-first">
                    <h3>10.4.5. declare-first</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.identifier">identifier</a>name</li>
                        <li>
                            <a href="#node.identikey-type">identikey-type</a>
                        </li>
                        <li>expression value</li>
                    </ul>
                    <p class="process">The identikey-type must be constant, and must have a category of automatic, strict, or function.</p>
                    <p>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</p>
                    <p>When a block contains declare-first nodes, the declare-first nodes are executed before the other expressions in the block are executed. The value expressions of declare-first nodes may depend on the values of other declare-first nodes in the same block. For example, two interfaces could reference each other.</p>
                    <p>This node can create identikeys before execution reaches it. For more information, see 
                    <a href="#handling-declare-first">this section</a>.</p>
                    <p class="exec">Produce the value bound to the identikey created by this node.</p>
                    <code xml:space="preserve">decl-first auto Foo = interface { get Bar bar } decl-first auto Bar = interface { get Foo foo } Foo foo = ... foo.bar.foo.bar...</code>
                </div>
                <div id="node.alias">
                    <h3>10.4.6. alias</h3>
                    <p>Creates an identikey that is associated with the same value/namespace as the specified identikey in the specified namespace.</p>
                    <ul class="layout">
                        <li>+ 
                        <a href="#node.identifier">identifier</a>target</li>
                        <li>
                        <a href="#node.identifier">identifier</a>name</li>
                    </ul>
                    <code xml:space="preserve">alias Xml.XmlDocument as Doc alias Xml.XmlElement as XmlElement import ".NET: System" as System alias System.Collections.Generic as box box.IList&lt;Foo&gt; = new box.List&lt;Foo&gt;();</code>
                    <code xml:space="preserve">alias FooBarBaz as FBZ alias System.out.print as puts puts( (FBZ to String)(Gamma) )</code>
                    <p>Each of the [target] identifiers, except for the last, must refer to a namespace. (The last can also refer to a namespace.)</p>
                </div>
                <div id="node.using">
                    <h3>10.4.7. using</h3>
                    <p>Imports all the child identikeys of the specified namespace into the enclosing scope.</p>
                    <ul class="layout">
                        <li>+ 
                        <a href="#node.identifier">identifier</a></li>
                    </ul>
                    <code xml:space="preserve">decl std.Array&lt;Int&gt; numbers using std decl Array&lt;Int&gt; numbers</code>
                </div>
                <div id="node.return">
                    <h3>10.4.8. return</h3>
                    <ul class="layout">
                        <li>? expression</li>
                    </ul>
                    <p>Function call ends and evaluates to expression.</p>
                </div>
                <div id="node.throw">
                    <h3>10.4.9. throw</h3>
                    <ul class="layout">
                        <li>expression</li>
                    </ul>
                    <p>If the expression isn't an Exception, wrap it with NonExceptionThrownError.</p>
                </div>
                <div id="node.labeled">
                    <h3>10.4.10. labeled</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.identifier">identifier</a>label</li>
                        <li>expression child</li>
                    </ul>
                    <p class="process">The [child] node must be an iteration node, a block node, a possibility node, a conditional node, or a select node. (XXX update and explain requirements instead of just listing nodes that meet requirements)</p>
                    <code xml:space="preserve">$func setupCell(Int searchID) { $decl Cell wantedCell outer: $for row $in table { $for cell $in row { $if cell.ID == searchID { wantedCell = cell $break outer } } } $if wantedCell != null { doSomething(wantedCell) } }</code>
                </div>
                <div id="node.yield">
                    <h3>10.4.11. yield</h3>
                    <p>Within a generator, specifies the next value for the generator to yield.</p>
                    <ul class="layout">
                        <li>expression</li>
                    </ul>
                    <p class="process">Must be a descendant of a generator node, and not inside a function or class node. (XXX spec out the kind of barriers function and class nodes create)</p>
                </div>
            </div>
            <div id="sometimes-producing-expressions">
                <h2>10.5. Sometimes producing expressions</h2>
                <p>Nodes that can be executed, and sometimes produce.</p>
                <div id="node.assign">
                    <h3>10.5.1. assign</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.identifier">identifier</a>name</li>
                        <li>expression value</li>
                    </ul>
                    <p>Assigns the value to the identikey. If the identikey's type is not function, the identikey will be unbound first if it is already bound to something. The identikey's type must be dynamic, automatic, strict, or function. If the identikey's type is automatic, strict, or function, identifier must be variable.</p>
                </div>
                <div id="node.declare-assign">
                    <h3>10.5.2. declare-assign</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.identifier">identifier</a>name</li>
                        <li>
                            <a href="#node.identikey-type">identikey-type</a>
                        </li>
                        <li>expression value</li>
                    </ul>
                    <p class="process">The identikey-category of the identikey-type node must be dynamic, automatic, strict, or function.</p>
                    <p>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</p>
                </div>
                <div id="node.unassign">
                    <h3>10.5.3. unassign</h3>
                    <ul class="layout">
                        <li>expression</li>
                    </ul>
                    <p>Unassigns the values bound to the given reference. If the identikey is a function identikey, all bound functions are unbound.</p>
                    <p class="xxx">Is this needed? Why not just assign null?</p>
                </div>
                <div id="node.block">
                    <h3>10.5.4. block</h3>
                    <p class="xxx">Come up with better name.</p>
                    <ul class="layout">
                        <li>* expression</li>
                    </ul>
                    <p>Has scope.</p>
                    <ol class="exec">
                        <li>Execute each expression in order. Produce the result of the last expression. (Produce nothing if the block contained no expressions or the last expression didn't produce.)</li>
                    </ol>
                    <p>Note: This node type is different from the Dextr concept of blocks. To differentiate between the two, nodes of this type can be called "block nodes", and the syntactic construct of Dextr can be called "Dextr blocks" or "syntactic blocks".</p>
                </div>
                <div id="node.possibility">
                    <h3>10.5.5. possibility</h3>
                    <ul class="layout">
                        <li>expression test</li>
                        <li>expression result</li>
                    </ul>
                    <p>Has scope.</p>
                    <p class="process">An error results if the implementation knows [test] will never evaluate to a value that can be downcast to Bool.</p>
                    <ol class="exec">
                        <li>Evaluate [test].</li>
                        <li>Downcast [1] to Bool.</li>
                        <li>If [2] is true, evaluate [result].</li>
                        <li>Evaluate this node to [3].</li>
                    </ol>
                    <code xml:space="preserve">if not foo.isSetup? { foo.setup() }</code>
                </div>
                <div id="node.conditional">
                    <h3>10.5.6. conditional</h3>
                    <ul class="layout">
                        <li>+ 
                        <a href="#node.possibility">possibility</a></li>
                        <li>? expression else</li>
                    </ul>
                    <p class="exec">Execute the [test] of the first [possibilty]. Downcast the resultant value to a Bool. If it is true, execute the [result] of that [possibilty] and produce the result. Otherwise, move on to the next node. If no [test] produces true, and [else] is given, execute [else] and produce its result.</p>
                    <code xml:space="preserve">$decl Int a = (x ? 0 : 1) $if foo == 1 doStuff1() $elif foo == 2 doStuff2() $else doDefault() $decl bar = (foo == 1) ? getOne() : (foo == 2) ? getTwo() : getDefault() $decl bar = $if foo == 1 : $eval getOne() $elif foo == 2 : $eval getTwo() $else : $eval getDefault()</code>
                </div>
                <div id="node.select">
                    <h3>10.5.7. select</h3>
                    <ul class="layout">
                        <li>expression value</li>
                        <li>* 
                        <a href="#node.case">case</a></li>
                        <li>? expression else</li>
                    </ul>
                    <p class="exec">Execute [value]. Execute each [values] child of each [case] and compare them to the [value] value (with the .equals? method of the [value] value) until finding a match. Then, execute the [result] of that case and produce the result. If no match is found, and [else] is given, execute [else] and produce its result.</p>
                    <div id="node.case">
                        <h4>10.5.7.1. case</h4>
                        <ul class="layout">
                            <li>+ expression values</li>
                            <li>expression result</li>
                        </ul>
                    </div>
                    <code xml:space="preserve">$select event.type $case Events.QUIT { $return } $case Events.FOO, Events.BAR, Events.MAZ { //no action } $else { $throw ErrorClass("unknown event type") } $select foo $case 1 doStuff1() $case 2 doStuff2() $else doDefault() $decl bar = $select foo $case 1 : $eval getOne() $case 2 : $eval getTwo() $else $eval getDefault()</code>
                </div>
                <div id="node.try-catch">
                    <h3>10.5.8. try-catch</h3>
                    <ul class="layout">
                        <li>expression try</li>
                        <li>* 
                        <a href="#node.exception-handler">exception-handler</a></li>
                        <li>? expression else</li>
                        <li>? expression finally</li>
                    </ul>
                    <p class="xxx">The term "else" is not descriptive enough in this situation. Possible replacements: "onsuccess", "then"</p>
                    <p class="process">Must contain more than just [try].</p>
                    <div id="node.exception-handler">
                        <h4>10.5.8.1. exception-handler</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.boolean">boolean</a>catch</li>
                            <li>expression interface</li>
                            <li>? 
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>expression result</li>
                        </ul>
                    </div>
                    <code xml:space="preserve">$try { $decl foo = getSomething() } $observe( OutOfMemoryError ) { println "I'm not catching that!" //exception is noticed by this try-catch node, but not caught //the exception continues to rise out } $catch( NullError ) { println "null error" } $catch( FooError e ) { println "FooError: $(e.message)" } $catch( Error ) { println "unknown error" } $catch( Exception ) { println "unknown exception" } $observe { println "how execution reach here? am not good with computer" } $else { println "no errors!" doSomeStuff() //don't catch errors from this in this node } $finally { cleanup(foo) } $decl Status stat = $try { doSomething() Statuses.SUCCESS } $catch( NotSoBadError ) { Statuses.ERROR } $observe { println "something bad when trying to doSomething()" }</code>
                </div>
                <div id="node.call">
                    <h3>10.5.9. call</h3>
                    <ul class="layout">
                        <li>expression value</li>
                        <li>? 
                        <a href="#node.identifier">identifier</a>method name</li>
                        <li>* 
                        <a href="#node.argument">argument</a></li>
                    </ul>
                    <p>If [method name] is not given:</p>
                    <ol class="exec">
                        <li>Execute [value].</li>
                        <li>If the resultant value is not callable, throw an error.</li>
                        <li>Execute the argument expressions in order.</li>
                        <li>Send argument values to the [value] value for execution.</li>
                        <li>Produce the returned value.</li>
                    </ol>
                    <p>If [method name] is given:</p>
                    <ol class="exec">
                        <li>Execute [value].</li>
                        <li>If the resultant value is not callable, throw an error.</li>
                        <li>Execute the argument expressions in order.</li>
                        <li>Send argument values to the method with name [method name] of the [value] value for execution.</li>
                        <li>Produce the returned value.</li>
                    </ol>
                </div>
                <div id="node.curry">
                    <h3>10.5.10. curry</h3>
                    <p>Provides a built-in means of partial application. (Note that Desal provides no built-in support for the original type of currying, where a multi-argument function is converted into a chain of single-argument functions.)</p>
                    <ul class="layout">
                        <li>expression value</li>
                        <li>? 
                        <a href="#node.identifier">identifier</a>method name</li>
                        <li>* 
                        <a href="#node.argument">argument</a></li>
                        <li>
                        <a href="#node.boolean">boolean</a>call</li>
                    </ul>
                    <p>If [call] is true, and this node results in the function receiving enough arguments to be called, the function will be called.</p>
                    <code xml:space="preserve">func foo(Int a, Rat b, String c, Bool d) Int { ... } //partial application func(String,Bool)Int foo2 = foo(1, 2.34) print foo2("text", true) //other type of currying func(Int)( func(Rat)( func(String)( func(Bool)Int ))) foo3 = curry(foo) print foo3(1)(2.34)("text")(true) //The above two are equivalent to: print foo(1, 2.34, "text", true)</code>
                    <p>Assuming the function is not called: If the arguments match only one of the callees/methods of [value], this node produces a value with a function interface as the active interface. If the arguments match more than one of the callees/methods on [value], this node produces a value with an active interface that is made by adding the function interfaces of the callees/methods together.</p>
                    <p>After execution, the specified parameters have values, so they do not appear on the resultant function.</p>
                    <p>Once the function has all its arguments supplied, it is called if [call] is true, and the result of that call is produced.</p>
                    <code xml:space="preserve">func doStuff1(Int a, String b, Bool alpha) {...} func doStuff1(Int a, Rat b, Bool alpha) {...} func doStuff2 = doStuff1~(3, alpha=false) doStuff2("test") doStuff2(123.456)</code>
                    <p>The middle line perhaps might also be represented this way:</p>
                    <code xml:space="preserve">(declare-first (identifier.name "doStuff2") (curry (identifier.value "doStuff1") (argument (integer.value 3)) (argument (identifier.name "alpha") (identifier.value "false"))))</code>
                    <code xml:space="preserve">interface Alpha func bar(Int a, Rat b, String c) Alpha alpha = AlphaClass() alpha.bar(0, 0.0, "0") func()void bar1 = alpha:bar() bar(1, 2.3, "4") func()void bar2 = alpha:bar(c="text") bar2(7, 9.8) func()void bar3 = alpha:bar(-9, 0.001, "stuff") bar3()</code>
                    <p>Creates a function that, when passed the type specified by [interface], calls the method named [method name] with the rest of the arguments sent to it. It's purpose is to help with functional programming.</p>
                    <code xml:space="preserve">interface Foo { func doStuff(Int, Int) Rat } Foo foo = getFoo() func(Foo,Int,Int)Rat doStuffer = Foo::doStuff println doStuffer(foo,3,7) dyn doStuffer2 = dyn::doStuff println doStuffer2(foo,3,7) //all equilavent println Foo::doStuff(foo,3,7) println dyn::doStuff(foo,3,7) println foo.doStuff(3,7)</code>
                </div>
                <div id="node.ignore">
                    <h3>10.5.11. ignore</h3>
                    <p>Instructs an agent to not output certain warnings.</p>
                    <ul class="layout">
                        <li>expression content</li>
                        <li>+ 
                        <a href="#node.ignore-member">ignore-member</a></li>
                    </ul>
                    <div id="node.ignore-member">
                        <h4>10.5.11.1. ignore-member</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.string">string</a>name</li>
                            <li>
                            <a href="#node.integer">integer</a>depth</li>
                        </ul>
                        <p>The [name] can be a warning name from the 
                        <a href="#warnings-list">specified warnings</a>or an agent-defined warning name. Unknown warning names should by default produce a warning that the warning name is unknown. Agents should provide an option to disable warnings for unknown warning names.</p>
                        <p>The [depth] specifies what descendant nodes are affected by the ignore node. Counting begins at one with the [content] node of the ignore node and increments by one for each further descendant.</p>
                        <code xml:space="preserve">(ignore (ignore-member (string.name "always null") (integer.depth ...)) (call.content (function.identifier println) (assignment.argument (identifier.name foo) (for-value.value ...))))</code>
                        <p>Here, if the [depth] was 1, a warning should be output by the agent for the assignment node that the [value] node will never produce a value when executed (a.k.a. always evaluate to null).</p>
                    </div>
                </div>
            </div>
            <div id="always-producing-expresions">
                <h2>10.6. Always producing expressions</h2>
                <p>Expressions that, aside from e.g. exceptions, always produce when executed. These nodes, other than the and, nand, or, and nor nodes, are not intended to have side effects.</p>
                <div id="boolean-logic">
                    <h3>10.6.1. Boolean logic</h3>
                    <div id="node.and">
                        <h4>10.6.1.1. and</h4>
                        <p>Evaluates to false if either child expression evaluates to false.</p>
                        <ul class="layout">
                            <li>expression first</li>
                            <li>expression second</li>
                        </ul>
                        <ol class="exec">
                            <li>Evaluate the first [expression] node.</li>
                            <li>Downcast [1] to Bool.</li>
                            <li>If [2] is false, evaluate this node to false.</li>
                            <li>Evaluate the second [expression] node.</li>
                            <li>Downcast [4] to Bool.</li>
                            <li>Evaluate this node to [5].</li>
                        </ol>
                    </div>
                    <div id="node.nand">
                        <h4>10.6.1.2. nand</h4>
                        <p>Evaluates to true if either child expression evaluates to false.</p>
                        <ul class="layout">
                            <li>expression first</li>
                            <li>expression second</li>
                        </ul>
                        <ol class="exec">
                            <li>Evaluate the first [expression] node.</li>
                            <li>Downcast [1] to Bool.</li>
                            <li>If [2] is false, evaluate this node to true.</li>
                            <li>Evaluate the second [expression] node.</li>
                            <li>Downcast [4] to Bool.</li>
                            <li>Evaluate this node to the inverse of [5].</li>
                        </ol>
                    </div>
                    <div id="node.or">
                        <h4>10.6.1.3. or</h4>
                        <p>Evaluates to true if either child expression evaluates to true.</p>
                        <ul class="layout">
                            <li>expression first</li>
                            <li>expression second</li>
                        </ul>
                        <ol class="exec">
                            <li>Evaluate the first [expression] node.</li>
                            <li>Downcast [1] to Bool.</li>
                            <li>If [2] is true, evaluate this node to true.</li>
                            <li>Evaluate the second [expression] node.</li>
                            <li>Downcast [4] to Bool.</li>
                            <li>Evaluate this node to [5].</li>
                        </ol>
                    </div>
                    <div id="node.nor">
                        <h4>10.6.1.4. nor</h4>
                        <p>Evaluates to false if either child expression evaluates to true.</p>
                        <ul class="layout">
                            <li>expression first</li>
                            <li>expression second</li>
                        </ul>
                        <ol class="exec">
                            <li>Evaluate the first [expression] node.</li>
                            <li>Downcast [1] to Bool.</li>
                            <li>If [2] is true, evaluate this node to false.</li>
                            <li>Evaluate the second [expression] node.</li>
                            <li>Downcast [4] to Bool.</li>
                            <li>Evaluate this node to the inverse of [5].</li>
                        </ol>
                    </div>
                    <div id="node.xor">
                        <h4>10.6.1.5. xor</h4>
                        <p>Evaluates to true if the child expressions evaluate to different values.</p>
                        <ul class="layout">
                            <li>expression first</li>
                            <li>expression second</li>
                        </ul>
                        <ol class="exec">
                            <li>Evaluate the first [expression] node.</li>
                            <li>Downcast [1] to Bool.</li>
                            <li>Evaluate the second [expression] node.</li>
                            <li>Downcast [3] to Bool.</li>
                            <li>If [2] and [4] are different, evaluate to true. Otherwise, evaluate to false.</li>
                        </ol>
                    </div>
                    <div id="node.xnor">
                        <h4>10.6.1.6. xnor</h4>
                        <p>Evaluates to true if the child expressions evaluate to the same value.</p>
                        <ul class="layout">
                            <li>expression first</li>
                            <li>expression second</li>
                        </ul>
                        <ol class="exec">
                            <li>Evaluate the first [expression] node.</li>
                            <li>Downcast [1] to Bool.</li>
                            <li>Evaluate the second [expression] node.</li>
                            <li>Downcast [3] to Bool.</li>
                            <li>If [2] and [4] are the same, evaluate to true. Otherwise, evaluate to false.</li>
                        </ol>
                    </div>
                </div>
                <div id="node.array">
                    <h3>10.6.2. array</h3>
                    <ul class="layout">
                        <li>
                            <a href="#node.type">type</a>
                        </li>
                        <li>* expression element</li>
                    </ul>
                    <p>Evaluates to an object with interface array as the active interface. The object may implement other interfaces if they do not conflict with the array interface.</p>
                    <p>Each [element] is cast to [interface]. If a cast error results, it raises out of the array node, so that the array node doesn't evaluate to anything.</p>
                </div>
                <div id="node.cast">
                    <h3>10.6.3. cast</h3>
                    <ul class="layout">
                        <li>expression [object]</li>
                        <li>expression [interface]</li>
                    </ul>
                    <p>Evaluates to an object reference where the active interface is [interface] and the object is [object]. If [object] does not implement [interface], an error results.</p>
                    <code xml:space="preserve">Int o = getIntAndString() print (o as String).length</code>
                </div>
                <div id="node.chain">
                    <h3>10.6.4. chain</h3>
                    <p>Creates a doubly-linked list from the provided elements.</p>
                    <ul class="layout">
                        <li>
                            <a href="#node.type">type</a>
                        </li>
                        <li>* expression element</li>
                    </ul>
                    <p>Evaluates to a list, as if calling CList&lt; [interface] &gt; ( [element], [element], ... )</p>
                    <p>Each [element] is cast to [interface]. If a cast error results, it raises out of the list node, so that the list node doesn't evaluate to anything.</p>
                </div>
                <div id="node.class">
                    <h3>10.6.5. class</h3>
                    <p>Evaluates to a value that, when called, produces other values. The interfaces supported by the produced values are implemented in the way specified by this class node. The active interface of the produced value is specified by this class.</p>
                    <p>The active interface of the value that is produced when a class node is executed inherits from the master interface of the class. The master interface is the sum of all the root interfaces implemented by the class.</p>
                    <p class="xxx">XML comments with important information</p>
                    <ul class="layout">
                        <li>* 
                        <a href="#node.declare-class">declare-class</a>static declarations</li>
                        <li>? 
                        <a href="#node.block">block</a>static constructor</li>
                        <li>* 
                        <a href="#node.function">function</a>static callees</li>
                        <li>* 
                        <a href="#node.class-property">class-property</a>static properties</li>
                        <li>* 
                        <a href="#node.function">function</a>instance constructors</li>
                        <li>* 
                        <a href="#node.declaration">declaration</a>instance declarations</li>
                        <li>* 
                        <a href="#node.interface-implementation">interface-implementation</a></li>
                    </ul>
                    <p>XXX The static callees and static properties may not always be visible in the class node's scope. (An example of being visible is assigning the value produced by the class node to an identifier.) Should some identifier (e.g. "thisClass") be introduced that evaluates to the class's value? (e.g. thisClass.property = foo) Or should a general means of accessing the enclosing expression node's value be introduced? (e.g. thisValue.property = foo)</p>
                    <p>The above is not a problem for interface implementations due to the "this" identikey being bound to the active instance.</p>
                    <p>The children of class nodes can be grouped by several means.</p>
                    <p>By count:</p>
                    <table>
                        <tbody>
                            <tr>
                                <th />
                                <th>public</th>
                                <th>private</th>
                            </tr>
                            <tr>
                                <th>static - only 1</th>
                                <td>callees, getters/setters, methods, interface-implementations</td>
                                <td>static constructor, instance constructors, static declarations, instance methods</td>
                            </tr>
                            <tr>
                                <th>instance - 1 per instance</th>
                                <td />
                                <td>instance declarations</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>By scopes: (in scope means something can be accessed through a single identifier as a free identikey)</p>
                    <ul>
                        <li>static scope 
                        <ul>
                            <li>public 
                            <ul>
                                <li>defined by: static declarations (as properties and methods; must have access with get and/or set), static properties, instance constructors (as callees)</li>
                                <li>in scope: (none)</li>
                            </ul></li>
                            <li>private 
                            <ul>
                                <li>defined by: static declarations, instance constructors (as functions bound to "construct")</li>
                                <li>in scope: static constructor, callees, getters/setters, methods, expressions in static declarations</li>
                            </ul></li>
                        </ul></li>
                        <li>instance scope 
                        <ul>
                            <li>public 
                            <ul>
                                <li>defined by: interface-implementations (or really, by the interface)</li>
                                <li>in scope: (none)</li>
                            </ul></li>
                            <li>private 
                            <ul>
                                <li>defined by: instance declarations, instance methods</li>
                                <li>in scope: expressions in instance declarations, instance methods, interface implementations, instance constructors</li>
                            </ul></li>
                        </ul></li>
                    </ul>
                    <p>Note: Instance scopes are children of the static scope.</p>
                    <p class="process">Must have at least one interface-implementation. Including the interface-implementation nodes that are inherited by this class's child interface-implementation nodes, one and only one of the interface-implementation nodes must be specified as default.</p>
                    <ol class="exec">
                        <li>Create scope, STATIC_SCOPE.</li>
                        <li>Create an interface, CLASS_INTERFACE.</li>
                        <li>Add instance constructors as free functions to STATIC_SCOPE.</li>
                        <li>Add instance constructors as callees to CLASS_INTERFACE.</li>
                        <li>Evaluate every 
                        <a href="#node.declare-class">declare-class</a>that has a 
                        <a href="#node.declare-first">declare-first</a>in the scope of STATIC_SCOPE. If the identikey-type of the 
                        <a href="#node.declare-first">declare-first</a>is function, and it has access of get, add a method to CLASS_INTERFACE with the same function interface and name. Otherwise, create a property with a getter if declared public.</li>
                        <li>Evaluate the rest of the declare-class nodes in the scope of STATIC_SCOPE, except for the declare-class nodes with a declare-const-empty. Create properties as appropriate when the access nodes specify to do so.</li>
                        <li>In the scope of STATIC_SCOPE, evaluate the declare-class nodes that have declare-const-empty nodes. Create properties as appropriate when the access nodes specify to do so.</li>
                        <li>Add the static callees as free functions in STATIC_SCOPE.</li>
                        <li>Add the static callees and the static properties to CLASS_INTERFACE.</li>
                        <li>Execute the static constructor.</li>
                        <li>Seal the identikeys created by the declare-const-empty nodes, meaning don't allow their bound status to change.</li>
                        <li>Create a value with CLASS_INTERFACE as the active interface.</li>
                        <li>Evaluate this node to the above value.</li>
                    </ol>
                    <p>When a constructor is called:</p>
                    <ol class="exec">
                        <li>Create a scope, INSTANCE_SCOPE. Set STATIC_SCOPE as the parent scope.</li>
                        <li>Evaluate all declare-first nodes in scope of INSTANCE_SCOPE.</li>
                        <li>Execute the appropriate constructor.</li>
                        <li>Evaluate the function-call that lead to this constructor being evaluated to a value with INSTANCE_SCOPE as the object and the default interface implementation of the class as the active interface implementation.</li>
                        <li>Note: When the interface implementation is used, the value will pass the object into the interface implementation.</li>
                    </ol>
                    <div id="node.declare-class">
                        <h4>10.6.5.1. declare-class</h4>
                        <ul class="layout">
                            <li>
                                <a href="#node.declaration">declaration</a>
                            </li>
                            <li>? 
                            <a href="#node.access">access</a></li>
                        </ul>
                        <p class="process">If the declaration declares a const identifier, and access is present, the access node must be declared get.</p>
                        <p class="xxx">poorly named</p>
                    </div>
                    <div id="node.declaration">
                        <h4>10.6.5.2. declaration</h4>
                        <p>declaration is a family of node types, like expression. The node types included in this family are:</p>
                        <ul class="family-members">
                            <li>
                                <a href="#node.declare-empty">declare-empty</a>
                            </li>
                            <li>
                                <a href="#node.declare-assign">declare-assign</a>
                            </li>
                            <li>
                                <a href="#node.declare-first">declare-first</a>
                            </li>
                            <li>
                                <a href="#node.declare-const-empty">declare-const-empty</a>
                            </li>
                        </ul>
                    </div>
                    <div id="node.declare-const-empty">
                        <h4>10.6.5.3. declare-const-empty</h4>
                        <ul class="layout">
                            <li>
                                <a href="#node.identifier">identifier</a>
                            </li>
                            <li>
                                <a href="#node.identikey-type">identikey-type</a>
                            </li>
                        </ul>
                        <p class="process">If identikey-type is function, the interface is the return type. (xxx why?)</p>
                        <p>Identifiers created by this node are always const. [identikey-type] must be value or function. The class's static constructor is allowed to assign values to static identifiers created by this node. If anthing tries to assign a value to an identikey create by this node, and the identikey is already bound to something, throw an error. The class's instance constructors are allowed to assign values to instance identifiers created by this node. An error results if identikeys produced by declare-const-empty nodes are dereferenced before being bound to anything.</p>
                    </div>
                    <div id="node.interface-implementation">
                        <h4>10.6.5.4. interface-implementation</h4>
                        <ul class="layout">
                            <li>* 
                            <a href="#node.interface-implementation">interface-implementation</a>children</li>
                            <li>expression interface</li>
                            <li>* 
                            <a href="#node.function">function</a>callee</li>
                            <li>* 
                            <a href="#node.named-function">named-function</a>getter</li>
                            <li>* 
                            <a href="#node.named-function">named-function</a>setter</li>
                            <li>* 
                            <a href="#node.named-function">named-function</a>method</li>
                            <li>
                            <a href="#node.boolean">boolean</a>default</li>
                        </ul>
                    </div>
                    <div id="node.named-function">
                        <h4>10.6.5.5. named-function</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>
                            <a href="#node.function">function</a>function</li>
                        </ul>
                    </div>
                    <div id="node.class-property">
                        <h4>10.6.5.6. class-property</h4>
                        <ul class="layout">
                            <li>
                                <a href="#node.identifier">identifier</a>
                            </li>
                            <li>
                                <a href="#node.identikey-type">identikey-type</a>
                            </li>
                            <li>? 
                            <a href="#node.function">function</a>getter</li>
                            <li>? 
                            <a href="#node.function">function</a>setter</li>
                        </ul>
                        <p class="process">Must have a getter and/or setter. If only identifier and identikey-type are given, an error results.</p>
                    </div>
                    <code xml:space="preserve">class Foo { ... construct() {...} impl Bar {...} } interface of Foo { inherit Bar call() Bar } (Foo as Interface) == Bar //true</code>
                    <code xml:space="preserve">class Foo { ... construct() {...} impl Bar default {...} impl define Bar2 {...} //the identifier "Bar2" is required } interface of Foo { inherit Bar + {{interface Bar2}} call() Bar get Interface Bar2 } (Foo as Interface) == (Bar + Foo.Bar2) //true</code>
                </div>
                <div id="node.comprehension">
                    <h3>10.6.6. comprehension</h3>
                    <p>Used to build collections or generators. A slightly more general form of array/list comprehensions as found in other programming languages. Similar in nature to set-builder notation in mathematics.</p>
                    <ul class="layout">
                        <li>
                            <a href="#node.comprehension-type">comprehension-type</a>
                        </li>
                        <li>? expression destination collection</li>
                        <li>expression source collection</li>
                        <li>
                        <a href="#node.identifier">identifier</a>element name</li>
                        <li>? expression test</li>
                        <li>? expression output</li>
                    </ul>
                    <p class="process">[comprehension-type] must be set to "provided" if [destination-collection] is present.</p>
                    <div id="node.comprehension-type">
                        <h4>10.6.6.1. comprehension-type</h4>
                        <p>Specifies one of: array, chain, generator, provided</p>
                    </div>
                    <code xml:space="preserve">$decl foo = [2*x for x in L if x^2 &gt; 3] container: L element name: x test: x^2 &gt; 3 output: 2*x $decl foo = [x in L if x^2 &gt; 3] container: L element name: x test: x^2 &gt; 3 output: (implicit: x) $decl foo = [x in L] container: L element name: x test: (implicit: true) output: (implicit: x) for o in [2*x for x in L if x^2 &gt; 3] { println o }</code>
                </div>
                <div id="node.copy">
                    <h3>10.6.7. copy</h3>
                    <p>Attempts to copy a given value.</p>
                    <ul class="layout">
                        <li>expression value</li>
                        <li>? expression interface</li>
                    </ul>
                    <ol class="exec">
                        <li>Evaluate the value expression.</li>
                        <li>Evaluate the interface expression or get the active interface of the value.</li>
                        <li>Find the converter to the specified interface (XXX how?) using the same method as finding a property or method.</li>
                        <li>Activate the converter.</li>
                        <li>Evaluate this node to the returned value.</li>
                    </ol>
                    <code xml:space="preserve">decl Int $num1 = 987 decl Int $num2 = copy($num) decl Int $num3 := $num</code>
                </div>
                <div id="node.convert">
                    <h3>10.6.8. convert</h3>
                    <p>Attempts to convert a given value to a different type.</p>
                    <ul class="layout">
                        <li>expression value</li>
                        <li>? expression interface</li>
                    </ul>
                    <ol class="exec">
                        <li>Evaluate the value expression.</li>
                        <li>Evaluate the interface expression or get the active interface of the value.</li>
                        <li>Find the converter to the specified interface (XXX how?) using the same method as finding a property or method.</li>
                        <li>Activate the converter.</li>
                        <li>Evaluate this node to the returned value.</li>
                    </ol>
                    <code xml:space="preserve">decl Int $num1 = 987 decl Rat $num2 = ($num to Rat) decl Rat $num3 := $num</code>
                    <p class="xxx">Should the ":=" operator shown in the examples for copy and convert have an associated node? Something like "assign-copy"/"assign-convert"/"assign-new" would be good.</p>
                </div>
                <div id="node.dictionary">
                    <h3>10.6.9. dictionary</h3>
                    <ul class="layout">
                        <li>? 
                        <a href="#node.type">type</a>key type</li>
                        <li>? 
                        <a href="#node.type">type</a>value type</li>
                        <li>* 
                        <a href="#node.dictionary-entry">dictionary-entry</a></li>
                    </ul>
                    <div id="node.dictionary-entry">
                        <h4>10.6.9.1. dictionary-entry</h4>
                        <ul class="layout">
                            <li>expression key</li>
                            <li>expression value</li>
                        </ul>
                    </div>
                </div>
                <div id="node.enum">
                    <h3>10.6.10. enum</h3>
                    <p>An enum is similar to an immutable dict.</p>
                    <ul class="layout">
                        <li>? 
                        <a href="#node.type">type</a></li>
                        <li>+ 
                        <a href="#node.enum-entry">enum-entry</a></li>
                    </ul>
                    <p class="process">If [type] is not given, no enum entries can have a value. If [type] is given, all enum entries must have a value. Note that every enum entry has have a unique value. (XXX include restriction in execution instructions)</p>
                    <div id="node.enum-entry">
                        <h4>10.6.10.1. enum-entry</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>? expression value</li>
                        </ul>
                    </div>
                    <p>If [type] is given:</p>
                    <ol class="exec">
                        <li>Let EntryFace be a new interface that inherits from EnumDictEntry&lt;T&gt; where T is specified by [type].</li>
                        <li>For every [enum-entry], create a value with EntryFace as the active interface, where the "value" and "name" properties are those specified by the [enum-entry].</li>
                        <li>Let ListFace be a new interface. For every [enum-entry], add a readonly property to ListFace with the type of EntryFace and a name specified by the [enum-entry].</li>
                        <li>Let EnumFace be a new interface that inherits from Interface, EnumDict&lt;T, U&gt;, and ListFace, where T is EntryFace and U is specified by [type].</li>
                        <li>Let EnumInstance be a value with EnumFace as the active interface such that: 
                        <ul>
                            <li>the value given from getting a property of ListFace is the value created in step 2 that is associated with the same [enum-entry] as the property</li>
                            <li>the Interface implementation is EntryFace, i.e. EnumInstance cast to Interface is EnumFace</li>
                        </ul></li>
                        <li>Produce EnumInstance.</li>
                    </ol>
                    <p>If [type] is not given:</p>
                    <ol class="exec">
                        <li>Let EntryFace be a new interface that inherits from EnumEntry.</li>
                        <li>For every [enum-entry], create a value with EntryFace as the active interface, where the "name" property is that specified by the [enum-entry].</li>
                        <li>Let ListFace be a new interface. For every [enum-entry], add a readonly property to ListFace with the type of EntryFace and a name specified by the [enum-entry].</li>
                        <li>Let EnumFace be a new interface that inherits from Interface, Enum&lt;T&gt;, and ListFace, where T is EntryFace.</li>
                        <li>Let EnumInstance be a value with EnumFace as the active interface such that: 
                        <ul>
                            <li>the value given from getting a property of ListFace is the value created in step 2 that is associated with the same [enum-entry] as the property</li>
                            <li>the Interface implementation is EntryFace, i.e. EnumInstance cast to Interface is EnumFace</li>
                        </ul></li>
                        <li>Produce EnumInstance.</li>
                    </ol>
                    <p>Note that the sections specifying Enum, EnumDict, EnumEntry, and EnumDictEntry have additional requirements on the behavior of instances of these interfaces.</p>
                    <pre>
enum Animal {
        dog, cat, fish, parrot, ferret, gerbil, hamster
}

interface EntryFace
        inherit EnumEntry

interface ListFace
        get EntryFace dog
        get EntryFace cat
        get EntryFace fish
        get EntryFace parrot
        get EntryFace ferret
        get EntryFace gerbil
        get EntryFace hamster

interface EnumFace
        inherit Interface
        inherit Enum&lt;EntryFace&gt;
        inherit EnumList

Animal a = Animal.dog
Animal b = Animal.fromName("cat")
println Animal.size //assuming size is specified by Collection&lt;T&gt;

for animal in Animal
        println animal.name

activeInterface(Animal) == Interface + Enum&lt;EntryFace&gt; + EnumList
(Animal as Interface) == EntryFace
</pre>
                </div>
                <div id="node.function">
                    <h3>10.6.11. function</h3>
                    <ul class="layout">
                        <li>* 
                        <a href="#node.parameter">parameter</a></li>
                        <li>
                            <a href="#node.return-info">return-info</a>
                        </li>
                        <li>expression body</li>
                    </ul>
                    <p>XXX specify barrier, which is like the kind of barrier that is in class nodes. Compare this kind of barrier to scope barriers -- nodes that "have scope". The [body] node is not executed when this node is executed, but it may be executed after this node has executed.</p>
                    <p>When this node is executed, it produces a value with a function interface as the active interface. Only the [parameter] node and [return-info]'s [interface] nodes are executed at this time. When the resultant value is called, the [body] node is executed in the scope of this function node.</p>
                </div>
                <div id="node.function-interface">
                    <h3>10.6.12. function-interface</h3>
                    <ul class="layout">
                        <li>? expression template-argument-count</li>
                        <li>* 
                        <a href="#node.parameter">parameter</a></li>
                        <li>
                            <a href="#node.return-info">return-info</a>
                        </li>
                    </ul>
                </div>
                <div id="node.generator">
                    <h3>10.6.13. generator</h3>
                    <p>Produces a value that implements an instantiation of the Generator generic interface.</p>
                    <ul class="layout">
                        <li>
                            <a href="#node.type">type</a>
                        </li>
                        <li>expression</li>
                    </ul>
                    <p>Has scope.</p>
                    <code xml:space="preserve">$decl foo = $generator { $decl Int i = 2 $while i &lt; 5 { $yield i i++ } } $for i $in foo { print foo print " " } prints: '2 3 4 ' interface of foo == Generator&lt;Int&gt;</code>
                    <code xml:space="preserve">$decl foo = $func(Int a, Int b) Generator&lt;Int&gt; { $return $generator { $decl Int i = a $while i &lt; b { $yield i i++ } } } $for i $in foo(2, 5) { print foo print " " } prints: '2 3 4 '</code>
                    <code xml:space="preserve">A representation could provide a construct like that in other languages by combining functions and generators. $decl foo = $generator(Int a, Int b) Int { $decl Int i = a $while i &lt; b { $yield i i++ } } $for i $in foo(2, 5) { print foo print " " } prints: '2 3 4 '</code>
                </div>
                <div id="node.generic-class">
                    <h3>10.6.14. generic-class</h3>
                    <ul class="layout">
                        <li>+ 
                        <a href="#node.generic-parameter">generic-parameter</a>parameters</li>
                        <li>
                            <a href="#node.class">class</a>
                        </li>
                    </ul>
                    <p>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the class node.</p>
                </div>
                <div id="node.generic-function">
                    <h3>10.6.15. generic-function</h3>
                    <ul class="layout">
                        <li>+ 
                        <a href="#node.generic-parameter">generic-parameter</a>parameters</li>
                        <li>
                            <a href="#node.function">function</a>
                        </li>
                    </ul>
                    <p>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the function node.</p>
                    <code xml:space="preserve">generic(T) func larger(T a, T b) T { if a &lt; b return b return a } println larger(2, 7) //prints "7"</code>
                </div>
                <div id="node.generic-interface">
                    <h3>10.6.16. generic-interface</h3>
                    <ul class="layout">
                        <li>+ 
                        <a href="#node.generic-parameter">generic-parameter</a>parameters</li>
                        <li>
                            <a href="#node.interface">interface</a>
                        </li>
                    </ul>
                    <p>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the interface node.</p>
                    <code xml:space="preserve">generic(T) interface List { func addFront(T) func addBack(T) func removeFront() T func removeBack() T } List(Int) list = ... list.addFront(2) list.addBack(3) list.addFront(1) println list.removeFront() //prints "1" println list.removeBack() //prints "3"</code>
                </div>
                <div id="node.get-property">
                    <h3>10.6.17. get-property</h3>
                    <ul class="layout">
                        <li>expression source</li>
                        <li>
                        <a href="#node.identifier">identifier</a>property name</li>
                    </ul>
                    <p>Retrieves the value of a property. If the active interface of the value does not have a property with the specified name, or the property cannot be retrieved, an error results.</p>
                </div>
                <div id="node.identifier">
                    <h3>10.6.18. identifier</h3>
                    <p>Base node. Identifiers can sometimes evaluate to object references. Object references point to an object and have an active interface. Only properties declared by the active interface can be accessed, even if the object implements other interfaces.</p>
                    <p>When evaluating an identifier to an object: If the identifier is undefined in the current scope, move to the containing scope. If there is no containing scope, throw an UndefinedIdentifier error. Continue moving to outer scopes until the identifier is found or there is no containing scope. If the identifier is bound to an object, the identifier evaluates to that object. If the identifier has been declared that it can be bound to objects, but it is currently not bound to anything, return null. If the identifier is bound to a function, the identifier evaluates to the wrapper for that function, as defined in function-wrapper xxx. If the identifier is bound to a namespace, a NamespaceIdentifier error results.</p>
                </div>
                <div id="node.instantiate-generic-class">
                    <h3>10.6.19. instantiate-generic-class</h3>
                    <ul class="layout">
                        <li>expression generic class</li>
                        <li>+ 
                        <a href="#node.argument">argument</a></li>
                    </ul>
                    <p>All the arugments must be interfaces. Pass interfaces in to get a function.</p>
                </div>
                <div id="node.intantiate-generic-function">
                    <h3>10.6.20. instantiate-generic-function</h3>
                    <ul class="layout">
                        <li>expression generic function</li>
                        <li>+ 
                        <a href="#node.argument">argument</a></li>
                    </ul>
                    <p>All the arguments must be interfaces. Pass interfaces in to get a function.</p>
                </div>
                <div id="node.instantiate-generic-interface">
                    <h3>10.6.21. instantiate-generic-interface</h3>
                    <ul class="layout">
                        <li>expression generic interface</li>
                        <li>+ 
                        <a href="#node.argument">argument</a></li>
                    </ul>
                    <p>All the arguments must be interfaces. Pass interfaces in to get a function.</p>
                </div>
                <div id="node.implements">
                    <h3>10.6.22. implements</h3>
                    <ul class="layout">
                        <li>expression value</li>
                        <li>expression interface</li>
                    </ul>
                    <p>Returns a bool object reference to the true or false objects. True if [object] implements [interface], false otherwise.</p>
                    <code xml:space="preserve">if (o impls Foo) (o as Foo).propOfFoo()</code>
                </div>
                <div id="node.integer">
                    <h3>10.6.23. integer</h3>
                    <p>Base node. Evaluates to an object reference with BigInt as the active interface. The object may implement other interfaces if they do not conflict with the BigInt interface. Must not implement the LimInt interface.</p>
                </div>
                <div id="node.interface">
                    <h3>10.6.24. interface</h3>
                    <ul class="layout">
                        <li>* expression inheritees</li>
                        <li>* 
                        <a href="#node.statused-member">statused-member</a></li>
                    </ul>
                    <div id="node.statused-member">
                        <h4>10.6.24.1. statused-member</h4>
                        <ul class="layout">
                            <li>
                                <a href="#node.member-status">member-status</a>
                            </li>
                            <li>
                                <a href="#node.interface-member">interface-member</a>
                            </li>
                        </ul>
                    </div>
                    <div id="node.member-status">
                        <h4>10.6.24.2. member-status</h4>
                        <p>Base node. Specifies "new", "normal", or "deprecated".</p>
                    </div>
                    <div id="node.interface-member">
                        <h4>10.6.24.3. interface-member</h4>
                        <p>Supertype. Includes convertor, callee, property, and method.</p>
                    </div>
                    <div id="node.convertor">
                        <h4>10.6.24.4. convertor</h4>
                        <ul class="layout">
                            <li>? expression interface</li>
                        </ul>
                        <p>Specifies that implementations of that interface can be converted into the specified type. Or, if [interface] isn't given, that the value can be copied.</p>
                    </div>
                    <div id="node.callee">
                        <h4>10.6.24.5. callee</h4>
                        <ul class="layout">
                            <li>* 
                            <a href="#node.parameter">parameter</a></li>
                            <li>
                                <a href="#node.return-info">return-info</a>
                            </li>
                        </ul>
                    </div>
                    <div id="node.property">
                        <h4>10.6.24.6. property</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>? expression interface</li>
                            <li>
                            <a href="#node.access">access</a>access</li>
                        </ul>
                    </div>
                    <div id="node.method">
                        <h4>10.6.24.7. method</h4>
                        <ul class="layout">
                            <li>
                            <a href="#node.identifier">identifier</a>name</li>
                            <li>expression interface</li>
                        </ul>
                    </div>
                    <div id="node.access">
                        <h4>10.6.24.8. access</h4>
                        <p>Access nodes must specify one of three access levels: only reading, only writing, or both reading and writing.</p>
                    </div>
                </div>
                <div id="node.namespaced-identikey">
                    <h3>10.6.25. namespaced-identikey</h3>
                    <ul class="layout">
                        <li>+ 
                        <a href="#node.identifier">identifier</a>namespaces</li>
                        <li>
                        <a href="#node.identifier">identifier</a>identikey name</li>
                    </ul>
                    <code xml:space="preserve">namespace::namespace::identikey namespace foo { namespace bar { Int alpha = ... } } Int alpha = foo::bar::alpha</code>
                </div>
                <div id="node.rational">
                    <h3>10.6.26. rational</h3>
                    <p>Base node. Evaluates to an object with BigRat as the active interface. The object may implement other interfaces if they do not conflict with the BigRat interface. Must not implement the LimRat interface.</p>
                </div>
                <div id="node.set-property">
                    <h3>10.6.27. set-property</h3>
                    <p class="xxx">Shouldn't this be merged with the assign node?</p>
                    <ul class="layout">
                        <li>expression source</li>
                        <li>
                        <a href="#node.identifier">identifier</a>property name</li>
                        <li>expression value</li>
                    </ul>
                    <p>Sets the value of a property. If the active interface of the value does not have a property with the specified name, or the property cannot be set, an error results. Evaluates to the value given by [value].</p>
                </div>
                <div id="node.string">
                    <h3>10.6.28. string</h3>
                    <p>string nodes consist of text</p>
                    <p>strings are expressions</p>
                    <p>Base node. Evaluates to an object with interface string as the active interface. The object may implement other interfaces if they do not conflict with the string interface.</p>
                </div>
            </div>
            <div id="unsorted-nodes">
                <h2>10.7. Unsorted nodes</h2>
                <div id="node.identifier-chain">
                    <h3>10.7.1. identifier-chain</h3>
                    <ul class="layout">
                        <li>
                        <a href="#node.boolean">boolean</a>namespaced-identikey</li>
                        <li>
                        <a href="#node.boolean">boolean</a>get-property</li>
                        <li>
                        <a href="#node.boolean">boolean</a>bind</li>
                        <li>? expression starting value</li>
                        <li>+ 
                        <a href="#node.identifier">identifier</a></li>
                    </ul>
                    <p>This node exists for Desal representations that use the same syntax for different associations between identifiers. The associations supported by this node are the same as those of the 
                    <a href="#node.namespaced-identikey">namespaced-identikey</a>, 
                    <a href="#node.get-property">get-property</a>, and 
                    <a href="#node.curry">curry</a>nodes. The optional boolean nodes are all true by default, meaning all associations are supported. If namespaced-identikey is true, the starting value must not be present.</p>
                    <p>namespaced-identikey associations can be used to evaluate namespaced identikeys.</p>
                    <pre>
namespace.identikey
namespace.namespace.identikey
</pre>
                    <p>get-property associations can be used to get properties of values.</p>
                    <pre>
starting-value.property.property.property

if namespaced-identikey is also true:
namespace.identikey.property
</pre>
                    <p>bind associations can be used to bind a method of a value to a value.</p>
                    <pre>
alpha.doStuff.apply
</pre>
                    <pre>
Different syntax for namespaced identikeys, getting properties, and method binding.

alpha::beta.gamma=&gt;delta

(bind
        (get-property
                (namespaced-identikey
                        (namespace alpha)
                        (identifier beta))
                (identifier gamma))
        (identifier delta))

Here, alpha must be a namespace, beta must be an identikey, gamma must be a property, and delta must be a method.
</pre>
                    <pre>
Shared syntax for namespaced identikey references and getting properties, but different syntax for method binding.

alpha.beta.gamma:delta

(bind
        (chain
                (bind false)
                (identifier alpha)
                (identifier beta)
                (identifier gamma))
        (identifier delta))

Here, alpha could be a free identikey or a namespace. If alpha is a namespace, beta could be a namespace. gamma could be an identikey in the alpha.beta namespace, or a property of the value that beta evaluated to. delta must be a method.
</pre>
                    <pre>
Shared syntax for getting properties and method binding, but different syntax for referring to namespaced identikey references.

alpha::beta.gamma.delta

(chain
        (namespaced-identikey false)
        (starting-value
                (namespaced-identikey
                        (namespace alpha)
                        (identifier beta)))
        (identifier gamma)
        (identifier delta))

Here, alpha must be a namespace and beta must be an identikey within that namespace. gamma could be a property or method of beta. delta could be a property or method of gamma.
</pre>
                    <pre>
Same syntax for all.

alpha.beta.gamma.delta

(chain
        (identifier alpha)
        (identifier beta)
        (identifier gamma)
        (identifier delta))

Delta cannot be a namespace.
</pre>
                    <pre>
A representation could provide different syntax for each association, but also provide a way to specify that one of multiple assocations are allowed.

alpha :: beta {. or =&gt;} gamma . delta =&gt; epsilon

&lt;bind&gt;
        &lt;get-property label="value"&gt;
                &lt;chain label="value"&gt;
                        &lt;bool label="namespaced-idenkey"&gt;false&lt;/bool&gt;
                        &lt;namespaced-identikey label="starting-value"&gt;
                                &lt;identifer label="namespace"&gt;alpha&lt;/identifer&gt;
                                &lt;identifer label="member"&gt;beta&lt;/identifer&gt;
                        &lt;/namespaced-identifer&gt;
                        &lt;identifer&gt;gamma&lt;/identifer&gt;
                &lt;/chain&gt;
                &lt;identifer label="property-name"&gt;delta&lt;/identifer&gt;
        &lt;/get-property&gt;
        &lt;identifier label="method-name"&gt;epsilon&lt;/identifer&gt;
&lt;/bind&gt;

Here, alpha must be a namespace, and beta must be an identikey within that namespace. Gamma can be a property or method of beta. delta must be a property of gamma. epsilon must be a method of delta.
</pre>
                </div>
                <div id="node.unassign-function">
                    <h3>10.7.2. unassign-function</h3>
                    <ul class="layout">
                        <li>expression</li>
                        <li>
                            <a href="#node.interface">interface</a>
                        </li>
                    </ul>
                    <p>Unassigns the function with the specified interface from the given value.</p>
                    <p class="xxx">What to do when such a function isn't bound? throw an error?</p>
                    <p>Removed because function identikeys must now always be constant.</p>
                </div>
            </div>
        </div>
        <div id="special-identikeys">
            <h1>Chapter 11. Special identikeys</h1>
            <p>No user-defined identikeys can use these identifiers.</p>
            <ul>
                <li>global - namespace identikey that refers to the outermost scope.</li>
                <li>outer - namespace identikey that refers to the outer scope. Exists in all scopes/namespaces that have an outer scope. global::outer is invalid, but outer::outer may be valid.</li>
                <li>std - namespace for the standard library</li>
            </ul>
        </div>
        <div id="standard-library">
            <h1>Chapter 12. Standard library</h1>
            <p class="xxx">The standard library should be imported to a namespace by default. That namespace can then be "used" to expose all members. However, what should the name of that namespace be? (The section above uses "std".) Possibilites: standard, system, language, desal, and various capitalizations (Standard, System, Language, Desal) and abbreviations (std, stand, sys, lang) thereof.</p>
            <ul>
                <li>interface Object</li>
                <li>interface Interface</li>
                <li>... Bool</li>
                <li>interface String</li>
                <li>interface Int</li>
                <li>interface Rat</li>
                <li>interface BigInt</li>
                <li>interface BigRat</li>
                <li>interface&lt;I&gt; Generator</li>
                <li>interface Octet</li>
                <li>interface Blob</li>
                <li>interface&lt;I&gt; Ref</li>
                <li>interface&lt;I&gt; WeakRef</li>
                <li>interface&lt;I&gt; Array</li>
                <li>interface&lt;I&gt; Chain</li>
                <li>func&lt;I&gt;(val)I cast</li>
                <li>func(val, Interface face)Bool implements?</li>
                <li>Bool true</li>
                <li>Bool false</li>
            </ul>
            <pre>
possible additions:

interface&lt;I&gt; Collection
interface&lt;I&gt; List
        indexed
        elements can be added to beginning and end
        dynamic array
interface&lt;I&gt; FwdChain
        forward chain, a singly-linked list
interface&lt;I&gt; Deck
        a deque with an easier name
interface Complex
        a complex number where both parts are limited to rational numbers
interface&lt;I&gt; Grid
        a 2-dimensional array
interface&lt;I&gt; Vector
        a resizable list
interface&lt;I&gt; Queue
interface&lt;I&gt; Stack
interface&lt;I&gt; Dict, SortedDict, MultDict, SortedMultDict, BiDict, SortedBiDict, MiltBiDict, SortedMultiBiDict
interface&lt;I&gt; Set, OrderdSet, MultiSet, OrderdMultiSect

func getProperty(dyn value, String propertyName) dyn
func setProperty(dyn value, String propertyName, dyn propertyValue) dyn

fixed-width/fixed-precision numbers
fixed-point integers
"limited" namespace
interface LimInt
interface LimRat
<p class="xxx">How to differentiate between mutable and unmutable versions?</p>
                
</pre>
            <pre>
//T is the type of an entry in this enum
interface&lt;T : EnumEntry&gt; Enum
        inherit Collection&lt;T&gt;
        func fromName(String str) T

//an Enum where every entry has an associated value
//T is the type of an entry in this enum
//U is the type of a value of an enum entry
interface&lt;T : EnumDictEntry, U&gt; EnumDict
        inherit Enum&lt;T&gt;
        func fromValue(U val) T

interface EnumEntry
        get String name
        func equals?( EnumEntry ) Bool

//U is the type of value each entry is associated with
interface&lt;U&gt; EnumDictEntry
        inherit EnumEntry
        get U value
</pre>
            <div id="object.activeInterface">
                <h2>12.1. activeInterface</h2>
                <pre>
func activeInterface(dyn) Interface

println( activeInterface(false) == Bool ) //true
</pre>
                <p>Returns the interface that is the active interafce of the specified value.</p>
            </div>
            <div id="object.cast">
                <h2>12.2. func{I}(dyn)I cast</h2>
                <p>The cast function returns an object cast to the specified interface, or throws a cast error. The returned object must be the same object that was passed in.</p>
                <code xml:space="preserve">if (foo is Bar) cast&lt;Bar&gt;(foo).propOfBar()</code>
            </div>
            <div id="object.generator">
                <h2>12.3. interface generator</h2>
                <pre>
interface{I} generator
        func next() I
</pre>
                <p>The next() method will return objects when called until it throws a GeneratorDone exception.</p>
                <p>Some looping constructs will automatically obtain a generator by calling the object's getValueIterator, getKeyIterator, or getPairIterator method, and call the next() method of the generator until the exception is thrown</p>
                <code xml:space="preserve">MyClass[] objs for each o in objs o.doStuff()</code>
            </div>
            <div id="object.id">
                <h2>12.4. func id</h2>
                <pre>
func id(obj) Int

println( id(true) )
</pre>
                <p>Every object is associated with a constant non-negative integer. No two objects that are still accessible can have the same object number. This function returns a value, with Int as the active interface, that encodes the object number for the object associated with the given value. Two objects with non-overlapping lifetimes may have the same object id.</p>
                <p>Returns a different number for every object. Always returns the same number for the same object, even if that object is a part of different values (the same object cast to different interfaces).</p>
            </div>
            <div id="object.sameObject_q">
                <h2>12.5. func sameObject?</h2>
                <p>Determines whether the two values have the same object.</p>
                <pre>
func sameObject?(obj, obj) Bool

println( sameObject?(foo, bar) )
//same as
println( (foo as obj) == (bar as obj) )
//same as
println( id(foo) == id(bar) )
</pre>
                <p>Tells whether the values are associated with the same object.</p>
            </div>
            <div id="object.implements_q">
                <h2>12.6. func(obj, interface)bool implements?</h2>
                <p>Tells whether the object implements the interface, like the implements node.</p>
                <code xml:space="preserve">if implements(foo, Bar) (foo as Bar).propOfBar()</code>
            </div>
            <div id="ident.Int">
                <h2>12.7. interface Int</h2>
                <ul>
                    <li>func lessThan?(Int) Bool</li>
                    <li>func lessThanOrEqual?(Int) Bool</li>
                    <li>func equal?(Int) Bool</li>
                    <li>func greaterThanOrEqual?(Int) Bool</li>
                    <li>func greaterThan?(Int) Bool</li>
                    <li>func unequal?(Int) Bool</li>
                    <li>Bool positive?</li>
                    <li>Bool negative?</li>
                    <li>func add(Int) Int</li>
                    <li>func subtract(Int) Int</li>
                    <li>func multiply(Int) Int</li>
                    <li>func multiply(Rat) Rat</li>
                    <li>func divide(Int) Rat</li>
                    <li>func divide(Rat) Rat</li>
                    <li>func floorDivide(Int) Int</li>
                    <li>func floorDivide(Rat) Int</li>
                    <li>func remainder(Int) Int</li>
                    <li>Int absolute</li>
                    <li>func add!(Int)</li>
                    <li>func subtract!(Int)</li>
                    <li>func multiply!(Int)</li>
                    <li>func increment!()</li>
                    <li>func decrement!()</li>
                    <li>func floorDivide!(Int)</li>
                    <li>func floorDivide!(Rat)</li>
                    <li>func toBuiltin() Int</li>
                    <li>convert Int</li>
                    <li>convert Rat</li>
                    <li>convert String</li>
                </ul>
                <p>The non-mutating methods of Int should never throw for precsion reasons, i.e. they should always return an Int that fully represents the result without loss of precision. However, the mutator methods may throw a PrecisionError if the value is not capable of representing the resultant integer.</p>
                <p>When Desal implementations need to determine the value of Int objects that were implemented by user code, they should call the toBuiltin method to get an Int object that was implemented by the implementation. If toBuiltin throws an error, it should raise into user code. If the returned Int is not a built-in, an error results that should extend into user code.</p>
                <p>The String produced by the String convertee must represent the stored integer absolutely, with no loss of precision. It may throw an error if it is incapable of producing such a representation. There are no restrictions on how the integer should be represented, although Int implementations generally should try to produce a representation that is simple and short. Implementations of Int should prefer exotic and strange representations over throwing an error. For example, implementations should prefer representing a googolplex with e.g. "10E(10E100)" ofer throwing an error.</p>
            </div>
            <div id="object.BigInt">
                <h2>12.8. interface BigInt</h2>
                <p>Inherits from Int.</p>
            </div>
            <div id="object.BigRat">
                <h2>12.9. interface BigRat</h2>
                <p>Inherits from Rat.</p>
            </div>
            <div id="ident.Interface">
                <h2>12.10. interface Interface</h2>
                <ul>
                    <li>get Bool fromAddition?</li>
                    <li>get Set{Interface} inheritees</li>
                    <li>get List{Parameters} parameters</li>
                    <li>get Type returnType</li>
                    <li>get List{Property} properties</li>
                    <li>get List{Method} methods</li>
                    <li>func add(Interface) Interface</li>
                    <li>func subtract(Interface) Interface</li>
                </ul>
                <p>Implements itself.</p>
            </div>
            <div id="object.Object">
                <h2>12.11. interface Object</h2>
                <ul>
                    <li>Bool builtin?</li>
                    <li>Bool mutable?</li>
                    <li>Int number</li>
                    <li>func{I} cast() I</li>
                    <li>func implements? (Interface) Bool</li>
                    <li>func sameObject? (Object) Bool</li>
                </ul>
                <p>These methods expose the same functionality of some of the nodes.</p>
                <p>The builtin? property tells whether the object is implemented by the Desal implementation, such as for integers and strings. The implements? method tells whether the object implements a specified interface.</p>
            </div>
            <div id="interface.rat">
                <h2>12.12. interface rat</h2>
                <ul>
                    <li>func toInt() int</li>
                    <li>func round() int</li>
                    <li>func round!()</li>
                </ul>
                <p>toInt will throw if the represented value is not already an integer. round should not throw. round! modifies the represented value.</p>
            </div>
        </div>
        <div id="warnings-list">
            <h1>Chapter 13. Warnings</h1>
            <p>This is a list of warnings predefined by this specification. Agents should create other warnings whenever needed.</p>
            <table>
                <tbody>
                    <tr>
                        <th>name</th>
                        <th>meaning</th>
                    </tr>
                    <tr>
                        <td>always null</td>
                        <td>A node that will never produce a value when executed is being used as if it will sometimes produce a value. This warning is produced by the node that attempts to make use of the output, such as an assignment node, and not the node that doesn't produce.</td>
                    </tr>
                    <tr>
                        <td>unknown warning</td>
                        <td>A warning name in an ignore node is not recognized.</td>
                    </tr>
                    <tr>
                        <td>no effect</td>
                        <td>The output of a node that does not have side effects is not being used. For example, if a block contains an integer node (that is not last), the integer node has no effect.</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div id="preexisting-global-identikeys">
            <h1>Chapter 14. Other preexisting global identikeys</h1>
            <p>Constant identikeys in the global scope that exist before source begins execution. The values these identikeys are bound to are immutable. Unlike prevalent identifers, these identifers follow normal scoping rules. They can always be refered to trough the prevalent global namespace identifier.</p>
            <ul>
                <li>interface InterfaceBuilder</li>
                <li>func()InterfaceBuilder CInterfaceBuilder</li>
                <li>func(int, interface[], interface)interface getFuncInterface</li>
                <li>interface{I} Iterator</li>
                <li>func{I}(:vararg)array{I} CArray</li>
                <li>func(bool[] bits, bool positive = true)int CInt</li>
                <li>func{I}(:vararg)list{I} CList</li>
                <li>func{I}(I)SelfGen print</li>
                <li>func{I}(I)SelfGen println</li>
            </ul>
            <div id="Generator">
                <h2>14.1. Generator</h2>
                <code xml:space="preserve">generic&lt;T&gt; interface Generator { func yield() T //throws a GeneratorExhausted exception (which inherits from SpecialCase) when all values have been yielded }</code>
            </div>
            <div id="InterfaceBuilder">
                <h2>14.2. InterfaceBuilder</h2>
                <ul>
                    <li>map{string, interface} properties</li>
                    <li>bool alwaysImmutable?</li>
                    <li>func()interface generate</li>
                </ul>
                <p>interface interface is always immutable, so InterfaceBuilder exists to allow creating interface objects procedurally.</p>
            </div>
            <div id="Iterator">
                <h2>14.3. Iterator</h2>
                <pre>
interface{I} Iterator
        //values may change
        bool first?
        bool last?
        bool hasNext?
        bool hasPrevious?
        bool between? //iterator points between 2 items (such as after the item was removed)
        bool valid?

        //capabilities of the iterator - values should not change
        bool canMoveForward? //whether the iterator can move forward
        bool canMoveBackward? //whether the iterator can move backwards
        bool canRemove?
        bool canReplace? //whether the objects can be replaced with different objects
        bool canRead?
        bool canInsertAfter?
        bool canInsertBefore?
        bool canCompareCollection?
        bool canCompareIterator? //corresponds to equal?
        bool canComparePosition? //corresponds to before? and after?

        func moveForward()
        func moveBackward()
        func remove()
        func replace(I)
        func insertAfter(I)
        func insertBefore(I)
        func sameCollection?( Iterator{I} ) bool
        func before?( Iterator{I} ) bool
        func after?( Iterator{I} ) bool
        func equal?( Iterator{I} ) bool
        
        I value
</pre>
                <p>An iterator is used to access the elements in a container. If the elements are not ordered 2-dimensionally, an 2-dimensional order must be decided for the iterator that does not change for that iterator instance. If the elements in the container are ordered 2-dimensionally, the iterator must refer the elements in that order.</p>
                <p>The equals? method returns true if both iterators are pointing to same item of the same collection. If the collection is unordered, the order the iterator moves over items must also be the same.</p>
                <p>A valid iterator either refers to an element or a position between two elements. An iterator should only refer to a position between two elements when the element the iterator currently pointed to was removed. If the iterator is not valid, or read? is false, the value property refers to null.</p>
                <p>An iterator only becomes invalid if:</p>
                <ul>
                    <li>the container contains no objects</li>
                    <li>the iterator is moved beyond all objects</li>
                    <li>a non-supported method is called (example: moveBackward() is called on an iterator that can only move forward)</li>
                </ul>
                <p>If an iterator is not valid, it may be possible to revalidate it by calling next() or previous(). For example, if the iterator refers to the last object and next is called, the iterator becomes invalid, but calling previous may make the iterator valid again. Whether an iterator can be revalidated and under what circumstances the iterator is revalidated is dependant on the implementation of the iterator.</p>
                <p>Containers should always give iterators with the same functionality. For example, if a container, when it has three elements, gives an iterator with forward? set to true, it should also give an iterator with the property forward? set to true when it has 1, even though calling moveForward() would invalidate the iterator.</p>
                <code xml:space="preserve">Container{int} numbers; Iterator iter = numbers.iterate(); int num = iter.value while( iter.valid? ) int num = iter.value iter.moveForward()</code>
            </div>
            <div id="CInterfaceBuilder">
                <h2>14.4. CInterfaceBuilder</h2>
                <p>CInterfaceBuilder, when called, returns an object that can be used to procedurally and/or dynamically create interface objects.</p>
            </div>
            <div id="getFuncInterface">
                <h2>14.5. getFuncInterface</h2>
                <pre>
func getFuncInterface (
        int templateParamCount,
        interface[] params,
        interface returnInterface,
) interface
</pre>
                <p>Returns an interface specifying a call method with the specified number of template parameters, the specified parameters, and the specified return interface. If returnInterface is null, the interface specifies a void call method. Every time it is called with the same arguments, it must return the same object.</p>
            </div>
        </div>
        <div id="error-handling-processing">
            <h1>Chapter 15. Error handling during processing</h1>
            <p>If an error is found during processing, and none of the already generated nodes have been executed, all generated nodes in the entire Desal tree must not be used for purposes beyond explaining the source of errors. Construction of the Desal node tree may continue after errors are found. The main() function must not be called, and the members should not be exposed as a library.</p>
            <p>If errors occur while generating the Desal node tree, and execution has already begun, a warning should immediately be emitted describing the error. How this warning is emitted is undefined. Generation of the Desal node tree may continue. When execution reaches the damaged section of the tree, an error should be thrown describing the error. If execution never reaches the damaged section of the tree, the error should have no effect.</p>
        </div>
        <div id="warnings">
            <h1>Chapter 16. warnings</h1>
            <table>
                <tbody>
                    <tr>
                        <th>string identifier</th>
                        <th>meaning</th>
                    </tr>
                    <tr>
                        <td>always null</td>
                        <td>A node that will never produce a value when executed is being used as if it will produce a value. Example: The result is being assigned to an identikey or passed as an argument. This applies to node types like 
                        <a href="#node.call">call</a>which can sometimes produce a value, if a particular instance can be determined to never produce a value. For example: func doStuff(){} (XXX should this warning apply to using nodes like throw, break, or return as expressions?)</td>
                    </tr>
                    <tr>
                        <td>unreachable</td>
                        <td>Code is unreachable. Execution will never reach a particular piece of code.</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <div id="rationales">
            <h1>Chapter 17. Rationales</h1>
            <p>This chapter explains the decisions behind various choices made for Desal.</p>
            <div id="rationale.dynamic-static-typing">
                <h2>17.1. Dynamic static typing</h2>
                <p>Dynamic static typing refers to explicitly using and enforcing type information that isn't available until runtime. The type information isn't known until runtime, but after it's known, it's enforced and can't be changed.</p>
                <p>An example of this is loading an interface from a library and then using obtaining values with that interface through the library. The loaded interface can be used as the type for function parameters, free identifiers, etc. So although the interface wasn't known until runtime, one the information was known, it was enforced, and the values of that interface are only accessed by ensuring they are of that interface.</p>
                <p>Dynamic static typing can do nothing beforehand to ensure property/method access is correct, but it can ensure that various values are of the same type. For example, consider the case where an interface is loaded from a library and bound to an identifer. Then a free identifier is declared to be of that type, and a function is declared to accept a value of that type. An implementation will known that the free identifer and the function's parameter are of the same type, so the value bound to the free identifier can safely be passed to the function. This safety could not be ensured with fully dynamic typing.</p>
                <p>Dynamic static typing is not as safe as fully static typing, but interfaces cannot always be known before runtime, which is a requirement for fully static typing. Therefore, Desal should provide something to give more type safety for the cases when interfaces cannot be known until runtime. Dynamic static typing is safer than fully dynamic typing.</p>
                <code xml:space="preserve">Interface Foo = lib['Foo'] Interface Bar = lib['Bar'] func()Foo getFoo = lib['getFoo'] func(Bar)Int doStuff = lib['doStuff'] Foo foo = getFoo() //static typing: known beforehand that types match foo.somthing() //dynamic typing: don't know beforehand whether Foo declares a 'somthing' method doStuff(foo) //static typing: known beforehand that types don't match --- Dyn getFoo = lib['getFoo'] Dyn doStuff = lib['doStuff'] Dyn foo = getFoo() //dynamic typing: don't know beforehand whether types match foo.somthing() //dynamic typing: don't know beforehand whether value of foo has a "somthing" method doStuff(foo) //dynamic typing: don't know beforehand whether types match</code>
                <p>Arguments against: Interfaces should almost always be known beforehand. Dynamic static typing may be very rarely used, and could encourage bad programming.</p>
            </div>
            <div id="rationale.terms">
                <h2>17.2. Terms</h2>
                <div id="rationale.get-set">
                    <h3>17.2.1. get/set</h3>
                    <table>
                        <tbody>
                            <tr>
                                <th>term as verb</th>
                                <th>term as noun</th>
                                <th>good points</th>
                                <th>bad points</th>
                            </tr>
                            <tr>
                                <td>get</td>
                                <td>getter</td>
                                <td>short, easy to say, easy to spell, common amoung programming languages</td>
                                <td>implies the property has been taken away</td>
                            </tr>
                            <tr>
                                <td>set</td>
                                <td>setter</td>
                                <td>short, easy to say, easy to spell, common amoung programming languages</td>
                                <td>sounds more like adding a new property than changing the value of a pre-existing property</td>
                            </tr>
                            <tr>
                                <td>access</td>
                                <td>accessor</td>
                            </tr>
                            <tr>
                                <td>retrieve</td>
                                <td>retriever</td>
                            </tr>
                            <tr>
                                <td>read</td>
                                <td>reader</td>
                            </tr>
                            <tr>
                                <td>write</td>
                                <td>writer</td>
                            </tr>
                            <tr>
                                <td>mutate</td>
                                <td>mutator</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>Additional notes:</p>
                    <p>The one letter difference between "get" and "set" (and "getter" and "setter") could cause errors more easily than if the difference were greater. Also, the noun form is slightly irregular; some people may expect "geter" and "seter" to be the noun form.</p>
                </div>
            </div>
            <div id="rationale.executing-boolean-logic">
                <h2>17.3. Executing boolean logic nodes</h2>
                <p>In other languages, functions/methods that return boolean values are often chained together with short-circuiting boolean logic nodes. XOR and XNOR nodes cannot short-circuit, and thus this does not apply to them.</p>
                <code xml:space="preserve">list.empty? $or list.clear() //similar to: $if $not list.empty? : list.clear() list.empty? $and list = getValues() //similar to: $if list.empty? : list = getValues()</code>
            </div>
            <div id="executing-declaration-first">
                <h2>17.4. Disallowing executing declaration-first</h2>
                <p>Children of declaration-first nodes are executed when the scope is first created, which may involve executing an identifier associated with a variable identikey. When execution reaches a declaration-first node, the identifiers used to create the initial value assigned to the identikey may be assigned to different values. Thus, executing a declaration-first node could produce unexpected results.</p>
                <code xml:space="preserve">$decl Int alpha = 12345 $block { alpha = 9000 println ( $decl-first Int beta = alpha ) //prints "12345" }</code>
                <p>In the above example, alpha is executed and assigned to beta when the scope for the block node is created. Then, 9000 is assigned to alpha. Then, the declaration-first node is executed, producing the value assigned to beta, which is 12345. A programmer may have expected beta to be bound to the current value of alpha, which is 9000.</p>
            </div>
        </div>
        <div id="unsorted-stuff">
            <h1>Chapter 18. unsorted stuff</h1>
            <div id="closures">
                <h2>18.1. Closures</h2>
                <p>Functions and classes (amoung others) have references to their containing scope. Identifier references in these scopes can be accessed and modified by the functions/classes.</p>
                <p>Copy closures create copies of specific values when a function node is executed. Modifying this copy does not modify the captured scope.</p>
                <code xml:space="preserve">//regular closures func makePrinters(Int max) func()void[] { func()void[] printers = new func()void[] Int i = 1 while i &lt;= max { printers &lt;&lt; func()void { print i + ' ' } i++ } return printers } //array of functions that have no parameters and return nothing func()void[] printers = makePrinters(10) for printer in printers { printer() } //output 10 10 10 10 10 10 10 10 10 10 Each of the anonymous functions held a reference to the same scope where i was defined. Because i held 10 when the functions were called, each output 10.</code>
                <code xml:space="preserve">//copy closures func makePrinters(Int max) func()void[] { func()void[] printers = new func()void[] Int i = 1 while i &lt;= max { printers &lt;&lt; func()void { copyclosure i print i + ' ' } i++ } return printers } //array of functions that have no parameters and return nothing func()void[] printers = makePrinters(10) for printer in printers { printer() } //output 1 2 3 4 5 6 7 8 9 10 Each of the anynonymous functions held a copy of the value of i at the time the function was created.</code>
            </div>
            <div id="tree-examples">
                <h2>18.2. Tree examples</h2>
                <div id="tree-example-1">
                    <h3>18.2.1. Example 1</h3>
                    <code xml:space="preserve">global declare-const identifier "main" expression [value] (function-definition) function-parameter identifier "args" expression [interface] (interface-template-instantiation) expression [interface-template] (identifier) "array" expression [template-argument] (identifier) "string" expression [return-interface] (identifier) "int" expression (return) expression (integer) 0 func main(string[] args) int return 0</code>
                </div>
                <div id="tree-example-2">
                    <h3>18.2.2. Example 2</h3>
                    <code xml:space="preserve">global (global) declaration (declaration &gt; function-declaration) name (string) "main" return (expression &gt; object-reference) name (string) "int" item (item &gt; return) value (expression &gt; integer) 0 func main() int return 0 &lt;global type="global"&gt; &lt;declaration type="function-declaration"&gt; &lt;name type="string"&gt;main&lt;/name&gt; &lt;return type="object-reference"&gt; &lt;name type="string"&gt;int&lt;/name&gt; &lt;/return&gt; &lt;item type="return"&gt; &lt;value type="integer"&gt;0&lt;/value&gt; &lt;/item&gt; &lt;/declaration&gt; &lt;/global&gt;</code>
                </div>
                <div id="tree-example-3">
                    <h3>18.2.3. Example 3</h3>
                    <code xml:space="preserve">global (global) name-bind (name-bind) identifier (identifier) "main" expression (function-definition) parameter (parameter) interface (interface &gt; function-call) function (function &gt; identifier) "array" argument (expression &gt; identifier) "string" identifier (identifier) "args" return-interface (interface &gt; identifier) "int" expression (expression &gt; return) expression (expression &gt; literal-integer) 0 func main(string[] args) int return 0 &lt;global type="global"&gt; &lt;name-bind type="name-bind"&gt; &lt;identifier type="identifier"&gt;main&lt;/identifier&gt; &lt;expression type="function-definition"&gt; &lt;parameter-list type="parameter-list"&gt; &lt;parameter type="parameter"&gt; &lt;identifier type="identifier"&gt;args&lt;/identifier&gt; &lt;expression type="function-call"&gt; &lt;identifier type="identifier"&gt;array&lt;/identifier&gt; &lt;argument-list type="argument-list"&gt; &lt;identifier type="identifier"&gt;string&lt;/identifier&gt; &lt;/argument-list&gt; &lt;/expression&gt; &lt;/parameter&gt; &lt;/parameter-list&gt; &lt;return-interface type="identifier"&gt;int&lt;/return-interface&gt; &lt;expression-list type="expression-list"&gt; &lt;expression type="return"&gt; &lt;expression type="literal-integer"&gt;0&lt;/expression&gt; &lt;/expression&gt; &lt;/expression-list&gt; &lt;/function&gt; &lt;/name-bind&gt; &lt;/global&gt;</code>
                </div>
            </div>
            <div id="get-interface">
                <h2>18.3. get interface</h2>
                <p>It's always possible to bind the interface of an object to an identifier.</p>
                <code xml:space="preserve">func getInterface{I}(I o) { return I; } dynref o = getMysteryObj() interface i = getInterface(o) i o2 = o</code>
            </div>
            <div id="obj-interface">
                <h2>18.4. obj interface</h2>
                <p>All objects automatically implement the "obj" interface.</p>
                <code xml:space="preserve">obj foo = getAnObject() (myinterface foo) .doStuff 3</code>
            </div>
            <div id="identifier-binding">
                <h2>18.5. Binding to identifiers</h2>
                <code xml:space="preserve">int alpha</code>
                <p>Declares that "alpha" can refer to objects that implement the "int" interface. alpha currently doesn't refer to anything; i.e. it refers to null.</p>
                <code xml:space="preserve">alpha = 3</code>
                <p>Creates an object that implements the int interface and makes alpha refer to it</p>
                <code xml:space="preserve">int beta = 5</code>
                <p>Declares that "beta" can refer to objects that implement the "beta" interface. Creates an object that implements the int interface. Binds the object to "beta".</p>
                <p>Multiple identifiers can refer to the same object.</p>
                <code xml:space="preserve">obj o = getObj() int a = o rat b = o</code>
            </div>
            <div id="print-println-return-interfaces">
                <h2>18.6. Return interfaces of print and println</h2>
                <p>Below, [unbound] means the interface is not bound to an identifier. However, these interfaces can be bound to identifiers and used like any user-created interface, and they have no special properties.</p>
                <ul>
                    <li>func{I}(I)[unbound] print</li>
                    <li>func{I}(I)[unbound] println</li>
                </ul>
                <pre>
interface{I} Print
        func call(I) Print

interface{I} PrintLine
        func call(I) PrintLine
</pre>
                <p>When print is called, it returns an object that implements an interface like Print. When println is called, it returns an object that implements an interface like PrintLine. Neither interface is bound to an identifier when execution begins. They are not the same interface, meaning print(1).interface == println(1).interface executes to false.</p>
                <pre>
println 1 2 3 "a" "b" "c" 4.5 6.7 8.9
</pre>
            </div>
            <div id="adjuncts">
                <h2>18.7. Adjuncts</h2>
                <code xml:space="preserve">interface IMyInterface public func doStuffA() public func doStuffB() class MyClass :implements(IMyInterface) ... func IMyInterface.doAB() this.doStuffA() this.doStuffB() func testThing(ref IMyInterface arg) arg.doAB() MyClass inst testThing(inst)</code>
            </div>
            <div id="runtime-inteface">
                <h2>18.8. runtime interface implementation</h2>
                <p>With Desal, you should be able to write a function that takes an interface (foo) and returns a function that takes an object of that interface (foo) and returns an object that implements that same interface (foo), but with an implementation that writes to a log anytime a method is called.</p>
                <pre>
log l = Log()
foo o = Foo()
foo wrapped = wrap(o, l)
doStuffWithAFoo(wrapped)
</pre>
                <p>Now anytime a method is called on the object, a log entry could be written.</p>
                <pre>
func{I} wrap(I o, log l) I
objbuilder wrapper = newObjbuilder()
wrapper.implement(I)
for prop in I.props
wrapper.interfaces[I].setProp( prop.name,
func(:vararg)obj

interface i = newInterface()
i.inherit(I)
for prop in 

wrap(...) takes an interface and returns a function
wrap(foo)(...) takes a foo and returns a foo
</pre>
            </div>
            <div id="runtime-interface-creation">
                <h2>18.9. Runtime interface creation</h2>
                <pre>
func createInterface( map{string,dyn} methods ) interface
        interface rv = newInterface()
        for (name, meth) in methods
                rv.methods.add( pair(name, meth.functionSignature) )
        return rv

func foo(int b) string
...

func bar(float c, float d) myClass
...

func baz(widget1 e, widget4 f)
...

map(string, func) table = {
"methA": foo,
"methB": bar,
"methC": baz
}
interface myinterface = createInterface(table)

func alpha(int g) string
...

func beta(float h, float i) myClass
...

func gamma(widget1 j, widget4 k)
...

myinterface myobj = {
methA: alpha,
methB: beta,
methC: gamma
}
string str = obj.methA(3)
myClass val = obj.methB(5.5, 7.7)
obj.gamma( createWidget1(), Widget4Factory.makeOne() )
</pre>
            </div>
            <div id="self-return-type">
                <h2>18.10. "self" return type</h2>
                <pre>
func(int,float)self

is the same as

interface __foo__
        func call(int,float) __foo__

func example(int num) self
        ...
        
example 1 2 3 4 5 6 7 8 9 0 //calls the example function 10 times
</pre>
            </div>
            <div id="bind">
                <h2>18.11. Bind</h2>
                <pre>
interface foo
        ...

func bar(foo o, int num)
        ...

foo fooInst = getAFoo()
bar(fooInst, 3)
(fooInst =&gt; bar) 3
func() funcy = (fooInst =&gt; bar)
funcy(3)
</pre>
                <p>obj =&gt; func</p>
                <p>The "=&gt;" operator binds the obj to the first argument of the function. It executes to a function. Semantically this creates a function-definition with a closure of the obj and func.</p>
            </div>
            <div id="classes">
                <h2>18.12. Classes</h2>
                <p>Classes produce functors that, when called, create objects. If a class implements more than 1 interface, it can declare which of the implemented interfaces is the active interface of the returned object by marking an interface as default. If no interface is marked, the active interface is obj.</p>
            </div>
            <div id="noninstantiated-interface-templates">
                <h2>18.13. Noninstantiated interface templates</h2>
                <pre>
interface list{I}
        readonly int count
        func pushFront(I o)
        func popFront() I

struct node{C}
        node{C} next = null
        node{C} value = null

class makeList{T}
        node{T} first
        
        interface list{T} #default //so makeList returns a list instead of an obj that has to be cast
                ...

list{int} nums = makeList{int}()
nums.pushFront(3)
nums.pushFront(5)
print nums.size //2

list{string} names = makeList{string}()
names.pushFront("John")
names.pushFront("Sarah")
names.pushFront("Billy")
print names.size //3

list someList = nums
print someList.size //2
someList.pushFront(5) //error
</pre>
                <p>someList may refer to any kind of list, such as list{foo}, list{bar}, etc, so only methods that have the same paramater and return interfaces for all list{}s can be called.</p>
            </div>
            <div id="dynamic-library-loading">
                <h2>18.14. Dynamic library loading</h2>
                <p>The selectLibrary function enables gaining references to objects without knowing the nodes that created the objects.</p>
                <pre>
interface Library
        readonly String path
        readonly String name
        readonly String version
        readonly Bool loaded?
        func key(String name) Dyn
        func get{I}(String name) I
        func load()
        func unload()

//prototype
func selectLibrary(string identifier, string version, bool load? = true) Library

---

string identifier
string version
if platform == platforms.MacOSX or platform == platforms.Windows
        identifier = "libxml"
        version = "2.1"
elif platform == platforms.Linux
        identifier = "/usr/lib/libxml.so"
        version = "56"
else
        throw Error("unsupported platform")

Library XmlLib = selectLibrary(identifier, version)

Interface XmlElement = XmlLib.get{Interface}("XmlElement")
Dyn XmlReader = XmlLib["XmlReader"]

XmlElement element = XmlRead.read("foo.xml").documentElement
</pre>
            </div>
            <div id="static-typing">
                <h2>18.15. Static typing</h2>
                <p>XXX spec out static typing and demand that implementations check all typing as much as possible before running anything. Note the section on dynamic static typing.</p>
            </div>
        </div>
    </body>
</html>
