<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="node-types">
	<title>Node types</title>

	<para>This chapter describes the various types of nodes.</para>
	
	<section xml:id="base-node-types">
		<title>Base nodes</title>
		
		<para>These node types do not contain child nodes, and are thus the only nodes that must encode information themselves (as opposed to containing child nodes which together provide information).</para>
		
		<simplelist>
			<member linkend="node.access">access</member>
			<member linkend="node.boolean">boolean</member>
			<member linkend="node.direction">direciton</member>
			<member linkend="node.identifier">identifier</member>
			<member linkend="node.identikey-category">identifier-category</member>
			<member linkend="node.integer">integer</member>
			<member linkend="node.rational">rational</member>
			<member linkend="node.string">string</member>
		</simplelist>
	</section>
	
	<section xml:id="tree-node-layout-key">
		<title>Tree node layout key</title>
		
		<para>This section describes how the layout of a node type is represented in this specification.</para>
		
		<para>The layout for a node type is represented in this specification as a list of items. Each item represents a child node, or multiple child nodes with the same meaning.</para>
		
		<para>Each item in these lists first specifies how many child nodes with that meaning may appear, or it says nothing about the number, which means there must be one (and no more). The ways of representing these amounts is described below.</para>
		
		<variablelist>
			<varlistentry>
				<term>?</term>
				<listitem>0 or 1</listitem>
			</varlistentry>
			<varlistentry>
				<term>*</term>
				<listitem>0 or more</listitem>
			</varlistentry>
			<varlistentry>
				<term>+</term>
				<listitem>1 or more</listitem>
			</varlistentry>
		</variablelist>
		
		<para>Next comes the name of a node type, or "expression". The child node represented by that list item must be of that type. The string "expression" means the node must be an expression.</para>
		
		<para>Lastly comes a optional label for refering to the child nodes represented by that item, when the type alone isn't enough to disambiguate which item is being referred to. These labels carry no semantic information, and are merely used by this specification to refer to specific child nodes. (Note this label is always singular, even for collections.)</para>
		
		<para>Example layout:</para>
		
		<screen>
alpha
? beta gamma
? beta delta
* epsilon
+ expression zeta
		</screen>
		
		<para>The first item represents a single required child node of type "alpha". The second item represents an optional child node of type "beta", which can be referred to using the label "gamma". The third item represents an optional child node of type "beta", which can be referred to using the label "delta". The fourth item refers to a collection of child nodes of type "epsilon"; the collection can be empty. The fifth item refers to a collection of expression child nodes; the collection must contain at least one node; nodes in this collection can be refered to using the label "zeta".</para>
	</section>
	
	<section xml:id="non-executable">
		<title>Non-executable</title>
		
		<para>Nodes that cannot be executed. Most server only to group other nodes together.</para>
		
		<section xml:id="node.argument">
			<title>argument</title>
			
			<simplelist role="layout">
				<member>? identifier parameter name</member>
				<member>? expression value</member>
			</simplelist>
			
			<programlisting>
func doSomething(Int a = 1, Int b = 2, Int c = 3, Int d) {...}
doSomething(7, default, default, 8)
doSomething(7, c = default, 8)
			</programlisting>
		</section>
		
		<section xml:id="node.boolean">
			<title>boolean</title>
			
			<para>Base node. Must specify either true or false.</para>
			
			<para>Cannot be evaluated because that would conflict with the "true" and "false" members of the Bool enum. Boolean values in the node tree use a boolean node, and boolean values in code use the "true" and "false" identikeys.</para>
		</section>
		
		<section xml:id="node.direction">
			<title>direction</title>
			
			<para>Specifies the direction of a function parameter, one of: in, in-mutable, out, in-out, in-mutable-out</para>
			
			<para>A value passed to a function as an "in" parameter will not be mutated by the function. This means if the function uses the value in ways that may mutate the value, the value will be copied. If an action in the function may mutate the value, and the value does not declare a copy converter, an error results.</para>
			
			<para>Instances where the value may be mutated include when the interface of the value does not provide opacity information and the function calls a method, or if the interface does provide opacity information but the function calls a mutator method, or if the value is passed to another function as an in-mutable or in-mutable-out parameter.</para>
			
			<programlisting>
func alpha(in Int num) {
println num
}

func beta(in-mutable Int num) {
num += 567
}

func gamma(out Int num) {
//num not currently assigned to anything
num = 987
}

func delta(in-out Int num) {
println num
num = 1001
}

func epsilon(in-mutable-out Int num) {
num += 55555
num = 19591
}

Int num = 123
alpha(num)
beta(num) //value mutated
gamma(num) //num assigned to different value
delta(num) //num assigned to different value
epsilon(num) //value mutated and num assigned to different value
			</programlisting>
		</section>
		
		<section xml:id="node.expose">
			<title>expose</title>
			
			<para>Imports all the child identikeys of the specified namespace into the enclosing scope.</para>
			
			<simplelist role="layout">
				<member>+ identifier</member>
			</simplelist>
			
			<programlisting>
decl std::Array&lt;std::Int> numbers = generateNumbers()

expose std
decl Array&lt;Int> numbers = generateNumbers()
			</programlisting>
		</section>
		
		<section xml:id="node.generic-parameter">
			<title>generic-parameter</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>? expression default interface</member>
			</simplelist>
		</section>
		
		<section xml:id="node.identikey-category">
			<title>identikey-category</title>
			
			<para>specifies one of: namespace, dynamic, automatic, strict, function</para>
			
			<para>See the <link linkend="identikeys">section on identikeys</link>.</para>
		</section>
		
		<section xml:id="node.identikey-type">
			<title>identikey-type</title>
			
			<simplelist role="layout">
				<member>identikey-category</member>
				<member>? nullable-type</member>
				<member>? boolean constant</member>
			</simplelist>

			<para role="process">[type] must be present if and only if the identikey-category is not namespace. The [type] must specify an [interface] if the identikey-category is strict. The [type] can specify an [interface] if the identikey-category is function. The [type] must not specify an [interface] if the identikey-category is namespace, dynamic, or automatic. The [type] must specify false for [nullable] if identikey-category is function. [constant] must not be specified if and only if the identikey-category is namespace or dynamic.</para>
			
			<para>If the category is strict, the active interface of any value bound to the identikey must be that interface. If the category is function, and the interface is given, functions bound to the identikey must specify that interface as the return type.</para>
			
			<para>The default value of [constant] is false. If [constant] is true, the identifier thereafter always refers to the same value. The identifier cannot be bound to a different value, or unbound. The active interface also cannot be changed.</para>
			
			<programlisting>
Int a = 3
func Int a = func()Int { return 3 }
			</programlisting>
		</section>
		
		<section xml:id="node.import">
			<title>import</title>
			
			<para>Binds a library namespace to a namespace identikey.</para>
			
			<simplelist role="layout">
				<member>string library</member>
				<member>identifier alias</member>
			</simplelist>
				
			<programlisting>
import "XmlLib" as Xml

library: "XmlLib"
alias: Xml
			</programlisting>
		</section>
		
		<section xml:id="node.nullable-type">
			<title>nullable-type</title>

			<para>Specifies a value type, including whether the absence of a value is allowed.</para>
			
			<simplelist role="layout">
				<member>? expression interface</member>
				<member>boolean nullable</member>
			</simplelist>
		</section>

		<section xml:id="node.parameter">
			<title>parameter</title>
			
			<para>A function parameter.</para>
			
			<simplelist role="layout">
				<member>direction</member>
				<member>nullable-type</member>
				<member>identifier name</member>
				<member>boolean has default value</member>
				<member>? expression default value</member>
			</simplelist>
			
			<para role="xxx">Should this node be split into e.g. parameter-info and parameter-impl? See next paragraph.</para>
			
			<para>When this node is a child of a function-interface or callee node, [default value] must not be present. (Meaning it can only be present when the child of a function node.) When a [default value] is given because the node is a child of a function node, [default value] is executed for every call to the function. It is not executed when the function node is executed.</para>
		</section>
				
		<section xml:id="node.plane">
			<title>plane</title>
			
			<para>A group of declarations within a bundle.</para>
			
			<simplelist role="layout">
				<member>* scope-alteration alt</member>
				<member>+ declare-first</member>
			</simplelist>
			
			<para>This node has scope, but only private identifiers are bound to it. Public and exported identifiers are bound to the scope of the bundle node.</para>
			
			<para>Planes aren't expressions because their declare-first nodes might rely on declare-first nodes in other planes, so all the declare-first nodes in a single plane can't just be executed all together.</para>
		</section>
		
		<section xml:id="node.scope-alteration">
			<title>scope-alteration</title>
				
			<para>This is a supertype, like expression. This type includes <link linkend="node.using">using</link> and <link linkend="node.expose">expose</link>.</para>
		</section>
		
		<section xml:id="node.using">
			<title>using</title>
			
			<para>Creates an identikey that is associated with the same value/namespace as the specified identikey in the specified namespace.</para>
			
			<simplelist role="layout">
				<member>+ identifier target</member>
				<member>? identifier name</member>
			</simplelist>
			
			<programlisting>
using Xml.XmlElement
using Xml.XmlDocument as Doc

import ".NET: System" as System
using System.Collections.Generic as box
box.IList&lt;Foo> = new box.List&lt;Foo>();
			</programlisting>
			
			<programlisting>
using FooBarBaz as FBZ
using System.out.print as puts
puts( (FBZ to String)(Gamma) )
			</programlisting>
			
			<para>Each of the [target] identifiers, except for the last, must refer to a namespace. (The last can also refer to a namespace.)</para>
		</section>
	</section>

	<section xml:id="non-producing-expressions">
		<title>Non-producing expressions</title>
		
		<para>Nodes that can be executed, but never produce.</para>

		<section xml:id="iteration">
			<title>Iteration</title>
			
			<para role="xxx">The interface expressions for these nodes need to be replaced with type nodes.</para>
			
			<section xml:id="node.do-while">
				<title>do-while</title>
				
				<simplelist role="layout">
					<member>block action</member>
					<member>expression test</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
do while test()
	something()

do
	something()
while test()
				</programlisting>
			</section>
			
			<section xml:id="node.do-times">
				<title>do-times</title>
				
				<simplelist role="layout">
					<member>expression times</member>
					<member>block action</member>
					<member>? expression test</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
do 8 times
	something()
	
do 8 times while test()
	something()
	
do 8 times
	something()
while test()
				</programlisting>
			</section>
			
			<section xml:id="node.for-key">
				<title>for-key</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression key interface</member>
					<member>identifier name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<orderedlist role="exec">
					<listitem>1. Call getKeyIterator on [container].</listitem>
					<listitem>2. Call getNext on [1]. If an exception is thrown with an active interface of GeneratorDone, swallow it and end execution. If anything else is thrown, follow normal exception rules.</listitem>
					<listitem>3. Create a scope.</listitem>
					<listitem>4. Assign [2] to [identifier] in [3].</listitem>
					<listitem>5. Execute [block] with scope [3].</listitem>
					<listitem>6. Go to step 2.</listitem>
				</orderedlist>
				
				<programlisting>
for key x in foo
	doStuff(x)

for key Int x in foo
	doStuff(x)
				</programlisting>
			</section>
			
			<section xml:id="node.for-pair">
				<title>for-pair</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression key interface</member>
					<member>identifier key name</member>
					<member>? expression value interface</member>
					<member>identifier value name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
for pair x, y in coords
	drawPoint(x, y)

for pair Int x, Int y in coords
	drawPoint(x, y)
				</programlisting>
			</section>

			<section xml:id="node.for-manual">
				<title>for-manual</title>
				
				<para>Used for manual iteration, as opposed to letting the Desal implementation deal with iteration, like with a for-value node.</para>
				
				<simplelist role="layout">
					<member>* expression initializer</member>
					<member>? expression test</member>
					<member>* expression post action</member>
					<member>? block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<para>The initializers are executed before iteration begins. Test is evaluated before each iteration. Post actions are executed after each iteration.</para>
				
				<screen>
initializers

test
action
post actions

test
action
post actions

...

test
action
post actions

test

(end of loop)
				</screen>
				
				<programlisting>
for manual( decl Int i = 0; i lt container.length; i++ )
	println container[i]

for manual( Iterator&lt;Int> iterator = container.getIterator() ;
iterator.hasMore? ; iterator.moveNext() )
	println iterator.current
				</programlisting>
			</section>
			
			<section xml:id="node.for-range">
				<title>for-range</title>
				
				<simplelist role="layout">
					<member>? identifier name</member>
					<member>expression start</member>
					<member>expression limit</member>
					<member>boolean inclusive</member>
					<member>? expression test</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<para>[inclusive] determines whether the loop should iterate one last time if the iteration value is equal to the limit, and it is false by default.</para>
				
				<programlisting>
for 0 to 100
	println "test"

for x from 0 to 100
	println x

for x from 0 to 100 inclusive
	println x

for 0 to string.length while not container.full
	container.push( string.unshift!() )

for x from 0 to 100 while not foo.done?
	foo.runTest(x)
				</programlisting>
			</section>
			
			<section xml:id="node.for-value">
				<title>for-value</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression value interface</member>
					<member>identifier name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
for name in names
	println name

for String name in names
	println name
				</programlisting>
			</section>
			
			<section xml:id="node.loop">
				<title>loop</title>
				
				<simplelist role="layout">
					<member>block</member>
				</simplelist>
				
				<para>Executes block continuously. Can only be exited by expressions in the block such as break and return.</para>
			
				<programlisting>
loop
	Event event = getNextEvent()
	select event.type
	case Event.QUIT
		break
	else
		defaultHandler(event)
				</programlisting>
			</section>
			
			<section xml:id="node.while">
				<title>while</title>
				
				<simplelist role="layout">
					<member>expression test</member>
					<member>block</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
while printNext() {}

while container.hasMore?
	print container.next
				</programlisting>
			</section>
		</section>
		
		<section xml:id="node.break">
			<title>break</title>
			
			<simplelist role="layout">
				<member>? identifier label</member>
			</simplelist>
		</section>
		
		<section xml:id="node.continue">
			<title>continue</title>
			
			<simplelist>
				<member>? identifier label</member>
			</simplelist>
		</section>
		
		<section xml:id="node.declare-empty">
			<title>declare-empty</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
			</simplelist>
			
			<para role="process">The identikey-type must not be constant.</para>
			
			<para>Creates an identikey in the parent scope with the specified type. After this node executes, the produced identikey does not yet point to any values.</para>

			<programlisting>
decl func Int foo
foo = func()Int { return 3 }
foo = func(Int a)Int { return a * 2 }
print foo() //prints 3
print foo(2) //prints 4

//xxx does this produce error or replace?
foo = func()Int { return 5 }
			</programlisting>

			<programlisting>
decl func()Int foo
foo = func()Int { return 3 }
print foo() //prints 3
foo = func()Int { return 5 }
print foo() //prints 5
foo = func(Int a)Int { return a * 2 } //error - interface mismatch
			</programlisting>
		</section>
		
		<section xml:id="node.declare-first">
			<title>declare-first</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
				<member>expression value</member>
				<member>boolean breed</member>
			</simplelist>
			
			<para role="process">The identikey-type must be constant, and must have a category of automatic, strict, or function.</para>
			
			<para>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</para>
			
			<para>When a block contains declare-first nodes, the declare-first nodes are executed before the other expressions in the block are executed. The value expressions of declare-first nodes may depend on the values of other declare-first nodes in the same block. For example, two interfaces could reference each other.</para>
			
			<para>This node can create identikeys before execution reaches it. For more information, see <link linkend="handling-declare-first">this section</link>.</para>
			
			<para role="exec">Produce the value bound to the identikey created by this node.</para>
			
			<programlisting>
declfirst auto Foo = interface {
	get Bar bar
}

declfirst auto Bar = interface {
	get Foo foo
}

Foo foo = ...
foo.bar.foo.bar...
			</programlisting>
		</section>
		
		<section xml:id="node.labeled">
			<title>labeled</title>
			
			<simplelist role="layout">
				<member>identifier label</member>
				<member>expression child</member>
			</simplelist>
			
			<para role="process">The [child] node must be an iteration node, a block node, a possibility node, a conditional node, or a select node. (XXX update and explain requirements instead of just listing nodes that meet requirements)</para>
			
			<programlisting>
func setupCell(Int searchID) {
	decl Cell wantedCell
	
	outer: for row in table {
		for cell in row
			if cell.ID eql searchID
				wantedCell = cell
				break outer
	}
	
	if wantedCell != null
		doSomething(wantedCell)
}
			</programlisting>
		</section>
		
		<section xml:id="node.null">
			<title>null</title>
			
			<para>Produces an untyped null.</para>
			
			<para>(XXX move) An untyped null can be cast to any interface, implicitly or explicitly, to form a typed null. A typed null can be downcast.</para>
			
			<programlisting>
decl Int ? foo = 123
foo = null //untyped null implicitly cast to an Int null
foo //evaluates to an Int null

decl String ? bar = (foo as void)
			</programlisting>
			
			<para role="xxx">Why not just have a global reserved identikey named "null" of type void? It would always evaluate to an untyped null.</para>
		</section>
		
		<section xml:id="node.return">
			<title>return</title>
			
			<simplelist role="layout">
				<member>? expression value</member>
			</simplelist>
			
			<para>Function call ends and evaluates to expression.</para>
		</section>
		
		<section xml:id="node.throw">
			<title>throw</title>
			
			<simplelist role="layout">
				<member>expression value</member>
			</simplelist>
			
			<para>If the expression isn't an Exception, wrap it with NonExceptionThrownError.</para>
		</section>
	
		<section xml:id="node.yield">
			<title>yield</title>
			
			<para>Within a generator, specifies the next value for the generator to yield.</para>
			
			<simplelist role="layout">
				<member>expression value</member>
			</simplelist>
			
			<para role="process">Must be a descendant of a generator node, and not inside a function or class node. (XXX spec out the kind of barriers function and class nodes create)</para>
		</section>
	</section>

	<section xml:id="sometimes-producing-expressions">
		<title>Sometimes producing expressions</title>
		
		<para>Nodes that can be executed, and sometimes produce.</para>

		<section xml:id="node.assign">
			<title>assign</title>
			
			<para>Assigns a value to an identikey.</para>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>expression value</member>
				<member>boolean breed</member>
			</simplelist>
			
			<para role="process">The identikey's type must be dynamic, automatic, or strict. If the identikey's type is automatic or strict, the identifier must be variable (not constant).</para>
			
			<para>If bree is false:</para>
			
			<orderedlist>
				<listitem>Let key by the identikey that [name] refers to.</listitem>
				<listitem>Execute [value] and let value be the product.</listitem>
				<listitem>Associate key with value so that key now refers (only) to value.</listitem>
			</orderedlist>
			
			<para>If breed is true:</para>
			
			<orderedlist>
				<listitem>Let key be the identikey that [name] refers to.</listitem>
				<listitem>Execute [value] and let parentValue be the product.</listitem>
				<listitem>Let faceValue be the required interface for key. If key does not require a particular interface, let faceValue be the active interface of parentValue.</listitem>
				<listitem>Find parentValue's breeder that produces values with an active interface of faceValue. If such a breeder is not found, throw an error.</listitem>
				<listitem>Activate the found breeder and let value be the product.</listitem>
				<listitem>Associate key with value so that key now refers (only) to value.</listitem>
			</orderedlist>
			
			<para>Example of difference between breeding and not breeding:</para>
			
			<programlisting>
decl Person person1
decl Person person2

person1 = Person()
person1.name = "John"
person2 = person1 //not breeding - person1 and person2 refer to same object
person2.name = "Suzy"
println( person1.name ) //Suzy

person1 = Person()
person1.name = "Michael"
person2 := person1 //breeding - person1 and person2 refer to different objects
person2.name = "Kim"
println( person1.name ) //Michael
			</programlisting>
		</section>
		
		<section xml:id="node.block">
			<title>block</title>
			
			<para role="xxx">Come up with better name.</para>
			
			<simplelist role="layout">
				<member>* scope-alteration alt</member>
				<member>* expression member</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<orderedlist role="exec">
				<listitem>Execute each expression in order. Produce the result of the last expression. (Produce nothing if the block contained no expressions or the last expression didn't produce.)</listitem>
			</orderedlist>
			
			<para>Note: This node type is different from the Dextr concept of blocks. To differentiate between the two, nodes of this type can be called "block nodes", and the syntactic construct of Dextr can be called "Dextr blocks" or "syntactic blocks".</para>
			
			<programlisting>
block {
	using System:Console
	using System:Collections as Boxes
	export Boxes:Generic
	Boxes:List numbers = List&lt;MyFace>()
	Console.WriteLine(numbers.Count.ToString())
}
			</programlisting>
		</section>
		
		<section xml:id="node.call">
			<title>call</title>

			<simplelist role="layout">
				<member>expression value</member>
				<member>* argument</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Execute [value].</listitem>
				<listitem>If the resultant value is not callable, throw an error.</listitem>
				<listitem>Execute the argument expressions in order.</listitem>
				<listitem>Send argument values to the [value] value for execution.</listitem>
				<listitem>Produce the returned value.</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.cast">
			<title>cast</title>
			
			<simplelist role="layout">
				<member>expression source</member>
				<member>? nullable-type</member>
			</simplelist>
			
			<para role="process">If [nullable-type] is given, it must declare an interface.</para>
			
			<orderedlist role="exec">
				<listitem>Execute [source] and let source be the result.</listitem>
				<listitem>If [nullable-type] is not given:
					<orderedlist>
						<listitem>If source is not null, throw an error, because a non-null value cannot be cast to void.</listitem>
						<listitem>Otherwise, produce an untype null.</listitem>
					</orderedlist>
				</listitem>
				<listitem>If [nullable] of [nullable-type] is true, and source is null, throw an error, because a null cannot be cast to a non-null type.</listitem>
				<listitem>Execute the [interface] of [nullable-type] and let face be the result.</listitem>
				<listitem>If source is non-null, cast it to face and return the result. If it cannot be cast to face, throw an error.</listitem>
				<listitem>If source is a typed null, and the associated interface does not inherit from face, throw an error.</listitem>
				<listitem>Produce a typed null with face as the associated face.</listitem>
			</orderedlist>
			
			<para>If [source] is not null, evaluates to a value, with an active interface specified by nullable-type, that is associated with the same object as [source]. Can also be used to cast null to typed or untyped null.</para>
			
			<programlisting>
//value
123 as Int
123 as Int ?
123 as void //error

//typed null
(null as Int ?) as Int //error
(null as Int ?) as Int ?
(null as Int ?) as void

//untyped null
null as Int //error
null as Int ?
null as void

Int o = getIntAndString()
print (o as String).length

decl Int ? a = (null as Int)
decl String ? b = ((a as null) as String)

decl Int ? a = null
decl String ? b = a as null
			</programlisting>
			
			<para>(XXX label or move) Rationale for casting to null: A generic type may want to cast an object to a parameter type, and the parameter type may be null. XXX But does that mean nullable-type must be replaced with a NullableType interface?</para> 
		</section>
			
		<section xml:id="node.conditional">
			<title>conditional</title>
			
			<simplelist role="layout">
				<member>+ possibility</member>
				<member>? expression else</member>
			</simplelist>
			
			<para role="exec">Execute the [test] of the first [possibilty]. Downcast the resultant value to a Bool. If it is true, execute the [result] of that [possibilty] and produce the result. Otherwise, move on to the next node. If no [test] produces true, and [else] is given, execute [else] and produce its result.</para>
			
			<programlisting>
decl Int a = (x ? 0 : 1)

if foo == 1
	doStuff1()
elif foo == 2
	doStuff2()
else
	doDefault()

decl bar =
	(foo == 1) ? getOne() :
	(foo == 2) ? getTwo() :
	getDefault()

decl bar =
	if foo == 1 : getOne()
	elif foo == 2 : getTwo()
	else : getDefault()
			</programlisting>
		</section>
		
		<section xml:id="node.curry">
			<title>curry</title>
			
			<para>Provides a built-in means of partial application. (Note that Desal provides no built-in support for the original type of currying, where a multi-argument function is converted into a chain of single-argument functions.)</para>
			
			<simplelist role="layout">
				<member>expression function</member>
				<member>* argument</member>
				<member>boolean call</member>
			</simplelist>

			<para>If [call] is true, and this node results in the function receiving enough arguments to be called, the function will be called.</para>
			
			<programlisting>
func foo(Int a, Rat b, String c, Bool d) Int {
	...
}

//partial application
func(String,Bool)Int foo2 = foo(1, 2.34)
print foo2("text", true)

//other type of currying
func(Int)(
	func(Rat)(
		func(String)(
			func(Bool)Int ))) foo3 = curry(foo)
print foo3(1)(2.34)("text")(true)

//The above two are equivalent to:
print foo(1, 2.34, "text", true)
			</programlisting>
			
			<para>Assuming the function is not called: If the arguments match only one of the callees/methods of [value], this node produces a value with a function interface as the active interface. If the arguments match more than one of the callees/methods on [value], this node produces a value with an active interface that is made by adding the function interfaces of the callees/methods together.</para>
			
			<para>After execution, the specified parameters have values, so they do not appear on the resultant function.</para>
			
			<para>Once the function has all its arguments supplied, it is called if [call] is true, and the result of that call is produced.</para>
			
			<programlisting>
func doStuff1(Int a, String b, Bool alpha) {...}
func doStuff1(Int a, Rat b, Bool alpha) {...}
func doStuff2 = doStuff1~(3, alpha=false)
doStuff2("test")
doStuff2(123.456)
			</programlisting>
			
			<para>The middle line perhaps might also be represented this way:</para>
			<programlisting>
(declare-first
	(identifier.name "doStuff2")
	(curry
		(identifier.value "doStuff1")
		(argument
			(integer.value 3))
		(argument
			(identifier.name "alpha")
			(identifier.value "false"))))
			</programlisting>

			<programlisting>
interface Alpha
func bar(Int a, Rat b, String c)

Alpha alpha = AlphaClass()

alpha.bar(0, 0.0, "0")

func()void bar1 = alpha.bar~()
bar(1, 2.3, "4")

func()void bar2 = alpha.bar~(c="text")
bar2(7, 9.8)

func()void bar3 = alpha.bar~(-9, 0.001, "stuff")
bar3()
			</programlisting>
		</section>
		
		<section xml:id="node.declare-assign">
			<title>declare-assign</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
				<member>expression value</member>
				<member>boolean breed</member>
			</simplelist>
			
			<para role="process">The identikey-category of the identikey-type node must be dynamic, automatic, strict, or function.</para>
			
			<para>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</para>
		</section>
		
		<section xml:id="node.ignore">
			<title>ignore</title>
			
			<para>Instructs an agent to not output certain warnings.</para>
			
			<simplelist role="layout">
				<member>expression content</member>
				<member>+ ignore-member</member>
			</simplelist>
			
			<section xml:id="node.ignore-member">
				<title>ignore-member</title>
				
				<simplelist role="layout">
					<member>string name</member>
					<member>integer depth</member>
				</simplelist>
			
				<para>The [name] can be a warning name from the <link linkend="warnings-list">specified warnings</link> or an agent-defined warning name. Unknown warning names should by default produce a warning that the warning name is unknown. Agents should provide an option to disable warnings for unknown warning names.</para>
				
				<para>The [depth] specifies what descendant nodes are affected by the ignore node. Counting begins at one with the [content] node of the ignore node and increments by one for each further descendant.</para>
				
				<programlisting>
(ignore
	(ignore-member
		(string.name "always null")
		(integer.depth ...))
	(call.content
		(function.identifier println)
		(assignment.argument
			(identifier.name foo)
			(for-value.value
				...))))
				</programlisting>
				
				<para>Here, if the [depth] was 1, a warning should be output by the agent for the assignment node that the [value] node will never produce a value when executed (a.k.a. always evaluate to null).</para>
			</section>
		</section>

		<section xml:id="node.namespaced-value-identikey">
			<title>namespaced-value-identikey</title>
			
			<simplelist role="layout">
				<member>+ identifier namespace</member>
				<member>identifier identikey name</member>
			</simplelist>
			
			<programlisting>
namespace foo {
	namespace bar {
		decl Int alpha = 123
	}
}
decl Int alpha = foo:bar:alpha
println( alpha ) //123
			</programlisting>
		</section>
		
		<section xml:id="node.possibility">
			<title>possibility</title>
			
			<simplelist role="layout">
				<member>expression test</member>
				<member>expression result</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<para role="process">An error results if the implementation knows [test] will never evaluate to a value that can be downcast to Bool.</para>
			
			<orderedlist role="exec">
				<listitem>Evaluate [test].</listitem>
				<listitem>Downcast [1] to Bool.</listitem>
				<listitem>If [2] is true, evaluate [result].</listitem>
				<listitem>Evaluate this node to [3].</listitem>
			</orderedlist>
			
			<programlisting>
if not foo.isSetup? {
	foo.setup()
}
			</programlisting>
		</section>
		
		<section xml:id="node.select">
			<title>select</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>* case</member>
				<member>? expression else</member>
			</simplelist>
			
			<para role="exec">Execute [value]. Execute each [values] child of each [case] and compare them to the [value] value (with the .equals? method of the [value] value) until finding a match. Then, execute the [result] of that case and produce the result. If no match is found, and [else] is given, execute [else] and produce its result.</para>
			
			<section xml:id="node.case">
				<title>case</title>
				
				<simplelist role="layout">
					<member>+ expression value</member>
					<member>expression result</member>
				</simplelist>
			</section>
			
			<programlisting>
select event.type
case Events.QUIT {
	return
}
case Events.FOO, Events.BAR, Events.MAZ {
	//no action
}
else {
	throw ErrorClass("unknown event type")
}

select foo
case 1
	doStuff1()
case 2
	doStuff2()
else
	doDefault()

decl bar = select foo
	case 1 : getOne()
	case 2 : getTwo()
	else getDefault()
			</programlisting>
		</section>
		
		<section xml:id="node.try-catch">
			<title>try-catch</title>
			
			<simplelist role="layout">
				<member>expression try</member>
				<member>* exception-handler</member>
				<member>? expression else</member>
				<member>? expression finally</member>
			</simplelist>
			
			<para role="xxx">The term "else" is not descriptive enough in this situation. Possible replacements: "onsuccess", "then"</para>
			
			<para role="process">Must contain more than just [try].</para>
			
			<section xml:id="node.exception-handler">
				<title>exception-handler</title>

				<simplelist role="layout">
					<member>boolean catch</member>
					<member>expression interface</member>
					<member>? identifier name</member>
					<member>expression result</member>
				</simplelist>
			</section>
			
			<programlisting>
try
	decl foo = getSomething()
observe( OutOfMemoryError )
	println "I'm not catching that!"
	//exception is noticed by this try-catch node, but not caught
	//the exception continues to rise out
catch( NullError )
	println "null error"
catch( FooError e )
	println "FooError: (e.message)"
catch( Error )
	println "unknown error"
catch( Exception )
	println "unknown exception"
observe
	println "how execution reach here? am not good with computer"
else
	println "no errors!"
	doSomeStuff() //don't catch errors from this in this node
finally
	cleanup(foo)

decl Status stat =
try
	doSomething()
	Statuses.SUCCESS
catch( NotSoBadError ) {
	Statuses.ERROR
observe
	println "something horrible not caught when trying to doSomething()"
			</programlisting>
		</section>
	</section>
	
	<section xml:id="always-producing-expresions">
		<title>Always producing expressions</title>
		
		<para>Expressions that, aside from e.g. exceptions, always produce when executed. These nodes, other than the and, nand, or, and nor nodes, are not intended to have side effects.</para>
		
		<section xml:id="boolean-logic">
			<title>Boolean logic</title>
			
			<section xml:id="node.and">
				<title>and</title>
				
				<para>Evaluates to false if either child expression evaluates to false.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is false, evaluate this node to false.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.nand">
				<title>nand</title>
				
				<para>Evaluates to true if either child expression evaluates to false.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is false, evaluate this node to true.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to the inverse of [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.or">
				<title>or</title>
				
				<para>Evaluates to true if either child expression evaluates to true.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is true, evaluate this node to true.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.nor">
				<title>nor</title>
				
				<para>Evaluates to false if either child expression evaluates to true.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is true, evaluate this node to false.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to the inverse of [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.xor">
				<title>xor</title>
				
				<para>Evaluates to true if the child expressions evaluate to different values.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [3] to Bool.</listitem>
					<listitem>If [2] and [4] are different, evaluate to true. Otherwise, evaluate to false.</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.xnor">
				<title>xnor</title>
				
				<para>Evaluates to true if the child expressions evaluate to the same value.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [3] to Bool.</listitem>
					<listitem>If [2] and [4] are the same, evaluate to true. Otherwise, evaluate to false.</listitem>
				</orderedlist>
			</section>
			
			<programlisting>
true and false
true xnor false
			</programlisting>
			
			<programlisting>
(and true false)
(xnor true false)
			</programlisting>
		</section>
		
		<section xml:id="node.array">
			<title>array</title>
			
			<simplelist role="layout">
				<member>nullable-type</member>
				<member>* expression element</member>
			</simplelist>
			
			<para>Evaluates to an object with interface array as the active interface. The object may implement other interfaces if they do not conflict with the array interface.</para>
			
			<para>Each [element] is cast to [interface]. If a cast error results, it raises out of the array node, so that the array node doesn't evaluate to anything.</para>
			
			<programlisting>
decl numbers = array Int { 1, 2, 3 }
numbers[2] = 5
each( print, numbers ) //prints: "125"
			</programlisting>
			
			<programlisting>
(decl auto numbers
	(array Int (1 2 3)))
([]= numbers 2 5)
(each print numbers)
			</programlisting>
		</section>
		
		<section xml:id="node.breed">
			<title>breed</title>
			
			<para>Creates a new object ("offspring") that encodes some or all of the information from the parent, and exposes that information through the specified interface. If an interface is not specified, the new object has same type as the parent, and should encode most or all of the information from the parent. If an interface is specified, the new object may be an exact copy of the parent object, or it may be of a completetly different form that encodes very little information from the parent object.</para>
			
			<para>This node can be used to copy a value, or to convert a value into a different type.</para>
			
			<simplelist role="layout">
				<member>expression parent</member>
				<member>? expression interface</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Execute [parent] and let parentValue be the product.</listitem>
				<listitem>Execute [interface] and let faceValue be the product. If [interface] is not given, let faceValue be the active interface of parentValue.</listitem>
				<listitem>Find parentValue's breeder that produces values with faceValue as the active interface. If such a breeder is not found, throw an error.</listitem>
				<listitem>Activate the found breeder.</listitem>
				<listitem>Produce the new value produced by the breeder.</listitem>
			</orderedlist>
			
			<programlisting>
decl Int num1 = 987
decl Int num2 = copy(num)
decl Rat num3 = (num to Rat)
			</programlisting>
			
			<programlisting>
(decl Int num1 987)
(decl Int num2 (copy num))
(decl Rat num3 (breed num Rat))
			</programlisting>
		</section>
		
		<section xml:id="node.bundle">
			<title>bundle</title>
			
			<para>A grouping of library references (import) and groups of declarations (plane).</para>
			
			<simplelist role="layout">
				<member>* import</member>
				<member>* scope-alteration alt</member>
				<member>+ plane</member>
			</simplelist>
			
			<para>The bundle node type is the type of the root node. No node can contain a bundle node. All Desal nodes that are executed in any way must be part of a complete Desal tree, which means having a bundle node as the root node.</para>
			
			<para>Implementations must not pass any arguments to the main function when executing a bundle as a standalone executable. Implementations should instead provide program arguments through a library which can be imported with the import node. Note that the program arguments are not required by this specification to be a sequence of strings.</para>
			
			<para>The result produced by executing a bundle node as a standalone executable may be converted as necesary to suit the containing environment. How this conversion is performed depends on the containing environment and the Desal implementation, and is not covered by this specification.</para>
			
			<para>When treating a bundle as a standalone executable:</para>
			
			<orderedlist role="exec">
				<listitem>Let globalScope be a new scope.</listitem>
				<listitem>Create the identikeys required by <link linkend="reserved-identikey-names">Reserved identikey names</link>.</listitem>
				<listitem>For each @@import, @@using, and @@expose child node, add the identikeys to globalScope specified by that node.</listitem>
				<listitem>Execute all declaration-first children of each plane together as required by <link linkend="handling-declare-first">Handling declare-first nodes</link>.</listitem>
				<listitem>Let mainKey be the identikey in globalScope that is associated with identifier "main". If such an identikey does not exist, throw an error.</listitem>
				<listitem>Let mainVal be the result of evaluating mainKey. If mainVal is null, throw an error.</listitem>
				<listitem>Call mainVal with no arguments and let rv be the result. If mainVal is not callable, throw an error. If mainVal does not have a callee that takes no arguments, throw an error.</listitem>
				<listitem>If rv is null, produce a value, with Int as the active interface, that encodes the number zero. Else if rv has an active interface that inherits from Int, downcast rv to Int and produce the result. Else if rv, with it's current active interface, can breed an Int, have rv breed an Int, and produce the result. Else throw an error.</listitem>
			</orderedlist>
			
			<para>When treating a bundle as a library:</para>
			
			<orderedlist role="exec">
				<listitem>Let globalScope be a new scope.</listitem>
				<listitem>Create the identikeys required by <link linkend="reserved-identikey-names">Reserved identikey names</link>.</listitem>
				<listitem>For each @@import, @@using, and @@expose child node, add the identikeys to globalScope specified by that node.</listitem>
				<listitem>Execute all declaration-first children of each plane together as required by <link linkend="handling-declare-first">Handling declare-first nodes</link>.</listitem>
				<listitem>Expose globalScope, in an immutable form, to the containing environment. How this is done depends on the containing enviornment and the Desal implementation, and is not covered by this specification.</listitem>
			</orderedlist>
			
			<para role="xxx">When acting as a standalone executable, need to specify what happens to exceptions that bubble all the way up to the bundle node. They are caught, an error message is output, and the bundle node returns some value, like 1. The bundle may expose to the containing environment additional information, depending on the enclosing environment and Desal implementation.</para>
			
			<para role="xxx">When acting as a standalone executable, what kind of errors should bundle by throwing? This is a problem that applies to many other nodes as well.</para>
			
			<para role="xxx">For when acting as a library, need a means of hiding/showing certain child namespaces/identikeys of the global namespace. For example, a bundle may have declarations in the global namespace and in a "private" namespace. The bundle should expose the declarations in the global namespace but hide the declarations in the private namespace. There has also been consideration of an "export" attribute/node that would expose specified identikeys, and all other identikeys would not be exposed.</para>
			
			<para role="xxx">The identikeys added to globalScope by import, using, and expose nodes should not be exposed to the containing environment when the bundle is acting as a library.</para>
		</section>
		
		<section xml:id="node.caller">
			<title>caller</title>
			
			<simplelist role="layout">
				<member>? expression interface</member>
				<member>identifier method name</member>
			</simplelist>
			
			<para>Creates a function that, when passed the type specified by [interface], calls the method named [method name] on the first argument with the rest of the arguments sent to it. It's purpose is to help with functional programming.</para>
			
			<programlisting>
interface Foo {
	func doStuff(Int, Int) Rat
}

decl Foo foo = getFoo()
decl func(Foo,Int,Int)Rat doStuffer = Foo::doStuff
println doStuffer(foo,3,7)

decl doStuffer2 = dyn::doStuff
println doStuffer2(foo,3,7)

//below all equilavent:
println Foo::doStuff(foo,3,7)
println dyn::doStuff(foo,3,7)
println foo.doStuff(3,7)
			</programlisting>
			
			<programlisting>
(decl Foo foo
	(getFoo))
(decl auto doStuffer
	(caller Foo doStuff))
(println (doStuffer foo 3 7))

(decl const doStuffer2
	(caller dyn doStuff))
(println (doStuffer2 foo 3 7))
			</programlisting>
		</section>
		
		<section xml:id="node.chain">
			<title>chain</title>
			
			<para>Creates a doubly-linked list from the provided elements.</para>

			<simplelist role="layout">
				<member>nullable-type</member>
				<member>* expression element</member>
			</simplelist>
			
			<para>Evaluates to a list, as if calling CList&lt; [interface] > ( [element], [element], ... )</para>
			
			<para>Each [element] is cast to [interface]. If a cast error results, it raises out of the list node, so that the list node doesn't evaluate to anything.</para>
			
			<programlisting>
decl numbers = chain Int { 1, 2, 3, 4, 5, 6 }
for number in numbers
	println number
			</programlisting>
			
			<programlisting>
(decl const numbers
	(chain Int (1 2 3 4 5 6)))
(for number numbers
	(println number))
			</programlisting>
		</section>
		
		<section xml:id="node.class">
			<title>class</title>
			
			<para>Evaluates to a value that, when called, produces other values. The interfaces supported by the produced values are implemented in the way specified by this class node. The active interface of the produced value is specified by this class.</para>
			
			<para>The active interface of the value that is produced when a class node is executed inherits from the master interface of the class. The master interface is the sum of all the root interfaces implemented by the class.</para>
			
			<para role="xxx">XML comments with important information</para>
			
			<simplelist role="layout">
				<!-- private and possibly public; can't be "call" or "callee" -->
				<member>* static-member static declaration</member>
				
				<!-- private -->
				<member>? block static constructor</member>
				
				<!-- public -->
				<member>* function static callee</member>
				
				<!-- public -->
				<member>* class-property static property</member>
				
				<!-- private and public -->
				<member>* function instance constructor</member>
				
				<!-- private -->
				<member>* declaration instance declaration</member>
				
				<!-- private and public -->
				<member>* interface-implementation</member>
			</simplelist>
			
			<para>XXX The static callees and static properties may not always be visible in the class node's scope. (An example of being visible is assigning the value produced by the class node to an identifier.) Should some identifier (e.g. "thisClass") be introduced that evaluates to the class's value? (e.g. thisClass.property = foo) Or should a general means of accessing the enclosing expression node's value be introduced? (e.g. thisValue.property = foo)</para>
			
			<para>The above is not a problem for interface implementations due to the "this" identikey being bound to the active instance.</para>
			
			<para>The children of class nodes can be grouped by several means.</para>
			
			<para>By count:</para>
			<table>
				<tbody>
					<tr>
						<th></th>
						<th>public</th>
						<th>private</th>
					</tr>
					<tr>
						<th>static - only 1</th>
						<td>callees, getters/setters, methods, interface-implementations</td>
						<td>static constructor, instance constructors, static declarations, instance methods</td>
					</tr>
					<tr>
						<th>instance - 1 per instance</th>
						<td></td>
						<td>instance declarations</td>
					</tr>
				</tbody>
			</table>
			
			<para>By scopes: (in scope means something can be accessed through a single identifier as a free identikey)</para>
			<simplelist>
				<member>static scope
					<simplelist>
						<member>public
							<simplelist>
								<member>defined by: static declarations (as properties and methods; must have access with get and/or set), static properties, instance constructors (as callees)</member>
								<member>in scope: (none)</member>
							</simplelist>
						</member>
						<member>private
							<simplelist>
								<member>defined by: static declarations, instance constructors (as functions bound to "construct")</member>
								<member>in scope: static constructor, callees, getters/setters, methods, expressions in static declarations</member>
							</simplelist>
						</member>
					</simplelist>
				</member>
				<member>instance scope
					<simplelist>
						<member>public
							<simplelist>
								<member>defined by: interface-implementations (or really, by the interface)</member>
								<member>in scope: (none)</member>
							</simplelist>
						</member>
						<member>private
							<simplelist>
								<member>defined by: instance declarations, instance methods</member>
								<member>in scope: expressions in instance declarations, instance methods, interface implementations, instance constructors</member>
							</simplelist>
						</member>
					</simplelist>
				</member>
			</simplelist>
			
			<para>Note: Instance scopes are children of the static scope.</para>
			
			<para role="process">Must have at least one interface-implementation. Including the interface-implementation nodes that are inherited by this class's child interface-implementation nodes, one and only one of the interface-implementation nodes must be specified as default.</para>
			
			<orderedlist role="exec">
				<listitem>Create scope, STATIC_SCOPE.</listitem>
				<listitem>Create an interface, CLASS_INTERFACE.</listitem>
				<listitem>Add instance constructors as free functions to STATIC_SCOPE.</listitem>
				<listitem>Add instance constructors as callees to CLASS_INTERFACE.</listitem>
				<listitem>Evaluate the declaration of every <link linkend="node.static-member">static-member</link> that has a <link linkend="node.declare-first">declare-first</link>, in the scope of STATIC_SCOPE. If the identikey-type of the <link linkend="node.declare-first">declare-first</link> is function, and it has access of get, add a method to CLASS_INTERFACE with the same function interface and name. Otherwise, create a property with a getter if declared public.</listitem>
				<listitem>Evaluate the declarations of the rest of the static-member nodes in the scope of STATIC_SCOPE, except for the static-member nodes with a declare-const-empty. Create properties as appropriate when the access nodes specify to do so.</listitem>
				<listitem>In the scope of STATIC_SCOPE, evaluate the static-member nodes that have declare-const-empty nodes. Create properties as appropriate when the access nodes specify to do so.</listitem>
				<listitem>Add the static callees as free functions in STATIC_SCOPE.</listitem>
				<listitem>Add the static callees and the static properties to CLASS_INTERFACE.</listitem>
				<listitem>Execute the static constructor.</listitem>
				<listitem>Seal the identikeys created by the declare-const-empty nodes, meaning don't allow their bound status to change.</listitem>
				<listitem>Create a value with CLASS_INTERFACE as the active interface.</listitem>
				<listitem>Evaluate this node to the above value.</listitem>
			</orderedlist>
			
			<para>When a constructor is called:</para>
			<orderedlist role="exec">
				<listitem>Create a scope, INSTANCE_SCOPE. Set STATIC_SCOPE as the parent scope.</listitem>
				<listitem>Evaluate all declare-first nodes in scope of INSTANCE_SCOPE.</listitem>
				<listitem>Execute the appropriate constructor.</listitem>
				<listitem>Evaluate the function-call that lead to this constructor being evaluated to a value with INSTANCE_SCOPE as the object and the default interface implementation of the class as the active interface implementation.</listitem>
				<listitem>Note: When the interface implementation is used, the value will pass the object into the interface implementation.</listitem>
			</orderedlist>
			
			<section xml:id="node.static-member">
				<title>static-member</title>
				
				<simplelist role="layout">
					<member>declaration decl</member>
					<member>? access</member>
				</simplelist>
				
				<para role="process">If the declaration declares a const identifier, and access is present, the access node must be declared get.</para>
				
				<para role="xxx">poorly named</para>
			</section>
			
			<section xml:id="node.declaration">
				<title>declaration</title>
				
				<para>declaration is a family of node types, like expression. The node types included in this family are:</para>
				
				<simplelist role="family-members">
					<member>declare-empty</member>
					<member>declare-assign</member>
					<member>declare-first</member>
					<member>declare-const-empty</member>
				</simplelist>
			</section>
			
			<section xml:id="node.declare-const-empty">
				<title>declare-const-empty</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>identikey-type</member>
				</simplelist>
				
				<para>Identifiers created by this node are always const. [identikey-type] must be value or function. The class's static constructor is allowed to assign values to static identifiers created by this node. If anthing tries to assign a value to an identikey create by this node, and the identikey is already bound to something, throw an error. The class's instance constructors are allowed to assign values to instance identifiers created by this node. An error results if identikeys produced by declare-const-empty nodes are dereferenced before being bound to anything.</para>
			</section>
	
			<section xml:id="node.interface-implementation">
				<title>interface-implementation</title>
				
				<simplelist role="layout">
					<member>* interface-implementation child implemenatation</member>
					<member>expression interface</member>
					<member>* function callee</member>
					<member>* named-function getter</member>
					<member>* named-function setter</member>
					<member>* named-function method</member>
					<member>boolean default</member>
				</simplelist>
			</section>
			
			<section xml:id="node.named-function">
				<title>named-function</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>function function</member>
				</simplelist>
			</section>
			
			<section xml:id="node.class-property">
				<title>class-property</title>
				
				<simplelist role="layout">
					<member>identifier</member>
					<member>identikey-type</member>
					<member>? function getter</member>
					<member>? function setter</member>
				</simplelist>
				
				<para role="process">Must have a getter and/or setter. If only identifier and identikey-type are given, an error results.</para>
			</section>
			
			<programlisting>
class Foo {
	...
	construct() {...}
	impl Bar {...}
}

interface of Foo {
	inherit Bar
	call() Bar
}

(Foo as Interface) == Bar //true
			</programlisting>
			
			<programlisting>
class Foo {
	...
	construct() {...}
	impl Bar default {...}
	impl define Bar2 {...} //the identifier "Bar2" is required
}

interface of Foo {
	inherit Bar + {{interface Bar2}}
	call() Bar
	get Interface Bar2
}

(Foo as Interface) == (Bar + Foo.Bar2) //true
			</programlisting>
		</section>

		<section xml:id="node.comprehension">
			<title>comprehension</title>
			
			<para>Used to build collections or generators. A slightly more general form of array/list comprehensions as found in other programming languages. Similar in nature to set-builder notation in mathematics.</para>
			
			<simplelist role="layout">
				<member>comprehension-type</member>
				<member>? expression destination collection</member>
				<member>expression source collection</member>
				<member>identifier element name</member>
				<member>? expression test</member>
				<member>? expression output</member>
			</simplelist>
			
			<para role="process">[comprehension-type] must be set to "provided" if [destination-collection] is present.</para>
			
			<section xml:id="node.comprehension-type">
				<title>comprehension-type</title>
				
				<para>Specifies one of: array, chain, generator, provided</para>
			</section>

			<programlisting>
decl foo = [2*x for x in L if x^2 > 3]
container: L
element name: x
test: x^2 > 3
output: 2*x

decl foo = [x in L if x^2 > 3]
container: L
element name: x
test: x^2 > 3
output: (implicit: x)

decl foo = [x in L]
container: L
element name: x
test: (implicit: true)
output: (implicit: x)

for o in [2*x for x in L if x^2 > 3] {
	println o
}
			</programlisting>
		</section>
		
		<section xml:id="node.dictionary">
			<title>dictionary</title>
			
			<simplelist role="layout">
				<member>nullable-type key type</member>
				<member>nullable-type value type</member>
				<member>* dictionary-entry</member>
			</simplelist>
			
			<section xml:id="node.dictionary-entry">
				<title>dictionary-entry</title>
				
				<simplelist role="layout">
					<member>expression key</member>
					<member>expression value</member>
				</simplelist>
			</section>
			
			<programlisting>
decl ages = dict (String, Int) {
	"Saray" : 12,
	"John" : 70,
	"Mike" : 23
}

for pair name, age in ages
	println name " " age
			</programlisting>
			
			<programlisting>
(decl const ages
	(dict String Int
		(("Saray" 12) ("John" 70) ("Mike" 23))))

(forpair name age ages
	(println name " " age))
			</programlisting>
		</section>
		
		<section xml:id="node.enum">
			<title>enum</title>
			
			<para>An enum is similar to an immutable dict.</para>
			
			<simplelist role="layout">
				<member>? nullable-type</member>
				<member>+ enum-entry</member>
			</simplelist>
			
			<para role="process">If [type] is not given, no enum entries can have a value. If [type] is given, all enum entries must have a value. Note that every enum entry has have a unique value. (XXX include restriction in execution instructions)</para>
			
			<section xml:id="node.enum-entry">
				<title>enum-entry</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>? expression value</member>
				</simplelist>
			</section>
			
			<para>If [type] is given:</para>
			<orderedlist role="exec">
				<listitem>Let EntryFace be a new interface that inherits from EnumDictEntry&lt;T> where T is specified by [type].</listitem>
				<listitem>For every [enum-entry], create a value with EntryFace as the active interface, where the "value" and "name" properties are those specified by the [enum-entry].</listitem>
				<listitem>Let ListFace be a new interface. For every [enum-entry], add a readonly property to ListFace with the type of EntryFace and a name specified by the [enum-entry].</listitem>
				<listitem>Let EnumFace be a new interface that inherits from Interface, EnumDict&lt;T, U>, and ListFace, where T is EntryFace and U is specified by [type].</listitem>
				<listitem>Let EnumInstance be a value with EnumFace as the active interface such that:
					<simplelist>
						<member>the value given from getting a property of ListFace is the value created in step 2 that is associated with the same [enum-entry] as the property</member>
						<member>the Interface implementation is EntryFace, i.e. EnumInstance cast to Interface is EnumFace</member>
					</simplelist>
				</listitem>
				<listitem>Produce EnumInstance.</listitem>
			</orderedlist>
			
			<para>If [type] is not given:</para>
			<orderedlist role="exec">
				<listitem>Let EntryFace be a new interface that inherits from EnumEntry.</listitem>
				<listitem>For every [enum-entry], create a value with EntryFace as the active interface, where the "name" property is that specified by the [enum-entry].</listitem>
				<listitem>Let ListFace be a new interface. For every [enum-entry], add a readonly property to ListFace with the type of EntryFace and a name specified by the [enum-entry].</listitem>
				<listitem>Let EnumFace be a new interface that inherits from Interface, Enum&lt;T>, and ListFace, where T is EntryFace.</listitem>
				<listitem>Let EnumInstance be a value with EnumFace as the active interface such that:
					<simplelist>
						<member>the value given from getting a property of ListFace is the value created in step 2 that is associated with the same [enum-entry] as the property</member>
						<member>the Interface implementation is EntryFace, i.e. EnumInstance cast to Interface is EnumFace</member>
					</simplelist>
				</listitem>
				<listitem>Produce EnumInstance.</listitem>
			</orderedlist>
			
			<para>Note that the sections specifying Enum, EnumDict, EnumEntry, and EnumDictEntry have additional requirements on the behavior of instances of these interfaces.</para>
			
			<screen>
<![CDATA[
enum Animal {
	dog, cat, fish, parrot, ferret, gerbil, hamster
}

interface EntryFace
	inherit EnumEntry

interface ListFace
	get EntryFace dog
	get EntryFace cat
	get EntryFace fish
	get EntryFace parrot
	get EntryFace ferret
	get EntryFace gerbil
	get EntryFace hamster

interface EnumFace
	inherit Interface
	inherit Enum<EntryFace>
	inherit EnumList

Animal a = Animal.dog
Animal b = Animal.fromName("cat")
println Animal.size //assuming size is specified by Collection<T>

for animal in Animal
	println animal.name

activeInterface(Animal) == Interface + Enum<EntryFace> + EnumList
(Animal as Interface) == EntryFace
]]>
			</screen>
			
			<programlisting>
(enum Animal
	(dog cat fish parrot ferret gerbil hamster)

(for animal Animal
	(println animal.name))
			</programlisting>
		</section>
		
		<section xml:id="node.extract-member">
			<title>extract-member</title>
			
			<simplelist role="layout">
				<member>expression source</member>
				<member>identifier member name</member>
			</simplelist>
			
			<para>Retrieves the a method or the value of a property from the value specified by [source]. If the active interface of the value specified by [source] does not have a property or method with the specified name, throw an exception.</para>
			
			<programlisting>
println( alpha.beta )
alpha.doStuff()
			</programlisting>
			
			<programlisting>
(println alpha.beta)
(alpha.doStuff)
			</programlisting>
		</section>

		<section xml:id="node.function">
			<title>function</title>
			
			<simplelist role="layout">
				<member>* parameter</member>
				<member>? nullable-type return info</member>
				<member>expression body</member>
			</simplelist>

			<para role="xxx">Specify barrier, which is like the kind of barrier that is in class nodes. Compare this kind of barrier to scope barriers -- nodes that "have scope". The [body] node is not executed when this node is executed, but it may be executed after this node has executed.</para>
			
			<para>If [return info] is not present, the function does not return anything. I.e., it does not produced a value when call.</para>
			
			<para>When this node is executed, it produces a value with a function interface as the active interface. Only the [parameter] node and [return info]'s [interface] nodes are executed at this time. When the resultant value is called, the [body] node is executed in the scope of this function node.</para>
			
			<programlisting>
decl square = func(a) {
	a * a
}

println( square(2) )
			</programlisting>
			
			<programlisting>
(decl const square
	(function (a) void
		(* a a)))

(println (square 2))
			</programlisting>
			
			<programlisting>
decl square = {a|a*a}
println( square(2) )
			</programlisting>
			
			<programlisting>
println( {a|a*a} 2 )
			</programlisting>
		</section>
		
		<section xml:id="node.function-interface">
			<title>function-interface</title>
			
			<simplelist role="layout">
				<member>? expression template-argument-count</member>
				<member>* parameter</member>
				<member>? nullable-type return info</member>
			</simplelist>
			
			<programlisting>
println( func(Int,Int)Rat )
			</programlisting>
			
			<programlisting>
(println (funcface (Int Int) Rat))
			</programlisting>
		</section>
		
		<section xml:id="node.generator">
			<title>generator</title>

			<para>Produces a value that implements an instantiation of the Generator generic interface.</para>
			
			<simplelist role="layout">
				<member>? nullable-type</member>
				<member>expression body</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<para>If [type] is not given, the generator does not produce. (The generator could still be useful for producing side effects.)</para>
			
			<programlisting>
decl foo = generator {
	decl Int i = 2
	while i lt 5 {
		yield i
		i++
	}
}

for i in foo {
	print i " "
}

prints: '2 3 4 '

interface of foo == Generator&lt;Int>
			</programlisting>
			
			<programlisting>
(decl const foo
	(generator
		(decl Int i 2)
		(while (lt i 5)
			(block
				(yield i)
				(++ i)))))

(forin i foo
	(print i " "))
			</programlisting>

			<programlisting>
decl foo = func(Int a, Int b) Generator&lt;Int> {
	return generator {
		decl Int i = a
		while i lt b {
			yield i
			i++
		}
	}
}

for i in foo(2, 5) {
	print i " "
}

prints: '2 3 4 '
			</programlisting>
			
			<programlisting>
decl foo = genfunc(Int a, Int b) Int {
	decl Int i = a
	while i &lt; b {
		yield i
		i++
	}
}

for i in foo(2, 5) {
	print i " "
}

prints: '2 3 4 '
			</programlisting>
		</section>
		
		<section xml:id="node.generic-class">
			<title>generic-class</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameter</member>
				<member>class</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the class node.</para>
		</section>
		
		<section xml:id="node.generic-function">
			<title>generic-function</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameter</member>
				<member>function</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the function node.</para>
			
			<programlisting>
func larger&lt;T>(T a, T b) T {
	if a lt b
		return b
	return a
}

println larger(2, 7) //prints "7"
			</programlisting>
			
			<programlisting>
(declfirst auto larger
	(genericfunction (T) ((T a) (T b)) T
		(if (lt a b)
			(return b))
		(return a)))

(println (larger 2 7))
			</programlisting>
		</section>
		
		<section xml:id="node.generic-interface">
			<title>generic-interface</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameter</member>
				<member>interface</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the interface node.</para>
			
			<programlisting>
interface List&lt;T> {
	func addFront(T)
	func addBack(T)
	func removeFront() T
	func removeBack() T
}

decl List&lt;Int> list = getNumbers()
list.addFront(2)
list.addBack(3)
list.addFront(1)
println list.removeFront() //prints "1"
println list.removeBack() //prints "3"
			</programlisting>
			
			<programlisting>
(declfirst auto List
	(genericinterface (T)
		(func addFront (T) void)
		(func addBack (T) void)
		(func removeFront () T)
		(func removeBack () T)))

(decl List&lt;Int> list
	(getNumbers))
(list.addFront 2)
(list.addBack 3)
(list.addFront 1)
(println (list.removeFront))
(println (list.removeBack))
			</programlisting>
		</section>
		
		<section xml:id="node.identifier">
			<title>identifier</title>
			
			<para>Base/terminal node.</para>
			
			<orderedlist role="exec">
				<listitem>Let ident be the identifier specified by this node.</listitem>
				<listitem>Let scope be the current scope.</listitem>
				<listitem>If scope has an identikey that is associated with ident, let scope be the parent scope of scope. If scope has no parent scope, throw an error. Continue moving through parent scopes until an identikey associated with ident is found. Let key be this identikey.</listitem>
				<listitem>If key is a function identikey, find parent function identikeys with that name, but with different types, and merge all the functions together. (XXX elaborate)</listitem>
				<listitem>If key is bound to a value, produce the value that key is bound to. If key has been declared that it can be bound to values, but it is currently not bound to anything, return null.</listitem>
				<listitem>If key is bound to a namespace, throw an error.</listitem>
			</orderedlist>
			
			<programlisting>
println( foo )
			</programlisting>
			
			<programlisting>
(println foo)
			</programlisting>
		</section>
		
		<section xml:id="node.instantiate-generic">
			<title>instantiate-generic</title>
			
			<para role="xxx">Need to decide how to include type information. Type value, or type node? Write down and compare pros and cons. (Some related info in "type occurrence.txt")</para>
			
			<simplelist role="layout">
				<member>expression generic</member>
				<member>+ argument</member>
			</simplelist>
			
			<programlisting>
decl List&lt;Int> numbers
			</programlisting>
			
			<programlisting>
(decl List&lt;Int> numbers)
			</programlisting>
		</section>
		
		<section xml:id="node.integer">
			<title>integer</title>
			
			<para>Base node. Evaluates to an object reference with BigInt as the active interface. The object may implement other interfaces if they do not conflict with the BigInt interface. Must not implement the LimInt interface.</para>
			
			<programlisting>
println( 789 )
			</programlisting>
			
			<programlisting>
(println 789)
			</programlisting>
		</section>
		
		<section xml:id="node.interface">
			<title>interface</title>
			
			<simplelist role="layout">
				<member>* expression inheritee</member>
				<member>* statused-member</member>
			</simplelist>
			
			<section xml:id="node.statused-member">
				<title>statused-member</title>
				
				<simplelist role="layout">
					<member>member-status</member>
					<member>interface-member</member>
				</simplelist>
			</section>
			
			<section xml:id="node.member-status">
				<title>member-status</title>
				
				<para>Base node. Specifies "new", "normal", or "deprecated".</para>
			</section>
			
			<section xml:id="node.interface-member">
				<title>interface-member</title>
				
				<para>Supertype. Includes convertor, callee, property, and method.</para>
			</section>
			
			<section xml:id="node.convertor">
				<title>convertor</title>
				
				<simplelist role="layout">
					<member>? expression interface</member>
				</simplelist>
				
				<para>Specifies that implementations of that interface can be converted into the specified type. Or, if [interface] isn't given, that the value can be copied.</para>
			</section>
			
			<section xml:id="node.callee">
				<title>callee</title>
				
				<simplelist role="layout">
					<member>* parameter</member>
					<member>? nullable-type return info</member>
				</simplelist>
				
				<para>If [return info] is not present, the callee does not produce anything when called.</para>
			</section>
			
			<section xml:id="node.property">
				<title>property</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>nullable-type</member>
					<member>access</member>
				</simplelist>
			</section>
			
			<section xml:id="node.method">
				<title>method</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>expression interface</member>
				</simplelist>
			</section>
			
			<section xml:id="node.access">
				<title>access</title>
				
				<para>Access nodes must specify one of three access levels: only reading, only writing, or both reading and writing.</para>
			</section>
		</section>
		
		<section xml:id="node.implements">
			<title>implements</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>expression interface</member>
			</simplelist>
			
			<para>Returns a bool object reference to the true or false objects. True if [object] implements [interface], false otherwise.</para>
			
			<programlisting>
if (o impls Foo)
	(o as Foo).propOfFoo()
			</programlisting>
			
			<programlisting>
(if (impls o Foo)
	((cast o Foo).propOfFoo))
			</programlisting>
		</section>
		
		<section xml:id="node.rational">
			<title>rational</title>
			
			<para>Base node. Evaluates to an object with BigRat as the active interface. The object may implement other interfaces if they do not conflict with the BigRat interface. Must not implement the LimRat interface.</para>
			
			<programlisting>
println( 123.456 )
			</programlisting>
			
			<programlisting>
(println 123.456)
			</programlisting>
		</section>
		
		<section xml:id="node.set-property">
			<title>set-property</title>

			<simplelist role="layout">
				<member>expression source</member>
				<member>identifier property name</member>
				<member>expression value</member>
			</simplelist>
			
			<para>Sets the value of a property. If the active interface of the value does not have a property with the specified name, or the property cannot be set, an error results. Evaluates to the value given by [value].</para>
			
			<programlisting>
alpha.beta = "gamma"
			</programlisting>
			
			<programlisting>
(= alpha.beta "gamma")
			</programlisting>
		</section>

		<section xml:id="node.string">
			<title>string</title>
			
			<para>string nodes consist of text</para>
			
			<para>strings are expressions</para>
			
			<para>Base node. Evaluates to an object with interface string as the active interface. The object may implement other interfaces if they do not conflict with the string interface.</para>
			
			<programlisting>
println( "this is a string" )
			</programlisting>
			
			<programlisting>
(println "this is a string")
			</programlisting>
		</section>
	</section>
</chapter>