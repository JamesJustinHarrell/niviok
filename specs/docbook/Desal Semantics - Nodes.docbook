<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="node-types">
	<title>Node types</title>

	<para>This chapter describes the various types of nodes.</para>
	
	<section xml:id="base-node-types">
		<title>Base nodes</title>
		
		<para>These node types do not contain child nodes, and are thus the only nodes that must encode information themselves (as opposed to containing child nodes which together provide information).</para>
		
		<simplelist>
			<member linkend="node.access">access</member>
			<member linkend="node.boolean">boolean</member>
			<member linkend="node.direction">direciton</member>
			<member linkend="node.identifier">identifier</member>
			<member linkend="node.identikey-category">identifier-category</member>
			<member linkend="node.integer">integer</member>
			<member linkend="node.rational">rational</member>
			<member linkend="node.string">string</member>
		</simplelist>
	</section>
	
	<section xml:id="tree-node-layout-key">
		<title>Tree node layout key</title>
		
		<para>This section describes how the layout of a node type is represented in this specification.</para>
		
		<para>The layout for a node type is represented in this specification as a list of items. Each item represents a child node or multiple child nodes with the same meaning. Nodes represented by different items are considered to have different meaning.</para>
		
		<para>Each item in these lists first specifies how many child nodes with that meaning may appear, or it says nothing about the number, which means there must be one (and only one). The ways of representing these amounts is described below.</para>
		
		<variablelist>
			<varlistentry>
				<term>?</term>
				<listitem>0 or 1</listitem>
			</varlistentry>
			<varlistentry>
				<term>*</term>
				<listitem>0 or more</listitem>
			</varlistentry>
			<varlistentry>
				<term>+</term>
				<listitem>1 or more</listitem>
			</varlistentry>
			<varlistentry>
				<term>2</term>
				<listitem>2 (used only for the <link linkend="node.enum">enum</link> node)</listitem>
			</varlistentry>
		</variablelist>
		
		<para>Next comes the name of a node type. The child node represented by that list item must be of that type, unless the type is Expression or Statement, in which case the child node's type must be a member of the Expression on Statement family, respectively. See section XXX for more information.</para>
		
		<para>Lastly comes a label for referring to the child nodes with that meaning. These labels carry no semantic information, and are only a means used to refer to specific nodes. The meaning of child nodes can certainly be represented by other means. However, people creating representations for Desal trees are encouraged to at least consider using these same labels when it makes sense to do so.</para>
	</section>
	
	<section xml:id="nonexecuted-nodes">
		<title>Nonexecuted nodes</title>
		
		<para>These nodes cannot be executed (and thus also cannot be evaluated).</para>
		
		<section xml:id="node.argument">
			<title>argument</title>
			
			<simplelist role="layout">
				<member>? identifier parameter name</member>
				<member>? expression value</member>
			</simplelist>
			
			<programlisting>
func doSomething(Int a = 1, Int b = 2, Int c = 3, Int d) {...}
doSomething(7, default, default, 8)
doSomething(7, c = default, 8)
			</programlisting>
		</section>
		
		<section xml:id="node.boolean">
			<title>boolean</title>
			
			<para>Base node. Must specify either true or false.</para>
			
			<para>Cannot be evaluated because that would conflict with the prevalent "true" and "false" identifiers. Use "true" and "false" identifiers for expressions instead.</para>
		</section>
		
		<section xml:id="node.bundle">
			<title>bundle</title>
			
			<simplelist role="layout">
				<member>* import</member>
				<member>* alias</member>
				<member>+ plane</member>
			</simplelist>
			
			<para>The bundle node type is the type of the root node. No node can contain an bundle node. All Desal nodes that are executed in any way must be part of a complete Desal tree, which means having an bundle node as the root node.</para>
			
			<para role="xxx">Program arguments are no longer passed to the main function, because developers should have a choice of accessing program arguments in different ways, and some implementations may not have program arguments, or have non-string program arguments, etc. The old way just isn't flexible enough. Implementations should give program arguments through some API instead of passing them to the main function.</para>

			<orderedlist role="exec">
				<listitem>1. Create the identikeys specified in section XXX to this node's scope.</listitem>
				<listitem>2. Create any implementation-specific identikeys.</listitem>
				<listitem>3. Execute each child identifier-const node in order.</listitem>
			</orderedlist>
			
			<para>When the complete Desal tree is treated as a standalone program, section xxx applies. Otherwise, besides layout and setup, the abilities and behavior of the bundle node is implementation-specific, and execution or evaluation of Desal nodes may occur directly, without going through the bundle node.</para>
			
			<para>The section XXX mentioned above should specify a value bound to "main" with a callee that takes no arguments and either returns nothing or returns an Int.</para>
		</section>
		
		<section xml:id="node.direction">
			<title>direction</title>
			
			<para>Specifies the direction of a function parameter, one of: in, in-mutable, out, in-out, in-mutable-out</para>
			
			<para>A value passed to a function as an "in" parameter will not be mutated by the function. This means if the function uses the value in ways that may mutate the value, the value will be copied. If an action in the function may mutate the value, and the value does not declare a copy converter, an error results.</para>
			
			<para>Instances where the value may be mutated include when the interface of the value does not provide opacity information and the function calls a method, or if the interface does provide opacity information but the function calls a mutator method, or if the value is passed to another function as an in-mutable or in-mutable-out parameter.</para>
				
			<programlisting>
func alpha(in Int num) {
	println num
}

func beta(in-mutable Int num) {
	num += 567
}

func gamma(out Int num) {
	//num not currently assigned to anything
	num = 987
}

func delta(in-out Int num) {
	println num
	num = 1001
}

func epsilon(in-mutable-out Int num) {
	num += 55555
	num = 19591
}

Int num = 123
alpha(num)
beta(num) //value mutated
gamma(num) //num assigned to different value
delta(num) //num assigned to different value
epsilon(num) //value mutated and num assigned to different value
			</programlisting>
		</section>
		
		<section xml:id="node.identikey-category">
			<title>identikey-category</title>
			
			<para>specifies one of: namespace, dynamic, automatic, strict, function</para>
			
			<para>See the <link linkend="identikeys">section on identikeys</link>.</para>
		</section>
		
		<section xml:id="node.identikey-type">
			<title>identikey-type</title>
			
			<simplelist role="layout">
				<member>identikey-category</member>
				<member>? expression interface</member>
				<member>? boolean constant</member>
			</simplelist>

			<para role="process">[constant] must not be specified if identikey-category is namespace. [constant] must be false (or not specified) if category is dynamic. The interface must be given if the category is strict. The interface must not be given if the category is namespace, dynamic, or automatic.</para>

			<para>If the category is strict, the active interface of any value bound to the identikey must be that interface. If the category is function, and the interface is given, functions bound to the identikey must specify that interface as the return type.</para>
			
			<para>The default value of [constant] is false. If [constant] is true, the identifier thereafter always refers to the same value. The identifier cannot be bound to a different value, or unbound. The active interface also cannot be changed.</para>
			
			<programlisting>
Int a = 3
func Int a = func()Int { return 3 }
			</programlisting>
		</section>
		
		<section xml:id="node.import">
			<title>import</title>
			
			<simplelist role="layout">
				<member>string library</member>
				<member>? identifier library alias</member>
				<member>* alias-member</member>
			</simplelist>
			
			<para>Assigns values from libraries to global identikeys.</para>
			
			<programlisting>
import "XmlLib" as Xml
/*
library: "XmlLib"
library alias: Xml */

from "XmlLib" import XmlDocument as Doc
/*
library: "XmlLib"
library alias: (not given)
alias-member: XmlDocument, Doc */

from "XmlLib" as Xml import XmlDocument as Doc
/*
library: "XmlLib"
library alias: Xml
alias-member: XmlDocument, Doc */

from "XmlLib" as Xml import XmlReader, XmlDocument as Doc, XmlElement
/*
library: "XmlLib"
library alias: Xml
alias-member: XmlReader
alias-member: XmlDocument, Doc
alias-member: XmlElement */

from "XmlLib" as Xml import
	XmlReader,
	XmlDocument as Doc,
	XmlElement
			</programlisting>
			
			<section xml:id="node.alias-member">
				<title>alias-member</title>
				
				<simplelist role="layout">
					<member>identifier target</member>
					<member>? identifier new name</member>
				</simplelist>
			</section>
		</section>
		
		<section xml:id="node.import-all">
			<title>import-all</title>
			
			<simplelist role="layout">
				<member>string library</member>
			</simplelist>
			
			<para>Imports every identikey in the library.</para>
			
			<programlisting>
import all from "XmlLib"
//library: "XmlLib"
			</programlisting>
		</section>
		
		<!-- xxx remove
		<section xml:id="node.namespace-reference">
			<title>namespace-reference</title>
			
			<simplelist role="layout">
				<member>+ identifier</member>
			</simplelist>
			
			<para>Used to refer to a namespace that is the child of another namespace.</para>
		</section>
		-->

		<section xml:id="node.parameter">
			<title>parameter</title>
			
			<para>A function parameter.</para>
			
			<simplelist role="layout">
				<member>direction</member>
				<member>? boolean nullable</member>
				<member>? expression interface</member>
				<member>identifier name</member>
				<member>? expression default value</member>
			</simplelist>
			
			 <para role="process">[nullable] must not be specified if direction is "out".</para>
		</section>
				
		<section xml:id="node.plane">
			<title>plane</title>
			
			<simplelist role="layout">
				<member>* alias</member>
				<member>+ declare-first</member>
			</simplelist>
			
			<para>This node has scope, but only private identifiers are bound to it. Public and exported identifiers are bound to the scope of the bundle node.</para>
			
			<para>Planes aren't statements because the declare-first nodes make rely on declare-first nodes in other planes, so all the declare-first nodes in a single plane can't just be executed all together.</para>
		</section>
	</section>

	<section xml:id="node.statement">
		<title>Statement nodes</title>
		
		<section xml:id="iteration">
			<title>Iteration</title>

			<section xml:id="node.do-while">
				<title>do-while</title>
				
				<simplelist role="layout">
					<member>block action</member>
					<member>expression test</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
do {
	something()
} while test()
				</programlisting>
			</section>
			
			<section xml:id="node.do-times">
				<title>do-times</title>
				
				<simplelist role="layout">
					<member>expression times</member>
					<member>block action</member>
					<member>? expression test</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
do 8 times {
	something()
}

do 8 times {
	something()
} while test()
				</programlisting>
			</section>
			
			<section xml:id="node.for-key">
				<title>for-key</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression key interface</member>
					<member>identifier name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<orderedlist role="exec">
					<listitem>1. Call getKeyIterator on [container].</listitem>
					<listitem>2. Call getNext on [1]. If an exception is thrown with an active interface of GeneratorDone, swallow it and end execution. If anything else is thrown, follow normal exception rules.</listitem>
					<listitem>3. Create a scope.</listitem>
					<listitem>4. Assign [2] to [identifier] in [3].</listitem>
					<listitem>5. Execute [block] with scope [3].</listitem>
					<listitem>6. Go to step 2.</listitem>
				</orderedlist>
				
				<programlisting>
for key x in foo
	doStuff(x)

for key Int x in foo
	doStuff(x)
				</programlisting>
			</section>
			
			<section xml:id="node.for-pair">
				<title>for-pair</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression key interface</member>
					<member>identifier key name</member>
					<member>? expression value interface</member>
					<member>identifier value name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
for pair x y in coords
	drawPoint(x, y)

for pair Int x, Int y in coords
	drawPoint(x, y)
				</programlisting>
			</section>

			<section xml:id="node.for-manual">
				<title>for-manual</title>
				
				<para>Used for manual iteration, as opposed to letting the Desal implementation deal with iteration, like with a for-value node.</para>
				
				<simplelist role="layout">
					<member>* statement initializers</member>
					<member>? expression test</member>
					<member>* statement post actions</member>
					<member>? block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<para>The initializers are executed before iteration begins. Test is evaluated before each iteration. Post actions are executed after each iteration.</para>
				
				<screen>
initializers

test
action
post actions

test
action
post actions

...

test
action
post actions

test

(end of loop)
				</screen>
				
				<programlisting>
for( Int i = 0 ; i &lt; container.length ; i++ ) {
	println container[i]
}

for( Iterator&lt;Int> iterator = container.getIterator() ;
iterator.hasMore? ; iterator.moveNext() ) {
	println iterator.current
}
				</programlisting>
			</section>
			
			<section xml:id="node.for-range">
				<title>for-range</title>
				
				<simplelist role="layout">
					<member>? identifier name</member>
					<member>expression start</member>
					<member>expression limit</member>
					<member>boolean inclusive</member>
					<member>? expression test</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<para>[inclusive] determines whether the loop should iterate one last time if the iteration value is equal to the limit, and it is false by default.</para>
				
				<programlisting>
for 0 to 100
	println "test"

for x from 0 to 100
	println x

for x from 0 to 100 inclusive
	println x

for 0 to string.length while not container.full
	container.push( string.unshift!() )

for x from 0 to 100 while not foo.done?
	foo.runTest(x)
				</programlisting>
			</section>
			
			<section xml:id="node.for-value">
				<title>for-value</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression value interface</member>
					<member>identifier name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
for name in names
	println name

for String name in names
	println name
				</programlisting>
			</section>
			
			<section xml:id="node.loop">
				<title>loop</title>
				
				<simplelist role="layout">
					<member>block</member>
				</simplelist>
				
				<para>Executes block continuously. Can only be exited by statements in the block such as break and return.</para>
			
				<programlisting>
loop {
	Event event = getNextEvent()
	switch( event ) {
		case Events.QUIT :
			break
	}
}
				</programlisting>
			</section>
			
			<section xml:id="node.while">
				<title>while</title>
				
				<simplelist role="layout">
					<member>expression test</member>
					<member>? block</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
while printNext()

while container.hasMore?
	print container.next
				</programlisting>
			</section>
		</section>
		
		<section xml:id="node.block">
			<title>block</title>
			
			<simplelist role="layout">
				<member>* statement statements</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<para>Note: This node type is different from the Dextr concept of blocks. To differentiate between the two, nodes of this type can be called "node blocks", "statement blocks", or "semantic blocks". The syntactic construct can be called "Dextr blocks" or "syntactic blocks".</para>
		</section>
		
		<section xml:id="node.break">
			<title>break</title>
			
			<simplelist role="layout">
				<member>? identifier label</member>
			</simplelist>
		</section>
		
		<section xml:id="node.conditional-block">
			<title>conditional-block</title>
			
			<simplelist role="layout">
				<member>expression test</member>
				<member>* statement statements</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<para role="process">An error results if the implementation knows the test will never evaluate to a value with Bool as the active interface.</para>
			
			<para role="exec">Evaluate the test. If the active interface isn't Bool, raise an error. If it is true, execution the actions in order.</para>
			
			<programlisting>
if not foo.isSetup? {
	foo.setup()
}
			</programlisting>
		</section>
		
		<section xml:id="node.continue">
			<title>continue</title>
			
			<simplelist>
				<member>? identifier label</member>
			</simplelist>
		</section>
		
		<section xml:id="node.declare-empty">
			<title>declare-empty</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
			</simplelist>
			
			<para role="process">The identikey-type must not be constant.</para>
			
			<para>Creates an identikey in the parent scope with the specified type. After this node executes, the produced identikey does not yet point to any values.</para>

			<programlisting>
decl func Int foo
foo = func()Int { return 3 }
foo = func(Int a)Int { return a * 2 }
print foo() //prints 3
print foo(2) //prints 4

//xxx does this produce error or replace?
foo = func()Int { return 5 }
			</programlisting>

			<programlisting>
decl func()Int foo
foo = func()Int { return 3 }
print foo() //prints 3
foo = func()Int { return 5 }
print foo() //prints 5
foo = func(Int a)Int { return a * 2 } //error - interface mismatch
			</programlisting>
		</section>
		
		<section xml:id="node.declare-first">
			<title>declare-first</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
				<member>expression value</member>
			</simplelist>
			
			<para role="process">The identikey-type must be constant, and must have a category of automatic, strict, or function.</para>
			
			<para>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</para>
			
			<para>When a block contains declare-first nodes, the declare-first nodes are executed before the other statements in the block are executed. The value expressions of declare-first nodes may depend on the values of other declare-first nodes in the same block. For example, two interfaces could reference each other.</para>
			
			<programlisting>
decl-first auto Foo = interface {
	get Bar bar
}

decl-first auto Bar = interface {
	get Foo foo
}

Foo foo = ...
foo.bar.foo.bar...
			</programlisting>
		</section>
		
		<section xml:id="node.enum">
			<title>enum</title>
			
			<para>An enum is similar to an immutable dict.</para>
			
			<para role="xxx">clean up</para>
			
			<screen>
<![CDATA[

interface<T, U> Enum
	inherit Collection<T>
	r Int size
	func key(String str) T
	func fromValue(U val) T

interface<T> EnumElement
	inherit Stringable
	r T value

interface Stringable
	r String str

Enum and EnumElement cannot be implemented manually.

These two interfaces are used in the examples below:

interface {{AnimalInterface}}
	inherit EnumElement<Int>

interface {{Properties}}
	inherit Enum< {{AnimalInterface}}, Int >
	r {{AnimalInterface}} dog
	r {{AnimalInterface}} cat
	r {{AnimalInterface}} fish
	r {{AnimalInterface}} parrot
	r {{AnimalInterface}} ferret
	r {{AnimalInterface}} gerbil
	r {{AnimalInterface}} hamster

When [value-type] is not given:
	no entries can have values
	the value property of EnumEntry will return null
	the fromValue method of Enum will return null

When a [value-type] is given, all entries must have values.

Multiple identifiers can be assigned the same value. In such a case, each identifier will refer to the same object, and the str property of that object will give the first identifier as a string.

layout:
	identifier [interface]
	? expression [value-type]
	boolean [expose]
	(+ identifier [name]) | (+ enum-entry [element])

enum-entry layout:
	identifier [name]
	? expression [value]

----- example 1

enum Animal {
	dog, cat, fish, parrot, ferret, gerbil, hamster
}

Animal a = Animal.dog
Animal b = Animal["cat"]
println Animal.size

for animal in Animal
	println animal.str " " animal.value

----- example 2

enum Animal expose {
	DOG, CAT, FISH, PARROT, FERRET, GERBIL, HAMSTER
}

Animal a = Animal.DOG
Animal b = Animal["CAT"]
Animal c = FISH
println Animal.size

for animal in Animal
	println animal.str " " animal.value

-----

typeOf(Animal) == Interface + {{Properties}}
(Animal as Interface) == {{AnimalInterface}}
typeOf(DOG) == typeOf(Animal.DOG)

]]>
			</screen>
		</section>
		
		<section xml:id="node.if-else">
			<title>if-else</title>
			
			<simplelist role="layout">
				<member>+ conditional-block possible actions</member>
				<member>? block default action</member>
			</simplelist>
			
			<para>Evaluates the test of each possible action until it finds one that evaluates to true,  and executes the action associated with that possible action. If none of the possible actions have a test that evaluates to true, and a default action is specified, execute the default action. If test of any of the possible actions evaluates to a value that doesn't have Bool as the active interface, an error results.</para>
		</section>
		
		<section xml:id="node.labeled-statement">
			<title>labeled-statement</title>
			
			<simplelist role="layout">
				<member>identifier label</member>
				<member>statement</member>
			</simplelist>
			
			<para role="process">The statement must be an iteration node, a block node, a conditional-block node, an if-else node, or a select node.</para>
			
			<programlisting>
func setupCell(Int searchID) {
	decl Cell wantedCell
	
	outer: for row in table {
		for cell in row {
			if cell.ID == searchID {
				wantedCell = cell
				break outer
			}
		}
	}
	
	if wantedCell != null {
		doSomething(wantedCell)
	}
}
			</programlisting>
		</section>
		
		<section xml:id="node.return">
			<title>return</title>
			
			<simplelist role="layout">
				<member>? expression</member>
			</simplelist>
			
			<para>Function call ends and evaluates to expression.</para>
		</section>
		
		<section xml:id="node.select">
			<title>select</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>* case</member>
				<member>? block else</member>
			</simplelist>
			
			<section xml:id="node.case">
				<title>case</title>
				
				<simplelist role="layout">
					<member>? boolean fall</member>
					<member>+ expression</member>
					<member>block</member>
				</simplelist>
			</section>
			
			<programlisting>
select( event.type ) {
	case Events.QUIT {
		return
	}
	case Events.FOO, Events.BAR, Events.MAZ {
		//no action
	}
	else {
		throw Error("unknown event type")
	}
}
			</programlisting>
		</section>
		
		<section xml:id="node.try-catch">
			<title>try-catch</title>
			
			<simplelist role="layout">
				<member>block try</member>
				<member>* catch</member>
				<member>? block else</member>
				<member>? block finally</member>
			</simplelist>
			
			<para role="process">If a finally block is not given, must have at least one catch.</para>
			
			<section xml:id="node.catch">
				<title>catch</title>
			
				<simplelist role="layout">
					<member>expression interface</member>
					<member>? identifier name</member>
					<member>block</member>
				</simplelist>
			</section>
			
			<programlisting>
try {
	decl foo = doSomething()
}
catch( NullError ) {
	println "null error"
}
catch( FooError e ) {
	println "FooError: $(e.message)"
}
catch( Error ) {
	println "unknown error"
}
catch( Exception ) {
	println "unknown exception"
}
else {
	println "no errors!"
}
finally {
	cleanup(foo)
}
			</programlisting>
		</section>
		
		<section xml:id="throw">
			<title>throw</title>
			
			<simplelist role="layout">
				<member>expression</member>
			</simplelist>
			
			<para>If the expression isn't an Exception, wrap it with NonExceptionThrownError.</para>
		</section>
	</section>

	<section xml:id="node.expression">
		<title>Expression nodes</title>
		
		<section xml:id="boolean-logic-nodes">
			<title>Boolean logic nodes</title>
			
			<para>Boolean logic nodes take two boolean values and evaluate to a boolean value. During evaluation, if casting an object reference to Bool produces an error, end evaluation and allow the exception to rise. Some boolean logic nodes can do shortcutting, meaning they do not evaluate the second node if the result of the node is already known.</para>
			
			<para>Boolean logic nodes have this layout:</para>
			<simplelist role="layout">
				<member>expression</member>
				<member>expression</member>
			</simplelist>
			
			<section xml:id="node.and">
				<title>and</title>
				
				<para>Evaluates to false if either child expression evaluates to false.</para>

				<orderedlist role="eval">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Cast [1] to Bool.</listitem>
					<listitem>If [2] is false, evaluate this node to false.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Cast [4] to Bool.</listitem>
					<listitem>Evaluate this node to [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.nand">
				<title>nand</title>
				
				<para>Evaluates to true if either child expression evaluates to false.</para>

				<orderedlist role="eval">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Cast [1] to Bool.</listitem>
					<listitem>If [2] is false, evaluate this node to true.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Cast [4] to Bool.</listitem>
					<listitem>Evaluate this node to the inverse of [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.or">
				<title>or</title>
				
				<para>Evaluates to true if either child expression evaluates to true.</para>

				<orderedlist role="eval">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Cast [1] to Bool.</listitem>
					<listitem>If [2] is true, evaluate this node to true.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Cast [4] to Bool.</listitem>
					<listitem>Evaluate this node to [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.nor">
				<title>nor</title>
				
				<para>Evaluates to false if either child expression evaluates to true.</para>

				<orderedlist role="eval">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Cast [1] to Bool.</listitem>
					<listitem>If [2] is true, evaluate this node to false.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Cast [4] to Bool.</listitem>
					<listitem>Evaluate this node to the inverse of [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.xor">
				<title>xor</title>
				
				<para>Evaluates to true if the child expressions evaluate to different values.</para>

				<orderedlist role="eval">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Cast [1] to Bool.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Cast [3] to Bool.</listitem>
					<listitem>If [2] and [4] are different, evaluate to true. Otherwise, evaluate to false.</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.xnor">
				<title>xnor</title>
				
				<para>Evaluates to true if the child expressions evaluate to the same value.</para>

				<orderedlist role="eval">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Cast [1] to Bool.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Cast [3] to Bool.</listitem>
					<listitem>If [2] and [4] are the same, evaluate to true. Otherwise, evaluate to false.</listitem>
				</orderedlist>
			</section>
		</section>
		
		<section xml:id="node.active-interface">
			<title>active-interface</title>
			
			<simplelist role="layout">
				<member>expression value</member>
			</simplelist>
			
			<para>Evaluates to the interface that is the active interafce of the specified value.</para>
		</section>
		
		<section xml:id="node.array">
			<title>array</title>
			
			<simplelist role="layout">
				<member>expression [interface]</member>
				<member>* expression [element]</member>
			</simplelist>
			
			<para>Evaluates to an object with interface array as the active interface. The object may implement other interfaces if they do not conflict with the array interface.</para>
			
			<para>Each [element] is cast to [interface]. If a cast error results, it raises out of the array node, so that the array node doesn't evaluate to anything.</para>
		</section>
		
		<section xml:id="node.assign">
			<title>assign</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>expression value</member>
			</simplelist>
			
			<para>Assigns the value to the identikey. If the identikey's type is not function, the identikey will be unbound first if it is already bound to something. The identikey's type must be dynamic, automatic, strict, or function. If the identikey's type is automatic, strict, or function, identifier must be variable.</para>
		</section>
		
		<section xml:id="node.assign-meta">
			<title>assign-meta</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>expression value</member>
			</simplelist>
			
			<para role="process">The identikey referred to by the identifier must be a dynamic identikey.</para>
			
			<para>Assigns a value with MetaValue as the active interface to the specified name. When the value is accessed, methods are called on the MetaValue. The methods of the MetaValue cannot be accessed directly.</para>
			
			<programlisting>
singleton foo
	interface MetaValue
		func onMethodExecute(string methodName, dyn[] arguments)
			println arguments.first
declare dyn bar
meta-assign foo to bar
bar.doStuff("test") //prints out "test"
			</programlisting>
		</section>
		
		<section xml:id="node.bind">
			<title>bind</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>? identifier method name</member>
				<member>* argument</member>
			</simplelist>
			
			<para>Performs partial application. Evaluates to a function.</para>
			
			<para>Note that if all arguments are supplied, the function will not be called. Contrast this with the <link linkend="node.curry">curry node</link>.</para>
			
			<programlisting>
interface Alpha
	func bar(Int a, Rat b, String c)

Alpha alpha = AlphaClass()

alpha.bar(0, 0.0, "0")

func()void bar1 = alpha:bar()
bar(1, 2.3, "4")

func()void bar2 = alpha:bar(c="text")
bar2(7, 9.8)

func()void bar3 = alpha:bar(-9, 0.001, "stuff")
bar3()
			</programlisting>
		</section>
		
		<section xml:id="node.call">
			<title>call</title>

			<simplelist role="layout">
				<member>expression value</member>
				<member>? identifier method name</member>
				<member>* argument</member>
			</simplelist>
			
			<para role="process">If this node is used as an expression, and the implementation can determine that the callee or method does not return a value, an error results.</para>
			
			<para>If [method name] is not given:</para>
			
			<orderedlist role="exec">
				<listitem>Evaluate [value].</listitem>
				<listitem>If the resultant value is not callable, throw an error.</listitem>
				<listitem>Evaluate the argument expressions in order.</listitem>
				<listitem>Send argument values to value for execution.</listitem>
			</orderedlist>
			
			<orderedlist role="eval">
				<listitem>Evaluate [value].</listitem>
				<listitem>If the resultant value is not callable or does not have a return type, throw an error.</listitem>
				<listitem>Evaluate the argument expressions in order.</listitem>
				<listitem>Send argument values to the value for evaluation.</listitem>
				<listitem>Evaluate this node to the returned value.</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.cast">
			<title>cast</title>
			
			<simplelist role="layout">
				<member>expression [object]</member>
				<member>expression [interface]</member>
			</simplelist>
			
			<para>Evaluates to an object reference where the active interface is [interface] and the object is [object]. If [object] does not implement [interface], an error results.</para>
			
			<programlisting>
Int o = getIntAndString()
print (o as String).length
			</programlisting>
		</section>
		
		<section xml:id="node.chain">
			<title>chain</title>
			
			<simplelist role="layout">
				<member>boolean namespaced-identikey</member>
				<member>boolean get-property</member>
				<member>boolean bind</member>
				<member>? expression starting value</member>
				<member>+ identifier</member>
			</simplelist>
			
			<para>This node exists for Desal representations that use the same syntax for different associations between identifiers. The associations supported by this node are the same as those of the <link linkend="node.namespaced-identikey">namespaced-identikey</link>, <link linkend="node.get-property">get-property</link>, and <link linkend="node.bind">bind</link> nodes. The optional boolean nodes are all true by default, meaning all associations are supported. If namespaced-identikey is true, the starting value must not be present.</para>
			
			<para>namespaced-identikey associations can be used to evaluate namespaced identikeys.</para>
			
			<screen>
namespace.identikey
namespace.namespace.identikey
			</screen>
			
			<para>get-property associations can be used to get properties of values.</para>
			
			<screen>
starting-value.property.property.property

if namespaced-identikey is also true:
namespace.identikey.property
			</screen>
			
			<para>bind associations can be used to bind a method of a value to a value.</para>
			
			<screen>
alpha.doStuff.apply
			</screen>
			
			<screen>
Different syntax for namespaced identikeys, getting properties, and method binding.

alpha::beta.gamma=>delta

(bind
	(get-property
		(namespaced-identikey
			(namespace alpha)
			(identifier beta))
		(identifier gamma))
	(identifier delta))

Here, alpha must be a namespace, beta must be an identikey, gamma must be a property, and delta must be a method.
			</screen>
			
			<screen>
Shared syntax for namespaced identikey references and getting properties, but different syntax for method binding.

alpha.beta.gamma:delta

(bind
	(chain
		(bind false)
		(identifier alpha)
		(identifier beta)
		(identifier gamma))
	(identifier delta))

Here, alpha could be a free identikey or a namespace. If alpha is a namespace, beta could be a namespace. gamma could be an identikey in the alpha.beta namespace, or a property of the value that beta evaluated to. delta must be a method.
			</screen>
			
			<screen>
Shared syntax for getting properties and method binding, but different syntax for referring to namespaced identikey references.

alpha::beta.gamma.delta

(chain
	(namespaced-identikey false)
	(starting-value
		(namespaced-identikey
			(namespace alpha)
			(identifier beta)))
	(identifier gamma)
	(identifier delta))

Here, alpha must be a namespace and beta must be an identikey within that namespace. gamma could be a property or method of beta. delta could be a property or method of gamma.
			</screen>
			
			<screen>
Same syntax for all.

alpha.beta.gamma.delta

(chain
	(identifier alpha)
	(identifier beta)
	(identifier gamma)
	(identifier delta))

Delta cannot be a namespace.
			</screen>
			
			<screen><![CDATA[
A representation could provide different syntax for each association, but also provide a way to specify that one of multiple assocations are allowed.

alpha :: beta {. or =>} gamma . delta => epsilon

<bind>
	<get-property label="value">
		<chain label="value">
			<bool label="namespaced-idenkey">false</bool>
			<namespaced-identikey label="starting-value">
				<identifer label="namespace">alpha</identifer>
				<identifer label="member">beta</identifer>
			</namespaced-identifer>
			<identifer>gamma</identifer>
		</chain>
		<identifer label="property-name">delta</identifer>
	</get-property>
	<identifier label="method-name">epsilon</identifer>
</bind>

Here, alpha must be a namespace, and beta must be an identikey within that namespace. Gamma can be a property or method of beta. delta must be a property of gamma. epsilon must be a method of delta.
]]>
			</screen>
		</section>
		
		<section xml:id="node.class">
			<title>class</title>
			
			<para>Evaluates to a value that, when called, produces other values. The interfaces supported by the produced values are implemented in the way specified by this class node. The active interface of the produced value is specified by this class.</para>
			
			<para role="xxx">XML comments with important information</para>
			
			<simplelist role="layout">
				<!-- private and possibly public; can't be "call" or "callee" -->
				<member>* declare-class static declarations</member>
				
				<!-- private -->
				<member>? block static constructor</member>
				
				<!-- public -->
				<member>* function static callees</member>
				
				<!-- public -->
				<member>* class-property static properties</member>
				
				<!-- private and public -->
				<member>* function instance constructors</member>
				
				<!-- private -->
				<member>* declaration instance declarations</member>
				
				<!-- private and public -->
				<member>* interface-implementation</member>
			</simplelist>
			
			<para>XXX The static callees and static properties may not always be visible in the class node's scope. (An example of being visible is assigning the value produced by the class node to an identifier.) Should some identifier (e.g. "thisClass") be introduced that evaluates to the class's value? (e.g. thisClass.property = foo) Or should a general means of accessing the enclosing expression node's value be introduced? (e.g. thisValue.property = foo)</para>
			
			<para>The above is not a problem for interface implementations due to the "this" identikey being bound to the active instance.</para>
			
			<para>The children of class nodes can be grouped by several means.</para>
			
			<para>By count:</para>
			<table>
				<tbody>
					<tr>
						<th></th>
						<th>public</th>
						<th>private</th>
					</tr>
					<tr>
						<th>static - only 1</th>
						<td>callees, getters/setters, methods, interface-implementations</td>
						<td>static constructor, instance constructors, static declarations, instance methods</td>
					</tr>
					<tr>
						<th>instance - 1 per instance</th>
						<td></td>
						<td>instance declarations</td>
					</tr>
				</tbody>
			</table>
			
			<para>By scopes: (in scope means something can be accessed through a single identifier as a free identikey)</para>
			<simplelist>
				<member>static scope
					<simplelist>
						<member>public
							<simplelist>
								<member>defined by: static declarations (as properties and methods; must have access with get and/or set), static properties, instance constructors (as callees)</member>
								<member>in scope: (none)</member>
							</simplelist>
						</member>
						<member>private
							<simplelist>
								<member>defined by: static declarations, instance constructors (as functions bound to "construct")</member>
								<member>in scope: static constructor, callees, getters/setters, methods, expressions in static declarations</member>
							</simplelist>
						</member>
					</simplelist>
				</member>
				<member>instance scope
					<simplelist>
						<member>public
							<simplelist>
								<member>defined by: interface-implementations (or really, by the interface)</member>
								<member>in scope: (none)</member>
							</simplelist>
						</member>
						<member>private
							<simplelist>
								<member>defined by: instance declarations, instance methods</member>
								<member>in scope: expressions in instance declarations, instance methods, interface implementations, instance constructors</member>
							</simplelist>
						</member>
					</simplelist>
				</member>
			</simplelist>
			
			<para>Note: Instance scopes are children of the static scope.</para>
			
			<para role="process">Must have at least one interface-implementation. Including the interface-implementation nodes that are inherited by this class's child interface-implementation nodes, one and only one of the interface-implementation nodes must be specified as default.</para>
			
			<orderedlist role="eval">
				<listitem>Create scope, STATIC_SCOPE.</listitem>
				<listitem>Create an interface, CLASS_INTERFACE.</listitem>
				<listitem>Add instance constructors as free functions to STATIC_SCOPE.</listitem>
				<listitem>Add instance constructors as callees to CLASS_INTERFACE.</listitem>
				<listitem>Evaluate every <link linkend="node.declare-class">declare-class</link> that has a <link linkend="node.declare-first">declare-first</link> in the scope of STATIC_SCOPE. If the identikey-type of the <link linkend="node.declare-first">declare-first</link> is function, and it has access of get, add a method to CLASS_INTERFACE with the same function interface and name. Otherwise, create a property with a getter if declared public.</listitem>
				<listitem>Evaluate the rest of the declare-class nodes in the scope of STATIC_SCOPE, except for the declare-class nodes with a declare-const-empty. Create properties as appropriate when the access nodes specify to do so.</listitem>
				<listitem>In the scope of STATIC_SCOPE, evaluate the declare-class nodes that have declare-const-empty nodes. Create properties as appropriate when the access nodes specify to do so.</listitem>
				<listitem>Add the static callees as free functions in STATIC_SCOPE.</listitem>
				<listitem>Add the static callees and the static properties to CLASS_INTERFACE.</listitem>
				<listitem>Execute the static constructor.</listitem>
				<listitem>Seal the identikeys created by the declare-const-empty nodes, meaning don't allow their bound status to change.</listitem>
				<listitem>Create a value with CLASS_INTERFACE as the active interface.</listitem>
				<listitem>Evaluate this node to the above value.</listitem>
			</orderedlist>
			
			<para>When a constructor is called:</para>
			<orderedlist role="eval">
				<listitem>Create a scope, INSTANCE_SCOPE. Set STATIC_SCOPE as the parent scope.</listitem>
				<listitem>Evaluate all declare-first nodes in scope of INSTANCE_SCOPE.</listitem>
				<listitem>Execute the appropriate constructor.</listitem>
				<listitem>Evaluate the function-call that lead to this constructor being evaluated to a value with INSTANCE_SCOPE as the object and the default interface implementation of the class as the active interface implementation.</listitem>
				<listitem>Note: When the interface implementation is used, the value will pass the object into the interface implementation.</listitem>
			</orderedlist>
			
			<section xml:id="node.declare-class">
				<title>declare-class</title>
				
				<simplelist role="layout">
					<member>declaration</member>
					<member>? access</member>
				</simplelist>
				
				<para role="process">If the declaration declares a const identifier, and access is present, the access node must be declared get.</para>
				
				<para role="xxx">poorly named</para>
			</section>
			
			<section xml:id="node.declaration">
				<title>declaration</title>
				
				<para>declaration is a family of node types, like expression or statement. The node types included in this family are:</para>
				
				<simplelist role="family-members">
					<member>declare-empty</member>
					<member>declare-assign</member>
					<member>declare-first</member>
					<member>declare-const-empty</member>
				</simplelist>
			</section>
			
			<section xml:id="node.declare-const-empty">
				<title>declare-const-empty</title>
				
				<simplelist role="layout">
					<member>identifier</member>
					<member>identikey-type</member>
				</simplelist>
				
				<para role="process">If identikey-type is function, the interface is the return type. (xxx why?)</para>
				
				<para>Identifiers created by this node are always const. [identikey-type] must be value, function, or meta. The class's static constructor is allowed to assign values to static identifiers created by this node. If anthing tries to assign a value to an identikey create by this node, and the identikey is already bound to something, throw an error. The class's instance constructors are allowed to assign values to instance identifiers created by this node. An error results if identikeys produced by declare-const-empty nodes are dereferenced before being bound to anything.</para>
			</section>
	
			<section xml:id="node.interface-implementation">
				<title>interface-implementation</title>
				
				<simplelist role="layout">
					<member>* interface-implementation children</member>
					<member>expression interface</member>
					<member>* function callee</member>
					<member>* named-function getter</member>
					<member>* named-function setter</member>
					<member>* named-function method</member>
					<member>boolean default</member>
				</simplelist>
			</section>
			
			<section xml:id="node.named-function">
				<title>named-function</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>function function</member>
				</simplelist>
			</section>
			
			<section xml:id="node.class-property">
				<title>class-property</title>
				
				<simplelist role="layout">
					<member>identifier</member>
					<member>identikey-type</member>
					<member>? function getter</member>
					<member>? function setter</member>
				</simplelist>
				
				<para role="process">Must have a getter and/or setter. If only identifier and identikey-type are given, an error results.</para>
			</section>
		</section>
			
		<section xml:id="node.conditional-expression">
			<title>conditional-expression</title>
			
			<simplelist role="layout">
				<member>expression test</member>
				<member>expression true</member>
				<member>expression false</member>
			</simplelist>
			
			<para>If [test] evaluates to true, this node evaluates to [true]. If [test] evaluates to false, this node evaluates to [false].</para>
			
			<programlisting>
Int a = (x ? 0 : 1)

(declare-assign
	(identifier.name a)
	(identikey-type
		(identikey-category value)
		(identifier.interface Int))
	(conditional-expression.value
		(identifier.test x)
		(integer.true 0)
		(integer.false 1)))
			</programlisting>
		</section>
		
		<section xml:id="node.copy">
			<title>copy</title>
			
			<para>Attempts to copy a given value.</para>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>? expression interface</member>
			</simplelist>
			
			<orderedlist role="eval">
				<listitem>Evaluate the value expression.</listitem>
				<listitem>Evaluate the interface expression or get the active interface of the value.</listitem>
				<listitem>Find the converter to the specified interface (XXX how?) using the same method as finding a property or method.</listitem>
				<listitem>Activate the converter.</listitem>
				<listitem>Evaluate this node to the returned value.</listitem>
			</orderedlist>
			
			<programlisting>
decl Int $num = 3

decl Int $num2 = copy($num)
decl Rat $num3 = ($num as Rat)

decl Int $num4 := $num
decl Rat $num5 := $num
			</programlisting>
		</section>
		
		<section xml:id="node.curry">
			<title>curry</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>? identifier method name</member>
				<member>* argument</member>
			</simplelist>
			
			<para>Provides the type of currying that is also known as "partial application".</para>
			
			<para>Note that Desal provides no built-in means of doing the other kind of currying, where a multi-argument function is converted into a chain of single-argument functions.</para>

			<programlisting>
func foo(Int a, Rat b, String c, Bool d) Int {
	...
}

//partial application
func(String,Bool)Int foo2 = foo(1, 2.34)
print foo2("text", true)

//other type of currying
func(Int)(
	func(Rat)(
		func(String)(
			func(Bool)Int ))) foo3 = curry(foo)
print foo3(1)(2.34)("text")(true)

//The above two are equivalent to:
print foo(1, 2.34, "text", true)
			</programlisting>
			
			<para>If the arguments match only one of the callees/methods of [value], this node evaluates to a value with a function interface as the active interface. If the arguments match more than one of the callees/methods on [value], this node evaluates to a value with an active interface that is produced from adding the function interfaces of the callees/methods together.</para>
			
			<para>After evaluation, the specified parameters have values, so they do not appear on the resultant function.</para>
			
			<para>Once the function has all its arguments supplied, it is called. Note that this is different from the <link linkend="node.bind">bind node</link>.</para>
			
			<programlisting>
func doStuff1(Int a, String b, Bool alpha) {...}
func doStuff1(Int a, Rat b, Bool alpha) {...}
func doStuff2 = doStuff1~(3, alpha=false)
doStuff2("test")
doStuff2(123.456)
			</programlisting>
			
			<para>The middle line perhaps might also be represented this way:</para>
			<programlisting>
(declare-first
	(identifier.name "doStuff2")
	(curry
		(identifier.value "doStuff1")
		(argument
			(integer.value 3))
		(argument
			(identifier.name "alpha")
			(identifier.value "false"))))
			</programlisting>
		</section>
		
		<section xml:id="node.declare-assign">
			<title>declare-assign</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
				<member>expression value</member>
			</simplelist>
			
			<para role="process">The identikey-category of the identikey-type node must be dynamic, automatic, strict, or function.</para>
			
			<para>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</para>
		</section>

		<section xml:id="node.function">
			<title>function</title>
			
			<simplelist role="layout">
				<member>* parameter</member>
				<member>return-info</member>
				<member>block</member>
			</simplelist>
			
			<para>When this node is evaluated, it evaluates to a value with a function interface as the active interface. Only the [parameter] node and [return-info]'s [interface] nodes are evaluated at this time. When the resultant value is called, the [block] node is executed in the scope of this function node.</para>
		</section>
		
		<section xml:id="node.return-info">
			<title>return-info</title>
			
			<simplelist role="layout">
				<member>boolean return</member>
				<member>? expression interface</member>
			</simplelist>
			
			<para role="process">If [interface] is present, [return] must be true.</para>
			
			<para>[return] tells whether the function returns a value. If [return] and [interface] are absent, the function does not return a value. If [return] is absent and [interface] is present, the function returns a value. If [return] is present, it's value determines whether the function returns a value (true) or doesn't (false).</para>
		</section>
		
		<section xml:id="node.function-interface">
			<title>function-interface</title>
			
			<simplelist role="layout">
				<member>? expression template-argument-count</member>
				<member>* parameter</member>
				<member>return-info</member>
			</simplelist>
		</section>

		<section xml:id="node.generic-class">
			<title>generic-class</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>class</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the class node.</para>
		</section>
		
		<section xml:id="node.generic-function">
			<title>generic-function</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>function</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the function node.</para>
			
			<programlisting>
generic(T)
func larger(T a, T b) T {
	if a &lt; b
		return b
	return a
}

println larger(2, 7) //prints "7"
			</programlisting>
		</section>
		
		<section xml:id="node.generic-interface">
			<title>generic-interface</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>interface</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the interface node.</para>
			
			<programlisting>
generic(T)
interface List {
	func addFront(T)
	func addBack(T)
	func removeFront() T
	func removeBack() T
}

List(Int) list = ...
list.addFront(2)
list.addBack(3)
list.addFront(1)
println list.removeFront() //prints "1"
println list.removeBack() //prints "3"
			</programlisting>
		</section>
		
		<section xml:id="node.generic-parameter">
			<title>generic-parameter</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>? expression default interface</member>
			</simplelist>
		</section>
		
		<section xml:id="node.identifier">
			<title>identifier</title>
			
			<para>Base node. Identifiers can sometimes evaluate to object references. Object references point to an object and have an active interface. Only properties declared by the active interface can be accessed, even if the object implements other interfaces.</para>
			
			<para>When evaluating an identifier to an object: If the identifier is undefined in the current scope, move to the containing scope. If there is no containing scope, throw an UndefinedIdentifier error. Continue moving to outer scopes until the identifier is found or there is no containing scope. If the identifier is bound to an object, the identifier evaluates to that object. If the identifier has been declared that it can be bound to objects, but it is currently not bound to anything, return null. If the identifier is bound to a function, the identifier evaluates to the wrapper for that function, as defined in function-wrapper xxx. If the identifier is bound to a namespace, a NamespaceIdentifier error results.</para>
		</section>

		<section xml:id="node.instantiate-generic-interface">
			<title>instantiate-generic-interface</title>
			
			<simplelist role="layout">
				<member>expression generic interface</member>
				<member>+ argument</member>
			</simplelist>
			
			<para>All the arguments must be interfaces. Pass interfaces in to get a function.</para>
		</section>
		
		<section xml:id="node.instantiate-generic-class">
			<title>instantiate-generic-class</title>
			
			<simplelist role="layout">
				<member>expression generic class</member>
				<member>+ argument</member>
			</simplelist>
			
			<para>All the arugments must be interfaces. Pass interfaces in to get a function.</para>
		</section>
		
		<section xml:id="node.intantiate-generic-function">
			<title>instantiate-generic-function</title>
			
			<simplelist role="layout">
				<member>expression generic function</member>
				<member>+ argument</member>
			</simplelist>
			
			<para>All the arguments must be interfaces. Pass interfaces in to get a function.</para>
		</section>
		
		<section xml:id="node.namespaced-identikey">
			<title>namespaced-identikey</title>
			
			<simplelist role="layout">
				<member>+ identifier namespaces</member>
				<member>identifier identikey name</member>
			</simplelist>
			
			<programlisting>
namespace::namespace::identikey

namespace foo {
	namespace bar {
		Int alpha = ...
	}
}
Int alpha = foo::bar::alpha
			</programlisting>
		</section>
		
		<section xml:id="node.implements">
			<title>implements</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>expression interface</member>
			</simplelist>
			
			<para>Returns a bool object reference to the true or false objects. True if [object] implements [interface], false otherwise.</para>
			
			<programlisting>
if (o imps Foo)
	(o as Foo).propOfFoo()
			</programlisting>
		</section>
		
		<section xml:id="node.integer">
			<title>integer</title>
			
			<para>Base node. Evaluates to an object reference with BigInt as the active interface. The object may implement other interfaces if they do not conflict with the BigInt interface. Must not implement the LimInt interface.</para>
		</section>
		
		<section xml:id="node.interface">
			<title>interface</title>
			
			<simplelist role="layout">
				<member>* expression inheritees</member>
				<member>* statused-member</member>
			</simplelist>
			
			<section xml:id="node.statused-member">
				<title>statused-member</title>
				
				<simplelist role="layout">
					<member>member-status</member>
					<member>interface-member</member>
				</simplelist>
			</section>
			
			<section xml:id="node.member-status">
				<title>member-status</title>
				
				<para>Base node. Specifies "new", "normal", or "deprecated".</para>
			</section>
			
			<section xml:id="node.interface-member">
				<title>interface-member</title>
				
				<para>Supertype. Includes convertor, callee, property, and method.</para>
			</section>
			
			<section xml:id="node.convertor">
				<title>convertor</title>
				
				<simplelist role="layout">
					<member>? expression interface</member>
				</simplelist>
				
				<para>Specifies that implementations of that interface can be converted into the specified type. Or, if [interface] isn't given, that the value can be copied.</para>
			</section>
			
			<section xml:id="node.callee">
				<title>callee</title>
				
				<simplelist role="layout">
					<member>* parameter</member>
					<member>return-info</member>
				</simplelist>
			</section>
			
			<section xml:id="node.property">
				<title>property</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>? expression interface</member>
					<member>access access</member>
				</simplelist>
			</section>
			
			<section xml:id="node.method">
				<title>method</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>expression interface</member>
				</simplelist>
			</section>
			
			<section xml:id="node.access">
				<title>access</title>
				
				<para>Access nodes must specify one of three access levels: only reading, only writing, or both reading and writing.</para>
			</section>
		</section>
		
		<section xml:id="node.same-object">
			<title>same-object</title>
			
			<simplelist role="layout">
				<member>expression</member>
				<member>expression</member>
			</simplelist>
			
			<para>Tells whether the values are associated with the same object.</para>
			
			<programlisting>
Alpha a = getAlpha()
Beta b = getBeta()
if( a === b )
	print "same objects"
			</programlisting>
		</section>
		
		<section xml:id="node.list">
			<title>list</title>
			
			<simplelist role="layout">
				<member>expression [interface]</member>
				<member>* expression [element]</member>
			</simplelist>
			
			<para>Evaluates to a list, as if calling CList{ [interface] } ( [element], [element], ... )</para>
			
			<para>Each [element] is cast to [interface]. If a cast error results, it raises out of the list node, so that the list node doesn't evaluate to anything.</para>
		</section>
		
		<section xml:id="node.object-number">
			<title>object-number</title>
			
			<simplelist role="layout">
				<member>Expression value</member>
			</simplelist>
			
			<para>Every object is associated with a constant non-negative integer. No two objects that are still accessible can have the same object number. This node evaluates to a value, with Int as the active interface, that encodes the object number for the object associated with the given value.</para>
		</section>
		
		<section xml:id="node.rational">
			<title>rational</title>
			
			<para>Base node. Evaluates to an object with BigRat as the active interface. The object may implement other interfaces if they do not conflict with the BigRat interface. Must not implement the LimRat interface.</para>
		</section>
		
		<section xml:id="node.get-property">
			<title>get property</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>identifier property name</member>
			</simplelist>
			
			<para>Retrieves a property of a value. If the active interface of the value does not have a property with the specified name, an error results.</para>
		</section>

		<section xml:id="node.string">
			<title>string</title>
			
			<para>string nodes consist of text</para>
			
			<para>strings are expressions</para>
			
			<para>Base node. Evaluates to an object with interface string as the active interface. The object may implement other interfaces if they do not conflict with the string interface.</para>
		</section>
		
		<section xml:id="node.unassign">
			<title>unassign</title>
			
			<simplelist role="layout">
				<member>expression</member>
			</simplelist>
			
			<para>Unassigns the values bound to the given reference. If the identikey is a function identikey, all bound functions are unbound.</para>
			
			<para role="xxx">Is this needed? Why not just assign null?</para>
		</section>
		
		<section xml:id="node.unassign-function">
			<title>unassign-function</title>
			
			<simplelist role="layout">
				<member>expression</member>
				<member>interface</member>
			</simplelist>
			
			<para>Unassigns the function with the specified interface from the given value.</para>
			
			<para role="xxx">What to do when such a function isn't bound? throw an error?</para>
		</section>
	</section>
	
	<section xml:id="unsorted-nodes">
		<title>Unsorted nodes</title>

		<section xml:id="node.alias">
			<title>alias</title>
			
			<simplelist role="layout">
				<member>chain target</member>
				<member>? identifier name</member>
			</simplelist>

			<para>Note: Due to the whole "everything's an object" business, this node should probably be removed. XXX But what about namespaces?!</para>
			
			<programlisting>
alias FooBarBaz as FBZ
alias Alpha.Beta.Gamma //the "as Gamma" part is implied
alias System.out.print as puts
puts( FBZ.toString(Gamma) )
			</programlisting>
			
			<programlisting>
auto FBZ = FooBarBaz
auto Gamma = Alpha.Beta.Gamma
auto puts = System.out.print
puts( FBZ.toString(Gamma) )
			</programlisting>
			
			<programlisting>
//if Gamma is a namespace
namespace Gamma = Alpha.Beta.Gamma
			</programlisting>
		</section>
	</section>
</chapter>