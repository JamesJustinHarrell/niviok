<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="node-types">
	<title>Node types</title>

	<para>This chapter describes the various types of nodes.</para>
	
	<section xml:id="base-node-types">
		<title>Base nodes</title>
		
		<para>These node types do not contain child nodes, and are thus the only nodes that must encode information themselves (as opposed to containing child nodes which together provide information).</para>
		
		<simplelist>
			<member linkend="node.access">access</member>
			<member linkend="node.boolean">boolean</member>
			<member linkend="node.direction">direciton</member>
			<member linkend="node.identifier">identifier</member>
			<member linkend="node.identikey-category">identifier-category</member>
			<member linkend="node.integer">integer</member>
			<member linkend="node.rational">rational</member>
			<member linkend="node.string">string</member>
		</simplelist>
	</section>
	
	<section xml:id="tree-node-layout-key">
		<title>Tree node layout key</title>
		
		<para>This section describes how the layout of a node type is represented in this specification.</para>
		
		<para>The layout for a node type is represented in this specification as a list of items. Each item represents a child node or multiple child nodes with the same meaning. Nodes represented by different items are considered to have different meaning.</para>
		
		<para>Each item in these lists first specifies how many child nodes with that meaning may appear, or it says nothing about the number, which means there must be one (and only one). The ways of representing these amounts is described below.</para>
		
		<variablelist>
			<varlistentry>
				<term>?</term>
				<listitem>0 or 1</listitem>
			</varlistentry>
			<varlistentry>
				<term>*</term>
				<listitem>0 or more</listitem>
			</varlistentry>
			<varlistentry>
				<term>+</term>
				<listitem>1 or more</listitem>
			</varlistentry>
		</variablelist>
		
		<para>Next comes the name of a node type or "expression". The child node represented by that list item must be of that type. The string "expression" means the node must be executable.</para>
		
		<para>Lastly comes a label for referring to the child nodes with that meaning. These labels carry no semantic information, and are only a means used to refer to specific nodes. The meaning of child nodes can certainly be represented by other means. However, people creating representations for Desal trees are encouraged to at least consider using these same labels when it makes sense to do so.</para>
	</section>
	
	<section xml:id="non-executable">
		<title>Non-executable</title>
		
		<para>Nodes that cannot be executed. Most server only to group other nodes together.</para>
		
		<section xml:id="node.argument">
			<title>argument</title>
			
			<simplelist role="layout">
				<member>? identifier parameter name</member>
				<member>? expression value</member>
			</simplelist>
			
			<programlisting>
				func doSomething(Int a = 1, Int b = 2, Int c = 3, Int d) {...}
				doSomething(7, default, default, 8)
				doSomething(7, c = default, 8)
			</programlisting>
		</section>
		
		<section xml:id="node.boolean">
			<title>boolean</title>
			
			<para>Base node. Must specify either true or false.</para>
			
			<para>Cannot be evaluated because that would conflict with the prevalent "true" and "false" identifiers. Use "true" and "false" identifiers for expressions instead.</para>
		</section>
		
		<section xml:id="node.bundle">
			<title>bundle</title>
			
			<para>A grouping of library references (import) and groups of declarations (plane).</para>
			
			<simplelist role="layout">
				<member>* import</member>
				<member>* alias</member>
				<member>* using</member>
				<member>+ plane</member>
			</simplelist>
			
			<para>The bundle node type is the type of the root node. No node can contain an bundle node. All Desal nodes that are executed in any way must be part of a complete Desal tree, which means having an bundle node as the root node.</para>
			
			<para role="xxx">Program arguments are no longer passed to the main function, because developers should have a choice of accessing program arguments in different ways, and some implementations may not have program arguments, or have non-string program arguments, etc. The old way just isn't flexible enough. Implementations should give program arguments through some API instead of passing them to the main function.</para>
			
			<orderedlist role="exec">
				<listitem>1. Create the identikeys specified in section XXX to this node's scope.</listitem>
				<listitem>2. Create any implementation-specific identikeys.</listitem>
				<listitem>3. Execute each child identifier-const node in order.</listitem>
			</orderedlist>
			
			<para>When the complete Desal tree is treated as a standalone program, section xxx applies. Otherwise, besides layout and setup, the abilities and behavior of the bundle node is implementation-specific, and execution or evaluation of Desal nodes may occur directly, without going through the bundle node.</para>
			
			<para>The section XXX mentioned above should specify a value bound to "main" with a callee that takes no arguments and either returns nothing or returns an Int.</para>
			
			<para role="xxx">Need a means of hiding/showing certain child namespaces of the global namespace. For example, a bundle acting as a library may have declarations in the global namespace and in a "private" namespace. The bundle should expose the declarations in the global namespace but hide the declarations in the private namespace.</para>
		</section>
		
		<section xml:id="node.direction">
			<title>direction</title>
			
			<para>Specifies the direction of a function parameter, one of: in, in-mutable, out, in-out, in-mutable-out</para>
			
			<para>A value passed to a function as an "in" parameter will not be mutated by the function. This means if the function uses the value in ways that may mutate the value, the value will be copied. If an action in the function may mutate the value, and the value does not declare a copy converter, an error results.</para>
			
			<para>Instances where the value may be mutated include when the interface of the value does not provide opacity information and the function calls a method, or if the interface does provide opacity information but the function calls a mutator method, or if the value is passed to another function as an in-mutable or in-mutable-out parameter.</para>
			
			<programlisting>
func alpha(in Int num) {
println num
}

func beta(in-mutable Int num) {
num += 567
}

func gamma(out Int num) {
//num not currently assigned to anything
num = 987
}

func delta(in-out Int num) {
println num
num = 1001
}

func epsilon(in-mutable-out Int num) {
num += 55555
num = 19591
}

Int num = 123
alpha(num)
beta(num) //value mutated
gamma(num) //num assigned to different value
delta(num) //num assigned to different value
epsilon(num) //value mutated and num assigned to different value
			</programlisting>
		</section>
		
		<section xml:id="node.generic-parameter">
			<title>generic-parameter</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>? expression default interface</member>
			</simplelist>
		</section>
		
		<section xml:id="node.identikey-category">
			<title>identikey-category</title>
			
			<para>specifies one of: namespace, dynamic, automatic, strict, function</para>
			
			<para>See the <link linkend="identikeys">section on identikeys</link>.</para>
		</section>
		
		<section xml:id="node.identikey-type">
			<title>identikey-type</title>
			
			<simplelist role="layout">
				<member>identikey-category</member>
				<member>? expression interface</member>
				<member>boolean nullable</member>
				<member>boolean constant</member>
			</simplelist>
			
			<para role="process">[constant] must not be specified if identikey-category is namespace. [constant] must be false (or not specified) if category is dynamic. The interface must be given if the category is strict. The interface must not be given if the category is namespace, dynamic, or automatic.</para>
			
			<para>If the category is strict, the active interface of any value bound to the identikey must be that interface. If the category is function, and the interface is given, functions bound to the identikey must specify that interface as the return type.</para>
			
			<para>The default value of [constant] is false. If [constant] is true, the identifier thereafter always refers to the same value. The identifier cannot be bound to a different value, or unbound. The active interface also cannot be changed.</para>
			
			<programlisting>
				Int a = 3
				func Int a = func()Int { return 3 }
			</programlisting>
		</section>
		
		<section xml:id="node.import">
			<title>import</title>
			
			<para>Binds a library namespace to a namespace identikey.</para>
			
			<simplelist role="layout">
				<member>string library</member>
				<member>identifier alias</member>
			</simplelist>
				
			<programlisting>
import "XmlLib" as Xml
/*
library: "XmlLib"
alias: Xml */
			</programlisting>
		</section>

		<section xml:id="node.parameter">
			<title>parameter</title>
			
			<para>A function parameter.</para>
			
			<simplelist role="layout">
				<member>direction</member>
				<member>? boolean nullable</member>
				<member>? expression interface</member>
				<member>identifier name</member>
				<member>? expression default value</member>
			</simplelist>
			
			 <para role="process">[nullable] must not be specified if direction is "out".</para>
		</section>
				
		<section xml:id="node.plane">
			<title>plane</title>
			
			<para>A group of declarations within a bundle.</para>
			
			<simplelist role="layout">
				<member>* alias</member>
				<member>* identifier namespace</member>
				<member>+ declare-first</member>
			</simplelist>
			
			<para>This node has scope, but only private identifiers are bound to it. Public and exported identifiers are bound to the scope of the bundle node.</para>
			
			<para>Planes aren't expressions because their declare-first nodes might rely on declare-first nodes in other planes, so all the declare-first nodes in a single plane can't just be executed all together.</para>
		</section>

		<section xml:id="node.return-info">
			<title>return-info</title>
			
			<simplelist role="layout">
				<member>boolean return</member>
				<member>? expression interface</member>
			</simplelist>
			
			<para role="process">If [interface] is present, [return] must be true.</para>
			
			<para>[return] tells whether the function returns a value. If [return] and [interface] are absent, the function does not return a value. If [return] is absent and [interface] is present, the function returns a value. If [return] is present, it's value determines whether the function returns a value (true) or doesn't (false).</para>
		</section>
		
		<section xml:id="node.type">
			<title>type</title>

			<simplelist role="layout">
				<member>? interface</member>
				<member>boolean nullable</member>
			</simplelist>
		</section>
	</section>

	<section xml:id="non-producing-expressions">
		<title>Non-producing expressions</title>
		
		<para>Nodes that can be executed, but never produce.</para>

		<section xml:id="iteration">
			<title>Iteration</title>
			
			<section xml:id="node.do-while">
				<title>do-while</title>
				
				<simplelist role="layout">
					<member>block action</member>
					<member>expression test</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
do {
	something()
} while test()
				</programlisting>
			</section>
			
			<section xml:id="node.do-times">
				<title>do-times</title>
				
				<simplelist role="layout">
					<member>expression times</member>
					<member>block action</member>
					<member>? expression test</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
do 8 times {
	something()
}

do 8 times {
	something()
} while test()
				</programlisting>
			</section>
			
			<section xml:id="node.for-key">
				<title>for-key</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression key interface</member>
					<member>identifier name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<orderedlist role="exec">
					<listitem>1. Call getKeyIterator on [container].</listitem>
					<listitem>2. Call getNext on [1]. If an exception is thrown with an active interface of GeneratorDone, swallow it and end execution. If anything else is thrown, follow normal exception rules.</listitem>
					<listitem>3. Create a scope.</listitem>
					<listitem>4. Assign [2] to [identifier] in [3].</listitem>
					<listitem>5. Execute [block] with scope [3].</listitem>
					<listitem>6. Go to step 2.</listitem>
				</orderedlist>
				
				<programlisting>
for key x in foo
	doStuff(x)

for key Int x in foo
	doStuff(x)
				</programlisting>
			</section>
			
			<section xml:id="node.for-pair">
				<title>for-pair</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression key interface</member>
					<member>identifier key name</member>
					<member>? expression value interface</member>
					<member>identifier value name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
for pair x y in coords
	drawPoint(x, y)

for pair Int x, Int y in coords
	drawPoint(x, y)
				</programlisting>
			</section>

			<section xml:id="node.for-manual">
				<title>for-manual</title>
				
				<para>Used for manual iteration, as opposed to letting the Desal implementation deal with iteration, like with a for-value node.</para>
				
				<simplelist role="layout">
					<member>* expression initializers</member>
					<member>? expression test</member>
					<member>* expression post actions</member>
					<member>? block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<para>The initializers are executed before iteration begins. Test is evaluated before each iteration. Post actions are executed after each iteration.</para>
				
				<screen>
initializers

test
action
post actions

test
action
post actions

...

test
action
post actions

test

(end of loop)
				</screen>
				
				<programlisting>
for( Int i = 0 ; i &lt; container.length ; i++ ) {
	println container[i]
}

for( Iterator&lt;Int> iterator = container.getIterator() ;
iterator.hasMore? ; iterator.moveNext() ) {
	println iterator.current
}
				</programlisting>
			</section>
			
			<section xml:id="node.for-range">
				<title>for-range</title>
				
				<simplelist role="layout">
					<member>? identifier name</member>
					<member>expression start</member>
					<member>expression limit</member>
					<member>boolean inclusive</member>
					<member>? expression test</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<para>[inclusive] determines whether the loop should iterate one last time if the iteration value is equal to the limit, and it is false by default.</para>
				
				<programlisting>
for 0 to 100
	println "test"

for x from 0 to 100
	println x

for x from 0 to 100 inclusive
	println x

for 0 to string.length while not container.full
	container.push( string.unshift!() )

for x from 0 to 100 while not foo.done?
	foo.runTest(x)
				</programlisting>
			</section>
			
			<section xml:id="node.for-value">
				<title>for-value</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression value interface</member>
					<member>identifier name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
for name in names
	println name

for String name in names
	println name
				</programlisting>
			</section>
			
			<section xml:id="node.loop">
				<title>loop</title>
				
				<simplelist role="layout">
					<member>block</member>
				</simplelist>
				
				<para>Executes block continuously. Can only be exited by expressions in the block such as break and return.</para>
			
				<programlisting>
loop {
	Event event = getNextEvent()
	switch( event ) {
		case Events.QUIT :
			break
	}
}
				</programlisting>
			</section>
			
			<section xml:id="node.while">
				<title>while</title>
				
				<simplelist role="layout">
					<member>expression test</member>
					<member>? block</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
while printNext()

while container.hasMore?
	print container.next
				</programlisting>
			</section>
		</section>
		
		<section xml:id="node.break">
			<title>break</title>
			
			<simplelist role="layout">
				<member>? identifier label</member>
			</simplelist>
		</section>
		
		<section xml:id="node.continue">
			<title>continue</title>
			
			<simplelist>
				<member>? identifier label</member>
			</simplelist>
		</section>
		
		<section xml:id="node.declare-empty">
			<title>declare-empty</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
			</simplelist>
			
			<para role="process">The identikey-type must not be constant.</para>
			
			<para>Creates an identikey in the parent scope with the specified type. After this node executes, the produced identikey does not yet point to any values.</para>

			<programlisting>
decl func Int foo
foo = func()Int { return 3 }
foo = func(Int a)Int { return a * 2 }
print foo() //prints 3
print foo(2) //prints 4

//xxx does this produce error or replace?
foo = func()Int { return 5 }
			</programlisting>

			<programlisting>
decl func()Int foo
foo = func()Int { return 3 }
print foo() //prints 3
foo = func()Int { return 5 }
print foo() //prints 5
foo = func(Int a)Int { return a * 2 } //error - interface mismatch
			</programlisting>
		</section>
		
		<section xml:id="node.declare-first">
			<title>declare-first</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
				<member>expression value</member>
			</simplelist>
			
			<para role="process">The identikey-type must be constant, and must have a category of automatic, strict, or function.</para>
			
			<para>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</para>
			
			<para>When a block contains declare-first nodes, the declare-first nodes are executed before the other expressions in the block are executed. The value expressions of declare-first nodes may depend on the values of other declare-first nodes in the same block. For example, two interfaces could reference each other.</para>
			
			<para>This node can create identikeys before execution reaches it. For more information, see <link linkend="handling-declare-first">this section</link>.</para>
			
			<para role="exec">Produce the value bound to the identikey created by this node.</para>
			
			<programlisting>
decl-first auto Foo = interface {
	get Bar bar
}

decl-first auto Bar = interface {
	get Foo foo
}

Foo foo = ...
foo.bar.foo.bar...
			</programlisting>
		</section>
		
		<section xml:id="node.alias">
			<title>alias</title>
			
			<para>Creates an identikey that is associated with the same value/namespace as the specified identikey in the specified namespace.</para>
			
			<simplelist role="layout">
				<member>+ identifier target</member>
				<member>identifier name</member>
			</simplelist>
			
			<programlisting>
alias Xml.XmlDocument as Doc
alias Xml.XmlElement as XmlElement

import ".NET: System" as System
alias System.Collections.Generic as box
box.IList&lt;Foo> = new box.List&lt;Foo>();
			</programlisting>
			
			<programlisting>
alias FooBarBaz as FBZ
alias System.out.print as puts
puts( (FBZ to String)(Gamma) )
			</programlisting>
			
			<para>Each of the [target] identifiers, except for the last, must refer to a namespace. (The last can also refer to a namespace.)</para>
		</section>
		
		<section xml:id="node.using">
			<title>using</title>
			
			<para>Imports all the child identikeys of the specified namespace into the enclosing scope.</para>
			
			<simplelist role="layout">
				<member>+ identifier</member>
			</simplelist>
			
			<programlisting>
decl std.Array&lt;Int> numbers

using std
decl Array&lt;Int> numbers
			</programlisting>
		</section>
		
		<section xml:id="node.return">
			<title>return</title>
			
			<simplelist role="layout">
				<member>? expression</member>
			</simplelist>
			
			<para>Function call ends and evaluates to expression.</para>
		</section>
		
		<section xml:id="node.throw">
			<title>throw</title>
			
			<simplelist role="layout">
				<member>expression</member>
			</simplelist>
			
			<para>If the expression isn't an Exception, wrap it with NonExceptionThrownError.</para>
		</section>
		
		<section xml:id="node.labeled">
			<title>labeled</title>
			
			<simplelist role="layout">
				<member>identifier label</member>
				<member>expression child</member>
			</simplelist>
			
			<para role="process">The [child] node must be an iteration node, a block node, a possibility node, a conditional node, or a select node. (XXX update and explain requirements instead of just listing nodes that meet requirements)</para>
			
			<programlisting>
$func setupCell(Int searchID) {
	$decl Cell wantedCell
	
	outer: $for row $in table {
		$for cell $in row {
			$if cell.ID == searchID {
				wantedCell = cell
				$break outer
			}
		}
	}
	
	$if wantedCell != null {
		doSomething(wantedCell)
	}
}
			</programlisting>
		</section>
	
		<section xml:id="node.yield">
			<title>yield</title>
			
			<para>Within a generator, specifies the next value for the generator to yield.</para>
			
			<simplelist role="layout">
				<member>expression</member>
			</simplelist>
			
			<para role="process">Must be a descendant of a generator node, and not inside a function or class node. (XXX spec out the kind of barriers function and class nodes create)</para>
		</section>
	</section>

	<section xml:id="sometimes-producing-expressions">
		<title>Sometimes producing expressions</title>
		
		<para>Nodes that can be executed, and sometimes produce.</para>

		<section xml:id="node.assign">
			<title>assign</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>expression value</member>
			</simplelist>
			
			<para>Assigns the value to the identikey. If the identikey's type is not function, the identikey will be unbound first if it is already bound to something. The identikey's type must be dynamic, automatic, strict, or function. If the identikey's type is automatic, strict, or function, identifier must be variable.</para>
		</section>
		
		<section xml:id="node.declare-assign">
			<title>declare-assign</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
				<member>expression value</member>
			</simplelist>
			
			<para role="process">The identikey-category of the identikey-type node must be dynamic, automatic, strict, or function.</para>
			
			<para>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</para>
		</section>
		
		<section xml:id="node.unassign">
			<title>unassign</title>
			
			<simplelist role="layout">
				<member>expression</member>
			</simplelist>
			
			<para>Unassigns the values bound to the given reference. If the identikey is a function identikey, all bound functions are unbound.</para>
			
			<para role="xxx">Is this needed? Why not just assign null?</para>
		</section>
		
		<section xml:id="node.block">
			<title>block</title>
			
			<para role="xxx">Come up with better name.</para>
			
			<simplelist role="layout">
				<member>* expression</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<orderedlist role="exec">
				<listitem>Execute each expression in order. Produce the result of the last expression. (Produce nothing if the block contained no expressions or the last expression didn't produce.)</listitem>
			</orderedlist>
			
			<para>Note: This node type is different from the Dextr concept of blocks. To differentiate between the two, nodes of this type can be called "block nodes", and the syntactic construct of Dextr can be called "Dextr blocks" or "syntactic blocks".</para>
		</section>
		
		<section xml:id="node.possibility">
			<title>possibility</title>
			
			<simplelist role="layout">
				<member>expression test</member>
				<member>expression result</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<para role="process">An error results if the implementation knows [test] will never evaluate to a value that can be downcast to Bool.</para>
			
			<orderedlist role="exec">
				<listitem>Evaluate [test].</listitem>
				<listitem>Downcast [1] to Bool.</listitem>
				<listitem>If [2] is true, evaluate [result].</listitem>
				<listitem>Evaluate this node to [3].</listitem>
			</orderedlist>
			
			<programlisting>
if not foo.isSetup? {
	foo.setup()
}
			</programlisting>
		</section>
			
		<section xml:id="node.conditional">
			<title>conditional</title>
			
			<simplelist role="layout">
				<member>+ possibility</member>
				<member>? expression else</member>
			</simplelist>
			
			<para role="exec">Execute the [test] of the first [possibilty]. Downcast the resultant value to a Bool. If it is true, execute the [result] of that [possibilty] and produce the result. Otherwise, move on to the next node. If no [test] produces true, and [else] is given, execute [else] and produce its result.</para>
			
			<programlisting>
$decl Int a = (x ? 0 : 1)

$if foo == 1
	doStuff1()
$elif foo == 2
	doStuff2()
$else
	doDefault()

$decl bar =
	(foo == 1) ? getOne() :
	(foo == 2) ? getTwo() :
	getDefault()

$decl bar =
	$if foo == 1 : $eval getOne()
	$elif foo == 2 : $eval getTwo()
	$else : $eval getDefault()
			</programlisting>
		</section>
		
		<section xml:id="node.select">
			<title>select</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>* case</member>
				<member>? expression else</member>
			</simplelist>
			
			<para role="exec">Execute [value]. Execute each [values] child of each [case] and compare them to the [value] value (with the .equals? method of the [value] value) until finding a match. Then, execute the [result] of that case and produce the result. If no match is found, and [else] is given, execute [else] and produce its result.</para>
			
			<section xml:id="node.case">
				<title>case</title>
				
				<simplelist role="layout">
					<member>+ expression values</member>
					<member>expression result</member>
				</simplelist>
			</section>
			
			<programlisting>
$select event.type
$case Events.QUIT {
	$return
}
$case Events.FOO, Events.BAR, Events.MAZ {
	//no action
}
$else {
	$throw ErrorClass("unknown event type")
}

$select foo
$case 1
	doStuff1()
$case 2
	doStuff2()
$else
	doDefault()

$decl bar = $select foo
	$case 1 : $eval getOne()
	$case 2 : $eval getTwo()
	$else $eval getDefault()
			</programlisting>
		</section>
		
		<section xml:id="node.try-catch">
			<title>try-catch</title>
			
			<simplelist role="layout">
				<member>expression try</member>
				<member>* exception-handler</member>
				<member>? expression else</member>
				<member>? expression finally</member>
			</simplelist>
			
			<para role="xxx">The term "else" is not descriptive enough in this situation. Possible replacements: "onsuccess", "then"</para>
			
			<para role="process">Must contain more than just [try].</para>
			
			<section xml:id="node.exception-handler">
				<title>exception-handler</title>

				<simplelist role="layout">
					<member>boolean catch</member>
					<member>expression interface</member>
					<member>? identifier name</member>
					<member>expression result</member>
				</simplelist>
			</section>
			
			<programlisting>
$try {
	$decl foo = getSomething()
}
$observe( OutOfMemoryError ) {
	println "I'm not catching that!"
	//exception is noticed by this try-catch node, but not caught
	//the exception continues to rise out
}
$catch( NullError ) {
	println "null error"
}
$catch( FooError e ) {
	println "FooError: $(e.message)"
}
$catch( Error ) {
	println "unknown error"
}
$catch( Exception ) {
	println "unknown exception"
}
$observe {
	println "how execution reach here? am not good with computer"
}
$else {
	println "no errors!"
	doSomeStuff() //don't catch errors from this in this node
}
$finally {
	cleanup(foo)
}

$decl Status stat =
$try {
	doSomething()
	Statuses.SUCCESS
}
$catch( NotSoBadError ) {
	Statuses.ERROR
}
$observe {
	println "something bad when trying to doSomething()"
}
			</programlisting>
		</section>
		
		<section xml:id="node.call">
			<title>call</title>

			<simplelist role="layout">
				<member>expression value</member>
				<member>? identifier method name</member>
				<member>* argument</member>
			</simplelist>
			
			<para>If [method name] is not given:</para>
			
			<orderedlist role="exec">
				<listitem>Execute [value].</listitem>
				<listitem>If the resultant value is not callable, throw an error.</listitem>
				<listitem>Execute the argument expressions in order.</listitem>
				<listitem>Send argument values to the [value] value for execution.</listitem>
				<listitem>Produce the returned value.</listitem>
			</orderedlist>
			
			<para>If [method name] is given:</para>
			
			<orderedlist role="exec">
				<listitem>Execute [value].</listitem>
				<listitem>If the resultant value is not callable, throw an error.</listitem>
				<listitem>Execute the argument expressions in order.</listitem>
				<listitem>Send argument values to the method with name [method name] of the [value] value for execution.</listitem>
				<listitem>Produce the returned value.</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.curry">
			<title>curry</title>
			
			<para>Provides a built-in means of partial application. (Note that Desal provides no built-in support for the original type of currying, where a multi-argument function is converted into a chain of single-argument functions.)</para>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>? identifier method name</member>
				<member>* argument</member>
				<member>boolean call</member>
			</simplelist>

			<para>If [call] is true, and this node results in the function receiving enough arguments to be called, the function will be called.</para>
			
			<programlisting>
func foo(Int a, Rat b, String c, Bool d) Int {
	...
}

//partial application
func(String,Bool)Int foo2 = foo(1, 2.34)
print foo2("text", true)

//other type of currying
func(Int)(
	func(Rat)(
		func(String)(
			func(Bool)Int ))) foo3 = curry(foo)
print foo3(1)(2.34)("text")(true)

//The above two are equivalent to:
print foo(1, 2.34, "text", true)
			</programlisting>
			
			<para>Assuming the function is not called: If the arguments match only one of the callees/methods of [value], this node produces a value with a function interface as the active interface. If the arguments match more than one of the callees/methods on [value], this node produces a value with an active interface that is made by adding the function interfaces of the callees/methods together.</para>
			
			<para>After execution, the specified parameters have values, so they do not appear on the resultant function.</para>
			
			<para>Once the function has all its arguments supplied, it is called if [call] is true, and the result of that call is produced.</para>
			
			<programlisting>
func doStuff1(Int a, String b, Bool alpha) {...}
func doStuff1(Int a, Rat b, Bool alpha) {...}
func doStuff2 = doStuff1~(3, alpha=false)
doStuff2("test")
doStuff2(123.456)
			</programlisting>
			
			<para>The middle line perhaps might also be represented this way:</para>
			<programlisting>
(declare-first
	(identifier.name "doStuff2")
	(curry
		(identifier.value "doStuff1")
		(argument
			(integer.value 3))
		(argument
			(identifier.name "alpha")
			(identifier.value "false"))))
			</programlisting>

			<programlisting>
interface Alpha
func bar(Int a, Rat b, String c)

Alpha alpha = AlphaClass()

alpha.bar(0, 0.0, "0")

func()void bar1 = alpha:bar()
bar(1, 2.3, "4")

func()void bar2 = alpha:bar(c="text")
bar2(7, 9.8)

func()void bar3 = alpha:bar(-9, 0.001, "stuff")
bar3()
			</programlisting>
			
			<para>Creates a function that, when passed the type specified by [interface], calls the method named [method name] with the rest of the arguments sent to it. It's purpose is to help with functional programming.</para>
			
			<programlisting>
interface Foo {
func doStuff(Int, Int) Rat
}

Foo foo = getFoo()
func(Foo,Int,Int)Rat doStuffer = Foo::doStuff
println doStuffer(foo,3,7)

dyn doStuffer2 = dyn::doStuff
println doStuffer2(foo,3,7)

//all equilavent
println Foo::doStuff(foo,3,7)
println dyn::doStuff(foo,3,7)
println foo.doStuff(3,7)
			</programlisting>
		</section>
		
		<section xml:id="node.ignore">
			<title>ignore</title>
			
			<para>Instructs an agent to not output certain warnings.</para>
			
			<simplelist role="layout">
				<member>expression content</member>
				<member>+ ignore-member</member>
			</simplelist>
			
			<section xml:id="node.ignore-member">
				<title>ignore-member</title>
				
				<simplelist role="layout">
					<member>string name</member>
					<member>integer depth</member>
				</simplelist>
			
				<para>The [name] can be a warning name from the <link linkend="warnings-list">specified warnings</link> or an agent-defined warning name. Unknown warning names should by default produce a warning that the warning name is unknown. Agents should provide an option to disable warnings for unknown warning names.</para>
				
				<para>The [depth] specifies what descendant nodes are affected by the ignore node. Counting begins at one with the [content] node of the ignore node and increments by one for each further descendant.</para>
				
				<programlisting>
(ignore
	(ignore-member
		(string.name "always null")
		(integer.depth ...))
	(call.content
		(function.identifier println)
		(assignment.argument
			(identifier.name foo)
			(for-value.value
				...))))
				</programlisting>
				
				<para>Here, if the [depth] was 1, a warning should be output by the agent for the assignment node that the [value] node will never produce a value when executed (a.k.a. always evaluate to null).</para>
			</section>
		</section>
	</section>
	
	<section xml:id="always-producing-expresions">
		<title>Always producing expressions</title>
		
		<para>Expressions that, aside from e.g. exceptions, always produce when executed. These nodes, other than the and, nand, or, and nor nodes, are not intended to have side effects.</para>
		
		<section xml:id="boolean-logic">
			<title>Boolean logic</title>
			
			<section xml:id="node.and">
				<title>and</title>
				
				<para>Evaluates to false if either child expression evaluates to false.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is false, evaluate this node to false.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.nand">
				<title>nand</title>
				
				<para>Evaluates to true if either child expression evaluates to false.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is false, evaluate this node to true.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to the inverse of [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.or">
				<title>or</title>
				
				<para>Evaluates to true if either child expression evaluates to true.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is true, evaluate this node to true.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.nor">
				<title>nor</title>
				
				<para>Evaluates to false if either child expression evaluates to true.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is true, evaluate this node to false.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to the inverse of [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.xor">
				<title>xor</title>
				
				<para>Evaluates to true if the child expressions evaluate to different values.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [3] to Bool.</listitem>
					<listitem>If [2] and [4] are different, evaluate to true. Otherwise, evaluate to false.</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.xnor">
				<title>xnor</title>
				
				<para>Evaluates to true if the child expressions evaluate to the same value.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [3] to Bool.</listitem>
					<listitem>If [2] and [4] are the same, evaluate to true. Otherwise, evaluate to false.</listitem>
				</orderedlist>
			</section>
		</section>
		
		<section xml:id="node.array">
			<title>array</title>
			
			<simplelist role="layout">
				<member>type</member>
				<member>* expression element</member>
			</simplelist>
			
			<para>Evaluates to an object with interface array as the active interface. The object may implement other interfaces if they do not conflict with the array interface.</para>
			
			<para>Each [element] is cast to [interface]. If a cast error results, it raises out of the array node, so that the array node doesn't evaluate to anything.</para>
		</section>
		
		<section xml:id="node.cast">
			<title>cast</title>
			
			<simplelist role="layout">
				<member>expression [object]</member>
				<member>expression [interface]</member>
			</simplelist>
			
			<para>Evaluates to an object reference where the active interface is [interface] and the object is [object]. If [object] does not implement [interface], an error results.</para>
			
			<programlisting>
Int o = getIntAndString()
print (o as String).length
			</programlisting>
		</section>
		
		<section xml:id="node.chain">
			<title>chain</title>
			
			<para>Creates a doubly-linked list from the provided elements.</para>

			<simplelist role="layout">
				<member>type</member>
				<member>* expression element</member>
			</simplelist>
			
			<para>Evaluates to a list, as if calling CList&lt; [interface] > ( [element], [element], ... )</para>
			
			<para>Each [element] is cast to [interface]. If a cast error results, it raises out of the list node, so that the list node doesn't evaluate to anything.</para>
		</section>
		
		<section xml:id="node.class">
			<title>class</title>
			
			<para>Evaluates to a value that, when called, produces other values. The interfaces supported by the produced values are implemented in the way specified by this class node. The active interface of the produced value is specified by this class.</para>
			
			<para>The active interface of the value that is produced when a class node is executed inherits from the master interface of the class. The master interface is the sum of all the root interfaces implemented by the class.</para>
			
			<para role="xxx">XML comments with important information</para>
			
			<simplelist role="layout">
				<!-- private and possibly public; can't be "call" or "callee" -->
				<member>* declare-class static declarations</member>
				
				<!-- private -->
				<member>? block static constructor</member>
				
				<!-- public -->
				<member>* function static callees</member>
				
				<!-- public -->
				<member>* class-property static properties</member>
				
				<!-- private and public -->
				<member>* function instance constructors</member>
				
				<!-- private -->
				<member>* declaration instance declarations</member>
				
				<!-- private and public -->
				<member>* interface-implementation</member>
			</simplelist>
			
			<para>XXX The static callees and static properties may not always be visible in the class node's scope. (An example of being visible is assigning the value produced by the class node to an identifier.) Should some identifier (e.g. "thisClass") be introduced that evaluates to the class's value? (e.g. thisClass.property = foo) Or should a general means of accessing the enclosing expression node's value be introduced? (e.g. thisValue.property = foo)</para>
			
			<para>The above is not a problem for interface implementations due to the "this" identikey being bound to the active instance.</para>
			
			<para>The children of class nodes can be grouped by several means.</para>
			
			<para>By count:</para>
			<table>
				<tbody>
					<tr>
						<th></th>
						<th>public</th>
						<th>private</th>
					</tr>
					<tr>
						<th>static - only 1</th>
						<td>callees, getters/setters, methods, interface-implementations</td>
						<td>static constructor, instance constructors, static declarations, instance methods</td>
					</tr>
					<tr>
						<th>instance - 1 per instance</th>
						<td></td>
						<td>instance declarations</td>
					</tr>
				</tbody>
			</table>
			
			<para>By scopes: (in scope means something can be accessed through a single identifier as a free identikey)</para>
			<simplelist>
				<member>static scope
					<simplelist>
						<member>public
							<simplelist>
								<member>defined by: static declarations (as properties and methods; must have access with get and/or set), static properties, instance constructors (as callees)</member>
								<member>in scope: (none)</member>
							</simplelist>
						</member>
						<member>private
							<simplelist>
								<member>defined by: static declarations, instance constructors (as functions bound to "construct")</member>
								<member>in scope: static constructor, callees, getters/setters, methods, expressions in static declarations</member>
							</simplelist>
						</member>
					</simplelist>
				</member>
				<member>instance scope
					<simplelist>
						<member>public
							<simplelist>
								<member>defined by: interface-implementations (or really, by the interface)</member>
								<member>in scope: (none)</member>
							</simplelist>
						</member>
						<member>private
							<simplelist>
								<member>defined by: instance declarations, instance methods</member>
								<member>in scope: expressions in instance declarations, instance methods, interface implementations, instance constructors</member>
							</simplelist>
						</member>
					</simplelist>
				</member>
			</simplelist>
			
			<para>Note: Instance scopes are children of the static scope.</para>
			
			<para role="process">Must have at least one interface-implementation. Including the interface-implementation nodes that are inherited by this class's child interface-implementation nodes, one and only one of the interface-implementation nodes must be specified as default.</para>
			
			<orderedlist role="exec">
				<listitem>Create scope, STATIC_SCOPE.</listitem>
				<listitem>Create an interface, CLASS_INTERFACE.</listitem>
				<listitem>Add instance constructors as free functions to STATIC_SCOPE.</listitem>
				<listitem>Add instance constructors as callees to CLASS_INTERFACE.</listitem>
				<listitem>Evaluate every <link linkend="node.declare-class">declare-class</link> that has a <link linkend="node.declare-first">declare-first</link> in the scope of STATIC_SCOPE. If the identikey-type of the <link linkend="node.declare-first">declare-first</link> is function, and it has access of get, add a method to CLASS_INTERFACE with the same function interface and name. Otherwise, create a property with a getter if declared public.</listitem>
				<listitem>Evaluate the rest of the declare-class nodes in the scope of STATIC_SCOPE, except for the declare-class nodes with a declare-const-empty. Create properties as appropriate when the access nodes specify to do so.</listitem>
				<listitem>In the scope of STATIC_SCOPE, evaluate the declare-class nodes that have declare-const-empty nodes. Create properties as appropriate when the access nodes specify to do so.</listitem>
				<listitem>Add the static callees as free functions in STATIC_SCOPE.</listitem>
				<listitem>Add the static callees and the static properties to CLASS_INTERFACE.</listitem>
				<listitem>Execute the static constructor.</listitem>
				<listitem>Seal the identikeys created by the declare-const-empty nodes, meaning don't allow their bound status to change.</listitem>
				<listitem>Create a value with CLASS_INTERFACE as the active interface.</listitem>
				<listitem>Evaluate this node to the above value.</listitem>
			</orderedlist>
			
			<para>When a constructor is called:</para>
			<orderedlist role="exec">
				<listitem>Create a scope, INSTANCE_SCOPE. Set STATIC_SCOPE as the parent scope.</listitem>
				<listitem>Evaluate all declare-first nodes in scope of INSTANCE_SCOPE.</listitem>
				<listitem>Execute the appropriate constructor.</listitem>
				<listitem>Evaluate the function-call that lead to this constructor being evaluated to a value with INSTANCE_SCOPE as the object and the default interface implementation of the class as the active interface implementation.</listitem>
				<listitem>Note: When the interface implementation is used, the value will pass the object into the interface implementation.</listitem>
			</orderedlist>
			
			<section xml:id="node.declare-class">
				<title>declare-class</title>
				
				<simplelist role="layout">
					<member>declaration</member>
					<member>? access</member>
				</simplelist>
				
				<para role="process">If the declaration declares a const identifier, and access is present, the access node must be declared get.</para>
				
				<para role="xxx">poorly named</para>
			</section>
			
			<section xml:id="node.declaration">
				<title>declaration</title>
				
				<para>declaration is a family of node types, like expression. The node types included in this family are:</para>
				
				<simplelist role="family-members">
					<member>declare-empty</member>
					<member>declare-assign</member>
					<member>declare-first</member>
					<member>declare-const-empty</member>
				</simplelist>
			</section>
			
			<section xml:id="node.declare-const-empty">
				<title>declare-const-empty</title>
				
				<simplelist role="layout">
					<member>identifier</member>
					<member>identikey-type</member>
				</simplelist>
				
				<para role="process">If identikey-type is function, the interface is the return type. (xxx why?)</para>
				
				<para>Identifiers created by this node are always const. [identikey-type] must be value or function. The class's static constructor is allowed to assign values to static identifiers created by this node. If anthing tries to assign a value to an identikey create by this node, and the identikey is already bound to something, throw an error. The class's instance constructors are allowed to assign values to instance identifiers created by this node. An error results if identikeys produced by declare-const-empty nodes are dereferenced before being bound to anything.</para>
			</section>
	
			<section xml:id="node.interface-implementation">
				<title>interface-implementation</title>
				
				<simplelist role="layout">
					<member>* interface-implementation children</member>
					<member>expression interface</member>
					<member>* function callee</member>
					<member>* named-function getter</member>
					<member>* named-function setter</member>
					<member>* named-function method</member>
					<member>boolean default</member>
				</simplelist>
			</section>
			
			<section xml:id="node.named-function">
				<title>named-function</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>function function</member>
				</simplelist>
			</section>
			
			<section xml:id="node.class-property">
				<title>class-property</title>
				
				<simplelist role="layout">
					<member>identifier</member>
					<member>identikey-type</member>
					<member>? function getter</member>
					<member>? function setter</member>
				</simplelist>
				
				<para role="process">Must have a getter and/or setter. If only identifier and identikey-type are given, an error results.</para>
			</section>
			
			<programlisting>
class Foo {
	...
	construct() {...}
	impl Bar {...}
}

interface of Foo {
	inherit Bar
	call() Bar
}

(Foo as Interface) == Bar //true
			</programlisting>
			
			<programlisting>
class Foo {
	...
	construct() {...}
	impl Bar default {...}
	impl define Bar2 {...} //the identifier "Bar2" is required
}

interface of Foo {
	inherit Bar + {{interface Bar2}}
	call() Bar
	get Interface Bar2
}

(Foo as Interface) == (Bar + Foo.Bar2) //true
			</programlisting>
		</section>

		<section xml:id="node.comprehension">
			<title>comprehension</title>
			
			<para>Used to build collections or generators. A slightly more general form of array/list comprehensions as found in other programming languages. Similar in nature to set-builder notation in mathematics.</para>
			
			<simplelist role="layout">
				<member>comprehension-type</member>
				<member>? expression destination collection</member>
				<member>expression source collection</member>
				<member>identifier element name</member>
				<member>? expression test</member>
				<member>? expression output</member>
			</simplelist>
			
			<para role="process">[comprehension-type] must be set to "provided" if [destination-collection] is present.</para>
			
			<section xml:id="node.comprehension-type">
				<title>comprehension-type</title>
				
				<para>Specifies one of: array, chain, generator, provided</para>
			</section>

			<programlisting>
$decl foo = [2*x for x in L if x^2 > 3]
container: L
element name: x
test: x^2 > 3
output: 2*x

$decl foo = [x in L if x^2 > 3]
container: L
element name: x
test: x^2 > 3
output: (implicit: x)

$decl foo = [x in L]
container: L
element name: x
test: (implicit: true)
output: (implicit: x)

for o in [2*x for x in L if x^2 > 3] {
	println o
}
			</programlisting>
		</section>
		
		<section xml:id="node.copy">
			<title>copy</title>
			
			<para>Attempts to copy a given value.</para>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>? expression interface</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Evaluate the value expression.</listitem>
				<listitem>Evaluate the interface expression or get the active interface of the value.</listitem>
				<listitem>Find the converter to the specified interface (XXX how?) using the same method as finding a property or method.</listitem>
				<listitem>Activate the converter.</listitem>
				<listitem>Evaluate this node to the returned value.</listitem>
			</orderedlist>
			
			<programlisting>
decl Int $num1 = 987
decl Int $num2 = copy($num)
decl Int $num3 := $num
			</programlisting>
		</section>
		
		<section xml:id="node.convert">
			<title>convert</title>
			
			<para>Attempts to convert a given value to a different type.</para>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>? expression interface</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Evaluate the value expression.</listitem>
				<listitem>Evaluate the interface expression or get the active interface of the value.</listitem>
				<listitem>Find the converter to the specified interface (XXX how?) using the same method as finding a property or method.</listitem>
				<listitem>Activate the converter.</listitem>
				<listitem>Evaluate this node to the returned value.</listitem>
			</orderedlist>
			
			<programlisting>
decl Int $num1 = 987
decl Rat $num2 = ($num to Rat)
decl Rat $num3 := $num
			</programlisting>
			
			<para role="xxx">Should the ":=" operator shown in the examples for copy and convert have an associated node? Something like "assign-copy"/"assign-convert"/"assign-new" would be good.</para>
		</section>
		
		<section xml:id="node.dictionary">
			<title>dictionary</title>
			
			<simplelist role="layout">
				<member>? type key type</member>
				<member>? type value type</member>
				<member>* dictionary-entry</member>
			</simplelist>
			
			<section xml:id="node.dictionary-entry">
				<title>dictionary-entry</title>
				
				<simplelist role="layout">
					<member>expression key</member>
					<member>expression value</member>
				</simplelist>
			</section>
		</section>
		
		<section xml:id="node.enum">
			<title>enum</title>
			
			<para>An enum is similar to an immutable dict.</para>
			
			<simplelist role="layout">
				<member>? type</member>
				<member>+ enum-entry</member>
			</simplelist>
			
			<para role="process">If [type] is not given, no enum entries can have a value. If [type] is given, all enum entries must have a value. Note that every enum entry has have a unique value. (XXX include restriction in execution instructions)</para>
			
			<section xml:id="node.enum-entry">
				<title>enum-entry</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>? expression value</member>
				</simplelist>
			</section>
			
			<para>If [type] is given:</para>
			<orderedlist role="exec">
				<listitem>Let EntryFace be a new interface that inherits from EnumDictEntry&lt;T> where T is specified by [type].</listitem>
				<listitem>For every [enum-entry], create a value with EntryFace as the active interface, where the "value" and "name" properties are those specified by the [enum-entry].</listitem>
				<listitem>Let ListFace be a new interface. For every [enum-entry], add a readonly property to ListFace with the type of EntryFace and a name specified by the [enum-entry].</listitem>
				<listitem>Let EnumFace be a new interface that inherits from Interface, EnumDict&lt;T, U>, and ListFace, where T is EntryFace and U is specified by [type].</listitem>
				<listitem>Let EnumInstance be a value with EnumFace as the active interface such that:
					<simplelist>
						<member>the value given from getting a property of ListFace is the value created in step 2 that is associated with the same [enum-entry] as the property</member>
						<member>the Interface implementation is EntryFace, i.e. EnumInstance cast to Interface is EnumFace</member>
					</simplelist>
				</listitem>
				<listitem>Produce EnumInstance.</listitem>
			</orderedlist>
			
			<para>If [type] is not given:</para>
			<orderedlist role="exec">
				<listitem>Let EntryFace be a new interface that inherits from EnumEntry.</listitem>
				<listitem>For every [enum-entry], create a value with EntryFace as the active interface, where the "name" property is that specified by the [enum-entry].</listitem>
				<listitem>Let ListFace be a new interface. For every [enum-entry], add a readonly property to ListFace with the type of EntryFace and a name specified by the [enum-entry].</listitem>
				<listitem>Let EnumFace be a new interface that inherits from Interface, Enum&lt;T>, and ListFace, where T is EntryFace.</listitem>
				<listitem>Let EnumInstance be a value with EnumFace as the active interface such that:
					<simplelist>
						<member>the value given from getting a property of ListFace is the value created in step 2 that is associated with the same [enum-entry] as the property</member>
						<member>the Interface implementation is EntryFace, i.e. EnumInstance cast to Interface is EnumFace</member>
					</simplelist>
				</listitem>
				<listitem>Produce EnumInstance.</listitem>
			</orderedlist>
			
			<para>Note that the sections specifying Enum, EnumDict, EnumEntry, and EnumDictEntry have additional requirements on the behavior of instances of these interfaces.</para>
			
			<screen>
<![CDATA[
enum Animal {
	dog, cat, fish, parrot, ferret, gerbil, hamster
}

interface EntryFace
	inherit EnumEntry

interface ListFace
	get EntryFace dog
	get EntryFace cat
	get EntryFace fish
	get EntryFace parrot
	get EntryFace ferret
	get EntryFace gerbil
	get EntryFace hamster

interface EnumFace
	inherit Interface
	inherit Enum<EntryFace>
	inherit EnumList

Animal a = Animal.dog
Animal b = Animal.fromName("cat")
println Animal.size //assuming size is specified by Collection<T>

for animal in Animal
	println animal.name

activeInterface(Animal) == Interface + Enum<EntryFace> + EnumList
(Animal as Interface) == EntryFace
]]>
			</screen>
		</section>

		<section xml:id="node.function">
			<title>function</title>
			
			<simplelist role="layout">
				<member>* parameter</member>
				<member>return-info</member>
				<member>expression body</member>
			</simplelist>

			<para>XXX specify barrier, which is like the kind of barrier that is in class nodes. Compare this kind of barrier to scope barriers -- nodes that "have scope". The [body] node is not executed when this node is executed, but it may be executed after this node has executed.</para>
			
			<para>When this node is executed, it produces a value with a function interface as the active interface. Only the [parameter] node and [return-info]'s [interface] nodes are executed at this time. When the resultant value is called, the [body] node is executed in the scope of this function node.</para>
		</section>
		
		<section xml:id="node.function-interface">
			<title>function-interface</title>
			
			<simplelist role="layout">
				<member>? expression template-argument-count</member>
				<member>* parameter</member>
				<member>return-info</member>
			</simplelist>
		</section>
		
		<section xml:id="node.generator">
			<title>generator</title>

			<para>Produces a value that implements an instantiation of the Generator generic interface.</para>
			
			<simplelist role="layout">
				<member>type</member>
				<member>expression</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<programlisting>
$decl foo = $generator {
	$decl Int i = 2
	$while i &lt; 5 {
		$yield i
		i++
	}
}

$for i $in foo {
	print foo
	print " "
}

prints: '2 3 4 '

interface of foo == Generator&lt;Int>
			</programlisting>

			<programlisting>
$decl foo = $func(Int a, Int b) Generator&lt;Int> {
	$return $generator {
		$decl Int i = a
		$while i &lt; b {
			$yield i
			i++
		}
	}
}

$for i $in foo(2, 5) {
	print foo
	print " "
}

prints: '2 3 4 '
			</programlisting>
			
			<programlisting>
A representation could provide a construct like that in other languages by combining functions and generators.

$decl foo = $generator(Int a, Int b) Int {
	$decl Int i = a
	$while i &lt; b {
		$yield i
		i++
	}
}

$for i $in foo(2, 5) {
	print foo
	print " "
}

prints: '2 3 4 '
			</programlisting>
		</section>
		
		<section xml:id="node.generic-class">
			<title>generic-class</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>class</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the class node.</para>
		</section>
		
		<section xml:id="node.generic-function">
			<title>generic-function</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>function</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the function node.</para>
			
			<programlisting>
generic(T)
func larger(T a, T b) T {
	if a &lt; b
		return b
	return a
}

println larger(2, 7) //prints "7"
			</programlisting>
		</section>
		
		<section xml:id="node.generic-interface">
			<title>generic-interface</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>interface</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the interface node.</para>
			
			<programlisting>
generic(T)
interface List {
	func addFront(T)
	func addBack(T)
	func removeFront() T
	func removeBack() T
}

List(Int) list = ...
list.addFront(2)
list.addBack(3)
list.addFront(1)
println list.removeFront() //prints "1"
println list.removeBack() //prints "3"
			</programlisting>
		</section>
		
		<section xml:id="node.get-property">
			<title>get-property</title>
			
			<simplelist role="layout">
				<member>expression source</member>
				<member>identifier property name</member>
			</simplelist>
			
			<para>Retrieves the value of a property. If the active interface of the value does not have a property with the specified name, or the property cannot be retrieved, an error results.</para>
		</section>
		
		<section xml:id="node.identifier">
			<title>identifier</title>
			
			<para>Base node. Identifiers can sometimes evaluate to object references. Object references point to an object and have an active interface. Only properties declared by the active interface can be accessed, even if the object implements other interfaces.</para>
			
			<para>When evaluating an identifier to an object: If the identifier is undefined in the current scope, move to the containing scope. If there is no containing scope, throw an UndefinedIdentifier error. Continue moving to outer scopes until the identifier is found or there is no containing scope. If the identifier is bound to an object, the identifier evaluates to that object. If the identifier has been declared that it can be bound to objects, but it is currently not bound to anything, return null. If the identifier is bound to a function, the identifier evaluates to the wrapper for that function, as defined in function-wrapper xxx. If the identifier is bound to a namespace, a NamespaceIdentifier error results.</para>
		</section>
		
		<section xml:id="node.instantiate-generic-class">
			<title>instantiate-generic-class</title>
			
			<simplelist role="layout">
				<member>expression generic class</member>
				<member>+ argument</member>
			</simplelist>
			
			<para>All the arugments must be interfaces. Pass interfaces in to get a function.</para>
		</section>
		
		<section xml:id="node.intantiate-generic-function">
			<title>instantiate-generic-function</title>
			
			<simplelist role="layout">
				<member>expression generic function</member>
				<member>+ argument</member>
			</simplelist>
			
			<para>All the arguments must be interfaces. Pass interfaces in to get a function.</para>
		</section>

		<section xml:id="node.instantiate-generic-interface">
			<title>instantiate-generic-interface</title>
			
			<simplelist role="layout">
				<member>expression generic interface</member>
				<member>+ argument</member>
			</simplelist>
			
			<para>All the arguments must be interfaces. Pass interfaces in to get a function.</para>
		</section>
		
		<section xml:id="node.implements">
			<title>implements</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>expression interface</member>
			</simplelist>
			
			<para>Returns a bool object reference to the true or false objects. True if [object] implements [interface], false otherwise.</para>
			
			<programlisting>
if (o impls Foo)
	(o as Foo).propOfFoo()
			</programlisting>
		</section>
		
		<section xml:id="node.integer">
			<title>integer</title>
			
			<para>Base node. Evaluates to an object reference with BigInt as the active interface. The object may implement other interfaces if they do not conflict with the BigInt interface. Must not implement the LimInt interface.</para>
		</section>
		
		<section xml:id="node.interface">
			<title>interface</title>
			
			<simplelist role="layout">
				<member>* expression inheritees</member>
				<member>* statused-member</member>
			</simplelist>
			
			<section xml:id="node.statused-member">
				<title>statused-member</title>
				
				<simplelist role="layout">
					<member>member-status</member>
					<member>interface-member</member>
				</simplelist>
			</section>
			
			<section xml:id="node.member-status">
				<title>member-status</title>
				
				<para>Base node. Specifies "new", "normal", or "deprecated".</para>
			</section>
			
			<section xml:id="node.interface-member">
				<title>interface-member</title>
				
				<para>Supertype. Includes convertor, callee, property, and method.</para>
			</section>
			
			<section xml:id="node.convertor">
				<title>convertor</title>
				
				<simplelist role="layout">
					<member>? expression interface</member>
				</simplelist>
				
				<para>Specifies that implementations of that interface can be converted into the specified type. Or, if [interface] isn't given, that the value can be copied.</para>
			</section>
			
			<section xml:id="node.callee">
				<title>callee</title>
				
				<simplelist role="layout">
					<member>* parameter</member>
					<member>return-info</member>
				</simplelist>
			</section>
			
			<section xml:id="node.property">
				<title>property</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>? expression interface</member>
					<member>access access</member>
				</simplelist>
			</section>
			
			<section xml:id="node.method">
				<title>method</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>expression interface</member>
				</simplelist>
			</section>
			
			<section xml:id="node.access">
				<title>access</title>
				
				<para>Access nodes must specify one of three access levels: only reading, only writing, or both reading and writing.</para>
			</section>
		</section>
		
		<section xml:id="node.namespaced-identikey">
			<title>namespaced-identikey</title>
			
			<simplelist role="layout">
				<member>+ identifier namespaces</member>
				<member>identifier identikey name</member>
			</simplelist>
			
			<programlisting>
namespace::namespace::identikey

namespace foo {
	namespace bar {
		Int alpha = ...
	}
}
Int alpha = foo::bar::alpha
			</programlisting>
		</section>
		
		<section xml:id="node.rational">
			<title>rational</title>
			
			<para>Base node. Evaluates to an object with BigRat as the active interface. The object may implement other interfaces if they do not conflict with the BigRat interface. Must not implement the LimRat interface.</para>
		</section>
		
		<section xml:id="node.set-property">
			<title>set-property</title>
			
			<para role="xxx">Shouldn't this be merged with the assign node?</para>
			
			<simplelist role="layout">
				<member>expression source</member>
				<member>identifier property name</member>
				<member>expression value</member>
			</simplelist>
			
			<para>Sets the value of a property. If the active interface of the value does not have a property with the specified name, or the property cannot be set, an error results. Evaluates to the value given by [value].</para>
		</section>

		<section xml:id="node.string">
			<title>string</title>
			
			<para>string nodes consist of text</para>
			
			<para>strings are expressions</para>
			
			<para>Base node. Evaluates to an object with interface string as the active interface. The object may implement other interfaces if they do not conflict with the string interface.</para>
		</section>
	</section>
	
	<section xml:id="unsorted-nodes">
		<title>Unsorted nodes</title>

		<section xml:id="node.identifier-chain">
			<title>identifier-chain</title>
			
			<simplelist role="layout">
				<member>boolean namespaced-identikey</member>
				<member>boolean get-property</member>
				<member>boolean bind</member>
				<member>? expression starting value</member>
				<member>+ identifier</member>
			</simplelist>
			
			<para>This node exists for Desal representations that use the same syntax for different associations between identifiers. The associations supported by this node are the same as those of the <link linkend="node.namespaced-identikey">namespaced-identikey</link>, <link linkend="node.get-property">get-property</link>, and <link linkend="node.curry">curry</link> nodes. The optional boolean nodes are all true by default, meaning all associations are supported. If namespaced-identikey is true, the starting value must not be present.</para>
			
			<para>namespaced-identikey associations can be used to evaluate namespaced identikeys.</para>
			
			<screen>
namespace.identikey
namespace.namespace.identikey
			</screen>
			
			<para>get-property associations can be used to get properties of values.</para>
			
			<screen>
starting-value.property.property.property

if namespaced-identikey is also true:
namespace.identikey.property
			</screen>
			
			<para>bind associations can be used to bind a method of a value to a value.</para>
			
			<screen>
alpha.doStuff.apply
			</screen>
			
			<screen>
Different syntax for namespaced identikeys, getting properties, and method binding.

alpha::beta.gamma=>delta

(bind
	(get-property
		(namespaced-identikey
			(namespace alpha)
			(identifier beta))
		(identifier gamma))
	(identifier delta))

Here, alpha must be a namespace, beta must be an identikey, gamma must be a property, and delta must be a method.
			</screen>
			
			<screen>
Shared syntax for namespaced identikey references and getting properties, but different syntax for method binding.

alpha.beta.gamma:delta

(bind
	(chain
		(bind false)
		(identifier alpha)
		(identifier beta)
		(identifier gamma))
	(identifier delta))

Here, alpha could be a free identikey or a namespace. If alpha is a namespace, beta could be a namespace. gamma could be an identikey in the alpha.beta namespace, or a property of the value that beta evaluated to. delta must be a method.
			</screen>
			
			<screen>
Shared syntax for getting properties and method binding, but different syntax for referring to namespaced identikey references.

alpha::beta.gamma.delta

(chain
	(namespaced-identikey false)
	(starting-value
		(namespaced-identikey
			(namespace alpha)
			(identifier beta)))
	(identifier gamma)
	(identifier delta))

Here, alpha must be a namespace and beta must be an identikey within that namespace. gamma could be a property or method of beta. delta could be a property or method of gamma.
			</screen>
			
			<screen>
Same syntax for all.

alpha.beta.gamma.delta

(chain
	(identifier alpha)
	(identifier beta)
	(identifier gamma)
	(identifier delta))

Delta cannot be a namespace.
			</screen>
			
			<screen><![CDATA[
A representation could provide different syntax for each association, but also provide a way to specify that one of multiple assocations are allowed.

alpha :: beta {. or =>} gamma . delta => epsilon

<bind>
	<get-property label="value">
		<chain label="value">
			<bool label="namespaced-idenkey">false</bool>
			<namespaced-identikey label="starting-value">
				<identifer label="namespace">alpha</identifer>
				<identifer label="member">beta</identifer>
			</namespaced-identifer>
			<identifer>gamma</identifer>
		</chain>
		<identifer label="property-name">delta</identifer>
	</get-property>
	<identifier label="method-name">epsilon</identifer>
</bind>

Here, alpha must be a namespace, and beta must be an identikey within that namespace. Gamma can be a property or method of beta. delta must be a property of gamma. epsilon must be a method of delta.
]]>
			</screen>
		</section>
		
		<section xml:id="node.unassign-function">
			<title>unassign-function</title>
			
			<simplelist role="layout">
				<member>expression</member>
				<member>interface</member>
			</simplelist>
			
			<para>Unassigns the function with the specified interface from the given value.</para>
			
			<para role="xxx">What to do when such a function isn't bound? throw an error?</para>
			
			<para>Removed because function identikeys must now always be constant.</para>
		</section>
	</section>
</chapter>