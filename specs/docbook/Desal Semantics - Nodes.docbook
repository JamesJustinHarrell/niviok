<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="node-types">
	<title>Node types</title>

	<para>This chapter describes the various types of nodes.</para>
	
	<section xml:id="base-node-types">
		<title>Base nodes</title>
		
		<para>These node types do not contain child nodes, and are thus the only nodes that must encode information themselves (as opposed to containing child nodes which together provide information).</para>
		
		<simplelist>
			<member linkend="node.access">access</member>
			<member linkend="node.boolean">boolean</member>
			<member linkend="node.direction">direciton</member>
			<member linkend="node.identifier">identifier</member>
			<member linkend="node.identikey-category">identifier-category</member>
			<member linkend="node.integer">integer</member>
			<member linkend="node.rational">rational</member>
			<member linkend="node.string">string</member>
		</simplelist>
	</section>
	
	<section xml:id="tree-node-layout-key">
		<title>Tree node layout key</title>
		
		<para>This section describes how the layout of a node type is represented in this specification.</para>
		
		<para>The layout for a node type is represented in this specification as a list of items. Each item represents a child node or multiple child nodes with the same meaning. Nodes represented by different items are considered to have different meaning.</para>
		
		<para>Each item in these lists first specifies how many child nodes with that meaning may appear, or it says nothing about the number, which means there must be one (and only one). The ways of representing these amounts is described below.</para>
		
		<variablelist>
			<varlistentry>
				<term>?</term>
				<listitem>0 or 1</listitem>
			</varlistentry>
			<varlistentry>
				<term>*</term>
				<listitem>0 or more</listitem>
			</varlistentry>
			<varlistentry>
				<term>+</term>
				<listitem>1 or more</listitem>
			</varlistentry>
		</variablelist>
		
		<para>Next comes the name of a node type or "expression". The child node represented by that list item must be of that type. The string "expression" means the node must be executable.</para>
		
		<para>Lastly comes a label for referring to the child nodes with that meaning. These labels carry no semantic information, and are only a means used to refer to specific nodes. The meaning of child nodes can certainly be represented by other means. However, people creating representations for Desal trees are encouraged to at least consider using these same labels when it makes sense to do so.</para>
	</section>
	
	<section xml:id="non-executable">
		<title>Non-executable</title>
		
		<para>Nodes that cannot be executed. Most server only to group other nodes together.</para>
		
		<section xml:id="node.argument">
			<title>argument</title>
			
			<simplelist role="layout">
				<member>? identifier parameter name</member>
				<member>? expression value</member>
			</simplelist>
			
			<programlisting>
func doSomething(Int a = 1, Int b = 2, Int c = 3, Int d) {...}
doSomething(7, default, default, 8)
doSomething(7, c = default, 8)
			</programlisting>
		</section>
		
		<section xml:id="node.boolean">
			<title>boolean</title>
			
			<para>Base node. Must specify either true or false.</para>
			
			<para>Cannot be evaluated because that would conflict with the prevalent "true" and "false" identifiers. Use "true" and "false" identifiers for expressions instead.</para>
		</section>
		
		<section xml:id="node.bundle">
			<title>bundle</title>
			
			<para>A grouping of library references (import) and groups of declarations (plane).</para>
			
			<simplelist role="layout">
				<member>* import</member>
				<member>* scope-alteration</member>
				<member>+ plane</member>
			</simplelist>
			
			<para>The bundle node type is the type of the root node. No node can contain an bundle node. All Desal nodes that are executed in any way must be part of a complete Desal tree, which means having an bundle node as the root node.</para>
			
			<para role="xxx">Program arguments are no longer passed to the main function, because developers should have a choice of accessing program arguments in different ways, and some implementations may not have program arguments, or have non-string program arguments, etc. The old way just isn't flexible enough. Implementations should give program arguments through some API instead of passing them to the main function.</para>
			
			<orderedlist role="exec">
				<listitem>1. Create the identikeys specified in section XXX to this node's scope.</listitem>
				<listitem>2. Create any implementation-specific identikeys.</listitem>
				<listitem>3. Execute each child identifier-const node in order.</listitem>
			</orderedlist>
			
			<para>When the complete Desal tree is treated as a standalone program, section xxx applies. Otherwise, besides layout and setup, the abilities and behavior of the bundle node is implementation-specific, and execution or evaluation of Desal nodes may occur directly, without going through the bundle node.</para>
			
			<para>The section XXX mentioned above should specify a value bound to "main" with a callee that takes no arguments and either returns nothing or returns an Int.</para>
			
			<para role="xxx">Need a means of hiding/showing certain child namespaces of the global namespace. For example, a bundle acting as a library may have declarations in the global namespace and in a "private" namespace. The bundle should expose the declarations in the global namespace but hide the declarations in the private namespace.</para>
		</section>
		
		<section xml:id="node.direction">
			<title>direction</title>
			
			<para>Specifies the direction of a function parameter, one of: in, in-mutable, out, in-out, in-mutable-out</para>
			
			<para>A value passed to a function as an "in" parameter will not be mutated by the function. This means if the function uses the value in ways that may mutate the value, the value will be copied. If an action in the function may mutate the value, and the value does not declare a copy converter, an error results.</para>
			
			<para>Instances where the value may be mutated include when the interface of the value does not provide opacity information and the function calls a method, or if the interface does provide opacity information but the function calls a mutator method, or if the value is passed to another function as an in-mutable or in-mutable-out parameter.</para>
			
			<programlisting>
func alpha(in Int num) {
println num
}

func beta(in-mutable Int num) {
num += 567
}

func gamma(out Int num) {
//num not currently assigned to anything
num = 987
}

func delta(in-out Int num) {
println num
num = 1001
}

func epsilon(in-mutable-out Int num) {
num += 55555
num = 19591
}

Int num = 123
alpha(num)
beta(num) //value mutated
gamma(num) //num assigned to different value
delta(num) //num assigned to different value
epsilon(num) //value mutated and num assigned to different value
			</programlisting>
		</section>
		
		<section xml:id="node.expose">
			<title>expose</title>
			
			<para>Imports all the child identikeys of the specified namespace into the enclosing scope.</para>
			
			<simplelist role="layout">
				<member>+ identifier</member>
			</simplelist>
			
			<programlisting>
decl std::Array&lt;std::Int> numbers = generateNumbers()

expose std
decl Array&lt;Int> numbers = generateNumbers()
			</programlisting>
		</section>
		
		<section xml:id="node.generic-parameter">
			<title>generic-parameter</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>? expression default interface</member>
			</simplelist>
		</section>
		
		<section xml:id="node.identikey-category">
			<title>identikey-category</title>
			
			<para>specifies one of: namespace, dynamic, automatic, strict, function</para>
			
			<para>See the <link linkend="identikeys">section on identikeys</link>.</para>
		</section>
		
		<section xml:id="node.identikey-type">
			<title>identikey-type</title>
			
			<simplelist role="layout">
				<member>identikey-category</member>
				<member>? nullable-type</member>
				<member>? boolean constant</member>
			</simplelist>

			<para role="process">[type] must be present if and only if the identikey-category is not namespace. The [type] must specify an [interface] if the identikey-category is strict. The [type] can specify an [interface] if the identikey-category is function. The [type] must not specify an [interface] if the identikey-category is namespace, dynamic, or automatic. The [type] must specify false for [nullable] if identikey-category is function. [constant] must not be specified if and only if the identikey-category is namespace or dynamic.</para>
			
			<para>If the category is strict, the active interface of any value bound to the identikey must be that interface. If the category is function, and the interface is given, functions bound to the identikey must specify that interface as the return type.</para>
			
			<para>The default value of [constant] is false. If [constant] is true, the identifier thereafter always refers to the same value. The identifier cannot be bound to a different value, or unbound. The active interface also cannot be changed.</para>
			
			<programlisting>
Int a = 3
func Int a = func()Int { return 3 }
			</programlisting>
		</section>
		
		<section xml:id="node.import">
			<title>import</title>
			
			<para>Binds a library namespace to a namespace identikey.</para>
			
			<simplelist role="layout">
				<member>string library</member>
				<member>identifier alias</member>
			</simplelist>
				
			<programlisting>
import "XmlLib" as Xml

library: "XmlLib"
alias: Xml
			</programlisting>
		</section>
		
		<section xml:id="node.nullable-type">
			<title>nullable-type</title>

			<para>Specifies a value type, including whether the absence of a value is allowed.</para>
			
			<simplelist role="layout">
				<member>? expression interface</member>
				<member>boolean nullable</member>
			</simplelist>
		</section>

		<section xml:id="node.parameter">
			<title>parameter</title>
			
			<para>A function parameter.</para>
			
			<simplelist role="layout">
				<member>direction</member>
				<member>nullable-type</member>
				<member>identifier name</member>
				<member>boolean has default value</member>
				<member>? expression default value</member>
			</simplelist>
			
			<para role="xxx">Should this node be split into e.g. parameter-info and parameter-impl? See next paragraph.</para>
			
			<para>When this node is a child of a function-interface or callee node, [default value] must not be present. (Meaning it can only be present when the child of a function node.) When a [default value] is given because the node is a child of a function node, [default value] is executed for every call to the function. It is not executed when the function node is executed.</para>
		</section>
				
		<section xml:id="node.plane">
			<title>plane</title>
			
			<para>A group of declarations within a bundle.</para>
			
			<simplelist role="layout">
				<member>* scope-alteration</member>
				<member>* identifier namespace</member>
				<member>+ declare-first</member>
			</simplelist>
			
			<para>This node has scope, but only private identifiers are bound to it. Public and exported identifiers are bound to the scope of the bundle node.</para>
			
			<para>Planes aren't expressions because their declare-first nodes might rely on declare-first nodes in other planes, so all the declare-first nodes in a single plane can't just be executed all together.</para>
		</section>
		
		<section xml:id="node.scope-alteration">
			<title>scope-alteration</title>
				
			<para>This is a supertype, like expression. This type includes <link linkend="node.using">using</link> and <link linkend="node.expose">expose</link>.</para>
		</section>
		
		<section xml:id="node.using">
			<title>using</title>
			
			<para>Creates an identikey that is associated with the same value/namespace as the specified identikey in the specified namespace.</para>
			
			<simplelist role="layout">
				<member>+ identifier target</member>
				<member>? identifier name</member>
			</simplelist>
			
			<programlisting>
using Xml.XmlElement
using Xml.XmlDocument as Doc

import ".NET: System" as System
using System.Collections.Generic as box
box.IList&lt;Foo> = new box.List&lt;Foo>();
			</programlisting>
			
			<programlisting>
using FooBarBaz as FBZ
using System.out.print as puts
puts( (FBZ to String)(Gamma) )
			</programlisting>
			
			<para>Each of the [target] identifiers, except for the last, must refer to a namespace. (The last can also refer to a namespace.)</para>
		</section>
	</section>

	<section xml:id="non-producing-expressions">
		<title>Non-producing expressions</title>
		
		<para>Nodes that can be executed, but never produce.</para>

		<section xml:id="iteration">
			<title>Iteration</title>
			
			<para role="xxx">The interface expressions for these nodes need to be replaced with type nodes.</para>
			
			<section xml:id="node.do-while">
				<title>do-while</title>
				
				<simplelist role="layout">
					<member>block action</member>
					<member>expression test</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
do {
	something()
} while test()
				</programlisting>
			</section>
			
			<section xml:id="node.do-times">
				<title>do-times</title>
				
				<simplelist role="layout">
					<member>expression times</member>
					<member>block action</member>
					<member>? expression test</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
do 8 times {
	something()
}

do 8 times {
	something()
} while test()
				</programlisting>
			</section>
			
			<section xml:id="node.for-key">
				<title>for-key</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression key interface</member>
					<member>identifier name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<orderedlist role="exec">
					<listitem>1. Call getKeyIterator on [container].</listitem>
					<listitem>2. Call getNext on [1]. If an exception is thrown with an active interface of GeneratorDone, swallow it and end execution. If anything else is thrown, follow normal exception rules.</listitem>
					<listitem>3. Create a scope.</listitem>
					<listitem>4. Assign [2] to [identifier] in [3].</listitem>
					<listitem>5. Execute [block] with scope [3].</listitem>
					<listitem>6. Go to step 2.</listitem>
				</orderedlist>
				
				<programlisting>
for key x in foo
	doStuff(x)

for key Int x in foo
	doStuff(x)
				</programlisting>
			</section>
			
			<section xml:id="node.for-pair">
				<title>for-pair</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression key interface</member>
					<member>identifier key name</member>
					<member>? expression value interface</member>
					<member>identifier value name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
for pair x y in coords
	drawPoint(x, y)

for pair Int x, Int y in coords
	drawPoint(x, y)
				</programlisting>
			</section>

			<section xml:id="node.for-manual">
				<title>for-manual</title>
				
				<para>Used for manual iteration, as opposed to letting the Desal implementation deal with iteration, like with a for-value node.</para>
				
				<simplelist role="layout">
					<member>* expression initializers</member>
					<member>? expression test</member>
					<member>* expression post actions</member>
					<member>? block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<para>The initializers are executed before iteration begins. Test is evaluated before each iteration. Post actions are executed after each iteration.</para>
				
				<screen>
initializers

test
action
post actions

test
action
post actions

...

test
action
post actions

test

(end of loop)
				</screen>
				
				<programlisting>
for( Int i = 0 ; i &lt; container.length ; i++ ) {
	println container[i]
}

for( Iterator&lt;Int> iterator = container.getIterator() ;
iterator.hasMore? ; iterator.moveNext() ) {
	println iterator.current
}
				</programlisting>
			</section>
			
			<section xml:id="node.for-range">
				<title>for-range</title>
				
				<simplelist role="layout">
					<member>? identifier name</member>
					<member>expression start</member>
					<member>expression limit</member>
					<member>boolean inclusive</member>
					<member>? expression test</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<para>[inclusive] determines whether the loop should iterate one last time if the iteration value is equal to the limit, and it is false by default.</para>
				
				<programlisting>
for 0 to 100
	println "test"

for x from 0 to 100
	println x

for x from 0 to 100 inclusive
	println x

for 0 to string.length while not container.full
	container.push( string.unshift!() )

for x from 0 to 100 while not foo.done?
	foo.runTest(x)
				</programlisting>
			</section>
			
			<section xml:id="node.for-value">
				<title>for-value</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression value interface</member>
					<member>identifier name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
for name in names
	println name

for String name in names
	println name
				</programlisting>
			</section>
			
			<section xml:id="node.loop">
				<title>loop</title>
				
				<simplelist role="layout">
					<member>block</member>
				</simplelist>
				
				<para>Executes block continuously. Can only be exited by expressions in the block such as break and return.</para>
			
				<programlisting>
loop {
	Event event = getNextEvent()
	switch( event ) {
		case Events.QUIT :
			break
	}
}
				</programlisting>
			</section>
			
			<section xml:id="node.while">
				<title>while</title>
				
				<simplelist role="layout">
					<member>expression test</member>
					<member>? block</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
while printNext()

while container.hasMore?
	print container.next
				</programlisting>
			</section>
		</section>
		
		<section xml:id="node.break">
			<title>break</title>
			
			<simplelist role="layout">
				<member>? identifier label</member>
			</simplelist>
		</section>
		
		<section xml:id="node.continue">
			<title>continue</title>
			
			<simplelist>
				<member>? identifier label</member>
			</simplelist>
		</section>
		
		<section xml:id="node.declare-empty">
			<title>declare-empty</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
			</simplelist>
			
			<para role="process">The identikey-type must not be constant.</para>
			
			<para>Creates an identikey in the parent scope with the specified type. After this node executes, the produced identikey does not yet point to any values.</para>

			<programlisting>
decl func Int foo
foo = func()Int { return 3 }
foo = func(Int a)Int { return a * 2 }
print foo() //prints 3
print foo(2) //prints 4

//xxx does this produce error or replace?
foo = func()Int { return 5 }
			</programlisting>

			<programlisting>
decl func()Int foo
foo = func()Int { return 3 }
print foo() //prints 3
foo = func()Int { return 5 }
print foo() //prints 5
foo = func(Int a)Int { return a * 2 } //error - interface mismatch
			</programlisting>
		</section>
		
		<section xml:id="node.declare-first">
			<title>declare-first</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
				<member>expression value</member>
				<member>boolean breed</member>
			</simplelist>
			
			<para role="process">The identikey-type must be constant, and must have a category of automatic, strict, or function.</para>
			
			<para>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</para>
			
			<para>When a block contains declare-first nodes, the declare-first nodes are executed before the other expressions in the block are executed. The value expressions of declare-first nodes may depend on the values of other declare-first nodes in the same block. For example, two interfaces could reference each other.</para>
			
			<para>This node can create identikeys before execution reaches it. For more information, see <link linkend="handling-declare-first">this section</link>.</para>
			
			<para role="exec">Produce the value bound to the identikey created by this node.</para>
			
			<programlisting>
decl-first auto Foo = interface {
	get Bar bar
}

decl-first auto Bar = interface {
	get Foo foo
}

Foo foo = ...
foo.bar.foo.bar...
			</programlisting>
		</section>
		
		<section xml:id="node.labeled">
			<title>labeled</title>
			
			<simplelist role="layout">
				<member>identifier label</member>
				<member>expression child</member>
			</simplelist>
			
			<para role="process">The [child] node must be an iteration node, a block node, a possibility node, a conditional node, or a select node. (XXX update and explain requirements instead of just listing nodes that meet requirements)</para>
			
			<programlisting>
$func setupCell(Int searchID) {
	$decl Cell wantedCell
	
	outer: $for row $in table {
		$for cell $in row {
			$if cell.ID == searchID {
				wantedCell = cell
				$break outer
			}
		}
	}
	
	$if wantedCell != null {
		doSomething(wantedCell)
	}
}
			</programlisting>
		</section>
		
		<section xml:id="node.return">
			<title>return</title>
			
			<simplelist role="layout">
				<member>? expression</member>
			</simplelist>
			
			<para>Function call ends and evaluates to expression.</para>
		</section>
		
		<section xml:id="node.throw">
			<title>throw</title>
			
			<simplelist role="layout">
				<member>expression</member>
			</simplelist>
			
			<para>If the expression isn't an Exception, wrap it with NonExceptionThrownError.</para>
		</section>
	
		<section xml:id="node.yield">
			<title>yield</title>
			
			<para>Within a generator, specifies the next value for the generator to yield.</para>
			
			<simplelist role="layout">
				<member>expression</member>
			</simplelist>
			
			<para role="process">Must be a descendant of a generator node, and not inside a function or class node. (XXX spec out the kind of barriers function and class nodes create)</para>
		</section>
	</section>

	<section xml:id="sometimes-producing-expressions">
		<title>Sometimes producing expressions</title>
		
		<para>Nodes that can be executed, and sometimes produce.</para>

		<section xml:id="node.assign">
			<title>assign</title>
			
			<para>Assigns a value to an identikey.</para>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>expression value</member>
				<member>boolean breed</member>
			</simplelist>
			
			<para role="process">The identikey's type must be dynamic, automatic, or strict. If the identikey's type is automatic or strict, the identifier must be variable (not constant).</para>
			
			<para>If bree is false:</para>
			
			<orderedlist>
				<listitem>Let key by the identikey that [name] refers to.</listitem>
				<listitem>Execute [value] and let value be the product.</listitem>
				<listitem>Associate key with value so that key now refers (only) to value.</listitem>
			</orderedlist>
			
			<para>If breed is true:</para>
			
			<orderedlist>
				<listitem>Let key be the identikey that [name] refers to.</listitem>
				<listitem>Execute [value] and let parentValue be the product.</listitem>
				<listitem>Let faceValue be the required interface for key. If key does not require a particular interface, let faceValue be the active interface of parentValue.</listitem>
				<listitem>Find parentValue's breeder that produces values with an active interface of faceValue. If such a breeder is not found, throw an error.</listitem>
				<listitem>Activate the found breeder and let value be the product.</listitem>
				<listitem>Associate key with value so that key now refers (only) to value.</listitem>
			</orderedlist>
			
			<para>Example of difference between breeding and not breeding:</para>
			
			<programlisting>
decl Person person1
decl Person person2

person1 = Person()
person1.name = "John"
person2 = person1 //not breeding - person1 and person2 refer to same object
person2.name = "Suzy"
println( person1.name ) //Suzy

person1 = Person()
person1.name = "Michael"
person2 := person1 //breeding - person1 and person2 refer to different objects
person2.name = "Kim"
println( person1.name ) //Michael
			</programlisting>
		</section>
		
		<section xml:id="node.block">
			<title>block</title>
			
			<para role="xxx">Come up with better name.</para>
			
			<simplelist role="layout">
				<member>* scope-alteration</member>
				<member>* expression members</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<orderedlist role="exec">
				<listitem>Execute each expression in order. Produce the result of the last expression. (Produce nothing if the block contained no expressions or the last expression didn't produce.)</listitem>
			</orderedlist>
			
			<para>Note: This node type is different from the Dextr concept of blocks. To differentiate between the two, nodes of this type can be called "block nodes", and the syntactic construct of Dextr can be called "Dextr blocks" or "syntactic blocks".</para>
			
			<programlisting>
block {
	using System::Console
	using System::Collections as Boxes
	export Boxes::Generic
	Boxes::List numbers = List&lt;MyFace>()
	Console.WriteLine(numbers.Count.ToString())
}
			</programlisting>
		</section>
		
		<section xml:id="node.call">
			<title>call</title>

			<simplelist role="layout">
				<member>expression value</member>
				<member>* argument</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Execute [value].</listitem>
				<listitem>If the resultant value is not callable, throw an error.</listitem>
				<listitem>Execute the argument expressions in order.</listitem>
				<listitem>Send argument values to the [value] value for execution.</listitem>
				<listitem>Produce the returned value.</listitem>
			</orderedlist>
		</section>
			
		<section xml:id="node.conditional">
			<title>conditional</title>
			
			<simplelist role="layout">
				<member>+ possibility</member>
				<member>? expression else</member>
			</simplelist>
			
			<para role="exec">Execute the [test] of the first [possibilty]. Downcast the resultant value to a Bool. If it is true, execute the [result] of that [possibilty] and produce the result. Otherwise, move on to the next node. If no [test] produces true, and [else] is given, execute [else] and produce its result.</para>
			
			<programlisting>
$decl Int a = (x ? 0 : 1)

$if foo == 1
	doStuff1()
$elif foo == 2
	doStuff2()
$else
	doDefault()

$decl bar =
	(foo == 1) ? getOne() :
	(foo == 2) ? getTwo() :
	getDefault()

$decl bar =
	$if foo == 1 : $eval getOne()
	$elif foo == 2 : $eval getTwo()
	$else : $eval getDefault()
			</programlisting>
		</section>
		
		<section xml:id="node.curry">
			<title>curry</title>
			
			<para>Provides a built-in means of partial application. (Note that Desal provides no built-in support for the original type of currying, where a multi-argument function is converted into a chain of single-argument functions.)</para>
			
			<simplelist role="layout">
				<member>expression function</member>
				<member>* argument</member>
				<member>boolean call</member>
			</simplelist>

			<para>If [call] is true, and this node results in the function receiving enough arguments to be called, the function will be called.</para>
			
			<programlisting>
func foo(Int a, Rat b, String c, Bool d) Int {
	...
}

//partial application
func(String,Bool)Int foo2 = foo(1, 2.34)
print foo2("text", true)

//other type of currying
func(Int)(
	func(Rat)(
		func(String)(
			func(Bool)Int ))) foo3 = curry(foo)
print foo3(1)(2.34)("text")(true)

//The above two are equivalent to:
print foo(1, 2.34, "text", true)
			</programlisting>
			
			<para>Assuming the function is not called: If the arguments match only one of the callees/methods of [value], this node produces a value with a function interface as the active interface. If the arguments match more than one of the callees/methods on [value], this node produces a value with an active interface that is made by adding the function interfaces of the callees/methods together.</para>
			
			<para>After execution, the specified parameters have values, so they do not appear on the resultant function.</para>
			
			<para>Once the function has all its arguments supplied, it is called if [call] is true, and the result of that call is produced.</para>
			
			<programlisting>
func doStuff1(Int a, String b, Bool alpha) {...}
func doStuff1(Int a, Rat b, Bool alpha) {...}
func doStuff2 = doStuff1~(3, alpha=false)
doStuff2("test")
doStuff2(123.456)
			</programlisting>
			
			<para>The middle line perhaps might also be represented this way:</para>
			<programlisting>
(declare-first
	(identifier.name "doStuff2")
	(curry
		(identifier.value "doStuff1")
		(argument
			(integer.value 3))
		(argument
			(identifier.name "alpha")
			(identifier.value "false"))))
			</programlisting>

			<programlisting>
interface Alpha
func bar(Int a, Rat b, String c)

Alpha alpha = AlphaClass()

alpha.bar(0, 0.0, "0")

func()void bar1 = alpha.bar~()
bar(1, 2.3, "4")

func()void bar2 = alpha.bar~(c="text")
bar2(7, 9.8)

func()void bar3 = alpha.bar~(-9, 0.001, "stuff")
bar3()
			</programlisting>
		</section>
		
		<section xml:id="node.declare-assign">
			<title>declare-assign</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
				<member>expression value</member>
				<member>boolean breed</member>
			</simplelist>
			
			<para role="process">The identikey-category of the identikey-type node must be dynamic, automatic, strict, or function.</para>
			
			<para>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</para>
		</section>
		
		<section xml:id="node.ignore">
			<title>ignore</title>
			
			<para>Instructs an agent to not output certain warnings.</para>
			
			<simplelist role="layout">
				<member>expression content</member>
				<member>+ ignore-member</member>
			</simplelist>
			
			<section xml:id="node.ignore-member">
				<title>ignore-member</title>
				
				<simplelist role="layout">
					<member>string name</member>
					<member>integer depth</member>
				</simplelist>
			
				<para>The [name] can be a warning name from the <link linkend="warnings-list">specified warnings</link> or an agent-defined warning name. Unknown warning names should by default produce a warning that the warning name is unknown. Agents should provide an option to disable warnings for unknown warning names.</para>
				
				<para>The [depth] specifies what descendant nodes are affected by the ignore node. Counting begins at one with the [content] node of the ignore node and increments by one for each further descendant.</para>
				
				<programlisting>
(ignore
	(ignore-member
		(string.name "always null")
		(integer.depth ...))
	(call.content
		(function.identifier println)
		(assignment.argument
			(identifier.name foo)
			(for-value.value
				...))))
				</programlisting>
				
				<para>Here, if the [depth] was 1, a warning should be output by the agent for the assignment node that the [value] node will never produce a value when executed (a.k.a. always evaluate to null).</para>
			</section>
		</section>

		<section xml:id="node.namespaced-value-identikey">
			<title>namespaced-value-identikey</title>
			
			<simplelist role="layout">
				<member>+ identifier namespaces</member>
				<member>identifier identikey name</member>
			</simplelist>
			
			<programlisting>
namespace foo {
	namespace bar {
		decl Int alpha = 123
	}
}
decl Int alpha = foo:bar:alpha
println( alpha ) //123
			</programlisting>
		</section>
		
		<section xml:id="node.possibility">
			<title>possibility</title>
			
			<simplelist role="layout">
				<member>expression test</member>
				<member>expression result</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<para role="process">An error results if the implementation knows [test] will never evaluate to a value that can be downcast to Bool.</para>
			
			<orderedlist role="exec">
				<listitem>Evaluate [test].</listitem>
				<listitem>Downcast [1] to Bool.</listitem>
				<listitem>If [2] is true, evaluate [result].</listitem>
				<listitem>Evaluate this node to [3].</listitem>
			</orderedlist>
			
			<programlisting>
if not foo.isSetup? {
	foo.setup()
}
			</programlisting>
		</section>
		
		<section xml:id="node.select">
			<title>select</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>* case</member>
				<member>? expression else</member>
			</simplelist>
			
			<para role="exec">Execute [value]. Execute each [values] child of each [case] and compare them to the [value] value (with the .equals? method of the [value] value) until finding a match. Then, execute the [result] of that case and produce the result. If no match is found, and [else] is given, execute [else] and produce its result.</para>
			
			<section xml:id="node.case">
				<title>case</title>
				
				<simplelist role="layout">
					<member>+ expression values</member>
					<member>expression result</member>
				</simplelist>
			</section>
			
			<programlisting>
$select event.type
$case Events.QUIT {
	$return
}
$case Events.FOO, Events.BAR, Events.MAZ {
	//no action
}
$else {
	$throw ErrorClass("unknown event type")
}

$select foo
$case 1
	doStuff1()
$case 2
	doStuff2()
$else
	doDefault()

$decl bar = $select foo
	$case 1 : $eval getOne()
	$case 2 : $eval getTwo()
	$else $eval getDefault()
			</programlisting>
		</section>
		
		<section xml:id="node.try-catch">
			<title>try-catch</title>
			
			<simplelist role="layout">
				<member>expression try</member>
				<member>* exception-handler</member>
				<member>? expression else</member>
				<member>? expression finally</member>
			</simplelist>
			
			<para role="xxx">The term "else" is not descriptive enough in this situation. Possible replacements: "onsuccess", "then"</para>
			
			<para role="process">Must contain more than just [try].</para>
			
			<section xml:id="node.exception-handler">
				<title>exception-handler</title>

				<simplelist role="layout">
					<member>boolean catch</member>
					<member>expression interface</member>
					<member>? identifier name</member>
					<member>expression result</member>
				</simplelist>
			</section>
			
			<programlisting>
$try {
	$decl foo = getSomething()
}
$observe( OutOfMemoryError ) {
	println "I'm not catching that!"
	//exception is noticed by this try-catch node, but not caught
	//the exception continues to rise out
}
$catch( NullError ) {
	println "null error"
}
$catch( FooError e ) {
	println "FooError: $(e.message)"
}
$catch( Error ) {
	println "unknown error"
}
$catch( Exception ) {
	println "unknown exception"
}
$observe {
	println "how execution reach here? am not good with computer"
}
$else {
	println "no errors!"
	doSomeStuff() //don't catch errors from this in this node
}
$finally {
	cleanup(foo)
}

$decl Status stat =
$try {
	doSomething()
	Statuses.SUCCESS
}
$catch( NotSoBadError ) {
	Statuses.ERROR
}
$observe {
	println "something bad when trying to doSomething()"
}
			</programlisting>
		</section>
		
		<section xml:id="node.unassign">
			<title>unassign</title>
			
			<simplelist role="layout">
				<member>identifier</member>
			</simplelist>
			
			<para>Unassigns the values bound to the given reference. If the identikey is a function identikey, all bound functions are unbound.</para>
			
			<para role="xxx">Is this needed? Why not just assign null?</para>
		</section>
	</section>
	
	<section xml:id="always-producing-expresions">
		<title>Always producing expressions</title>
		
		<para>Expressions that, aside from e.g. exceptions, always produce when executed. These nodes, other than the and, nand, or, and nor nodes, are not intended to have side effects.</para>
		
		<section xml:id="boolean-logic">
			<title>Boolean logic</title>
			
			<section xml:id="node.and">
				<title>and</title>
				
				<para>Evaluates to false if either child expression evaluates to false.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is false, evaluate this node to false.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.nand">
				<title>nand</title>
				
				<para>Evaluates to true if either child expression evaluates to false.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is false, evaluate this node to true.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to the inverse of [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.or">
				<title>or</title>
				
				<para>Evaluates to true if either child expression evaluates to true.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is true, evaluate this node to true.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.nor">
				<title>nor</title>
				
				<para>Evaluates to false if either child expression evaluates to true.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is true, evaluate this node to false.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to the inverse of [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.xor">
				<title>xor</title>
				
				<para>Evaluates to true if the child expressions evaluate to different values.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [3] to Bool.</listitem>
					<listitem>If [2] and [4] are different, evaluate to true. Otherwise, evaluate to false.</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.xnor">
				<title>xnor</title>
				
				<para>Evaluates to true if the child expressions evaluate to the same value.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [3] to Bool.</listitem>
					<listitem>If [2] and [4] are the same, evaluate to true. Otherwise, evaluate to false.</listitem>
				</orderedlist>
			</section>
		</section>
		
		<section xml:id="node.array">
			<title>array</title>
			
			<simplelist role="layout">
				<member>nullable-type</member>
				<member>* expression element</member>
			</simplelist>
			
			<para>Evaluates to an object with interface array as the active interface. The object may implement other interfaces if they do not conflict with the array interface.</para>
			
			<para>Each [element] is cast to [interface]. If a cast error results, it raises out of the array node, so that the array node doesn't evaluate to anything.</para>
		</section>
		
		<section xml:id="node.breed">
			<title>breed</title>
			
			<para>Creates a new object ("offspring") that encodes some or all of the information from the parent, and exposes that information through the specified interface. If an interface is not specified, the new object has same type as the parent, and should encode most or all of the information from the parent. If an interface is specified, the new object may be an exact copy of the parent object, or it may be of a completetly different form that encodes very little information from the parent object.</para>
			
			<para>This node can be used to copy a value, or to convert a value into a different type.</para>
			
			<simplelist role="layout">
				<member>expression parent</member>
				<member>? expression interface</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Execute [parent] and let parentValue be the product.</listitem>
				<listitem>Execute [interface] and let faceValue be the product. If [interface] is not given, let faceValue be the active interface of parentValue.</listitem>
				<listitem>Find parentValue's breeder that produces values with faceValue as the active interface. If such a breeder is not found, throw an error.</listitem>
				<listitem>Activate the found breeder.</listitem>
				<listitem>Produce the new value produced by the breeder.</listitem>
			</orderedlist>
			
			<programlisting>
decl Int num1 = 987
decl Int num2 = copy(num)
decl Rat num3 = (num to Rat)
			</programlisting>
		</section>
		
		<section xml:id="node.caller">
			<title>caller</title>
			
			<simplelist role="layout">
				<member>? expression interface</member>
				<member>identifier method name</member>
			</simplelist>
			
			<para>Creates a function that, when passed the type specified by [interface], calls the method named [method name] on the first argument with the rest of the arguments sent to it. It's purpose is to help with functional programming.</para>
			
			<programlisting>
interface Foo {
	func doStuff(Int, Int) Rat
}

Foo foo = getFoo()
func(Foo,Int,Int)Rat doStuffer = Foo::doStuff
println doStuffer(foo,3,7)

dyn doStuffer2 = dyn::doStuff
println doStuffer2(foo,3,7)

//below all equilavent:
println Foo::doStuff(foo,3,7)
println dyn::doStuff(foo,3,7)
println foo.doStuff(3,7)
			</programlisting>
		</section>
		
		<section xml:id="node.cast">
			<title>cast</title>
			
			<simplelist role="layout">
				<member>expression object</member>
				<member>expression interface</member>
			</simplelist>
			
			<para>Evaluates to an object reference where the active interface is [interface] and the object is [object]. If [object] does not implement [interface], an error results.</para>
			
			<programlisting>
Int o = getIntAndString()
print (o as String).length
			</programlisting>
		</section>
		
		<section xml:id="node.chain">
			<title>chain</title>
			
			<para>Creates a doubly-linked list from the provided elements.</para>

			<simplelist role="layout">
				<member>nullable-type</member>
				<member>* expression element</member>
			</simplelist>
			
			<para>Evaluates to a list, as if calling CList&lt; [interface] > ( [element], [element], ... )</para>
			
			<para>Each [element] is cast to [interface]. If a cast error results, it raises out of the list node, so that the list node doesn't evaluate to anything.</para>
		</section>
		
		<section xml:id="node.class">
			<title>class</title>
			
			<para>Evaluates to a value that, when called, produces other values. The interfaces supported by the produced values are implemented in the way specified by this class node. The active interface of the produced value is specified by this class.</para>
			
			<para>The active interface of the value that is produced when a class node is executed inherits from the master interface of the class. The master interface is the sum of all the root interfaces implemented by the class.</para>
			
			<para role="xxx">XML comments with important information</para>
			
			<simplelist role="layout">
				<!-- private and possibly public; can't be "call" or "callee" -->
				<member>* static-member static declarations</member>
				
				<!-- private -->
				<member>? block static constructor</member>
				
				<!-- public -->
				<member>* function static callees</member>
				
				<!-- public -->
				<member>* class-property static properties</member>
				
				<!-- private and public -->
				<member>* function instance constructors</member>
				
				<!-- private -->
				<member>* declaration instance declarations</member>
				
				<!-- private and public -->
				<member>* interface-implementation</member>
			</simplelist>
			
			<para>XXX The static callees and static properties may not always be visible in the class node's scope. (An example of being visible is assigning the value produced by the class node to an identifier.) Should some identifier (e.g. "thisClass") be introduced that evaluates to the class's value? (e.g. thisClass.property = foo) Or should a general means of accessing the enclosing expression node's value be introduced? (e.g. thisValue.property = foo)</para>
			
			<para>The above is not a problem for interface implementations due to the "this" identikey being bound to the active instance.</para>
			
			<para>The children of class nodes can be grouped by several means.</para>
			
			<para>By count:</para>
			<table>
				<tbody>
					<tr>
						<th></th>
						<th>public</th>
						<th>private</th>
					</tr>
					<tr>
						<th>static - only 1</th>
						<td>callees, getters/setters, methods, interface-implementations</td>
						<td>static constructor, instance constructors, static declarations, instance methods</td>
					</tr>
					<tr>
						<th>instance - 1 per instance</th>
						<td></td>
						<td>instance declarations</td>
					</tr>
				</tbody>
			</table>
			
			<para>By scopes: (in scope means something can be accessed through a single identifier as a free identikey)</para>
			<simplelist>
				<member>static scope
					<simplelist>
						<member>public
							<simplelist>
								<member>defined by: static declarations (as properties and methods; must have access with get and/or set), static properties, instance constructors (as callees)</member>
								<member>in scope: (none)</member>
							</simplelist>
						</member>
						<member>private
							<simplelist>
								<member>defined by: static declarations, instance constructors (as functions bound to "construct")</member>
								<member>in scope: static constructor, callees, getters/setters, methods, expressions in static declarations</member>
							</simplelist>
						</member>
					</simplelist>
				</member>
				<member>instance scope
					<simplelist>
						<member>public
							<simplelist>
								<member>defined by: interface-implementations (or really, by the interface)</member>
								<member>in scope: (none)</member>
							</simplelist>
						</member>
						<member>private
							<simplelist>
								<member>defined by: instance declarations, instance methods</member>
								<member>in scope: expressions in instance declarations, instance methods, interface implementations, instance constructors</member>
							</simplelist>
						</member>
					</simplelist>
				</member>
			</simplelist>
			
			<para>Note: Instance scopes are children of the static scope.</para>
			
			<para role="process">Must have at least one interface-implementation. Including the interface-implementation nodes that are inherited by this class's child interface-implementation nodes, one and only one of the interface-implementation nodes must be specified as default.</para>
			
			<orderedlist role="exec">
				<listitem>Create scope, STATIC_SCOPE.</listitem>
				<listitem>Create an interface, CLASS_INTERFACE.</listitem>
				<listitem>Add instance constructors as free functions to STATIC_SCOPE.</listitem>
				<listitem>Add instance constructors as callees to CLASS_INTERFACE.</listitem>
				<listitem>Evaluate the declaration of every <link linkend="node.static-member">static-member</link> that has a <link linkend="node.declare-first">declare-first</link>, in the scope of STATIC_SCOPE. If the identikey-type of the <link linkend="node.declare-first">declare-first</link> is function, and it has access of get, add a method to CLASS_INTERFACE with the same function interface and name. Otherwise, create a property with a getter if declared public.</listitem>
				<listitem>Evaluate the declarations of the rest of the static-member nodes in the scope of STATIC_SCOPE, except for the static-member nodes with a declare-const-empty. Create properties as appropriate when the access nodes specify to do so.</listitem>
				<listitem>In the scope of STATIC_SCOPE, evaluate the static-member nodes that have declare-const-empty nodes. Create properties as appropriate when the access nodes specify to do so.</listitem>
				<listitem>Add the static callees as free functions in STATIC_SCOPE.</listitem>
				<listitem>Add the static callees and the static properties to CLASS_INTERFACE.</listitem>
				<listitem>Execute the static constructor.</listitem>
				<listitem>Seal the identikeys created by the declare-const-empty nodes, meaning don't allow their bound status to change.</listitem>
				<listitem>Create a value with CLASS_INTERFACE as the active interface.</listitem>
				<listitem>Evaluate this node to the above value.</listitem>
			</orderedlist>
			
			<para>When a constructor is called:</para>
			<orderedlist role="exec">
				<listitem>Create a scope, INSTANCE_SCOPE. Set STATIC_SCOPE as the parent scope.</listitem>
				<listitem>Evaluate all declare-first nodes in scope of INSTANCE_SCOPE.</listitem>
				<listitem>Execute the appropriate constructor.</listitem>
				<listitem>Evaluate the function-call that lead to this constructor being evaluated to a value with INSTANCE_SCOPE as the object and the default interface implementation of the class as the active interface implementation.</listitem>
				<listitem>Note: When the interface implementation is used, the value will pass the object into the interface implementation.</listitem>
			</orderedlist>
			
			<section xml:id="node.static-member">
				<title>static-member</title>
				
				<simplelist role="layout">
					<member>declaration</member>
					<member>? access</member>
				</simplelist>
				
				<para role="process">If the declaration declares a const identifier, and access is present, the access node must be declared get.</para>
				
				<para role="xxx">poorly named</para>
			</section>
			
			<section xml:id="node.declaration">
				<title>declaration</title>
				
				<para>declaration is a family of node types, like expression. The node types included in this family are:</para>
				
				<simplelist role="family-members">
					<member>declare-empty</member>
					<member>declare-assign</member>
					<member>declare-first</member>
					<member>declare-const-empty</member>
				</simplelist>
			</section>
			
			<section xml:id="node.declare-const-empty">
				<title>declare-const-empty</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>identikey-type</member>
				</simplelist>
				
				<para>Identifiers created by this node are always const. [identikey-type] must be value or function. The class's static constructor is allowed to assign values to static identifiers created by this node. If anthing tries to assign a value to an identikey create by this node, and the identikey is already bound to something, throw an error. The class's instance constructors are allowed to assign values to instance identifiers created by this node. An error results if identikeys produced by declare-const-empty nodes are dereferenced before being bound to anything.</para>
			</section>
	
			<section xml:id="node.interface-implementation">
				<title>interface-implementation</title>
				
				<simplelist role="layout">
					<member>* interface-implementation children</member>
					<member>expression interface</member>
					<member>* function callee</member>
					<member>* named-function getter</member>
					<member>* named-function setter</member>
					<member>* named-function method</member>
					<member>boolean default</member>
				</simplelist>
			</section>
			
			<section xml:id="node.named-function">
				<title>named-function</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>function function</member>
				</simplelist>
			</section>
			
			<section xml:id="node.class-property">
				<title>class-property</title>
				
				<simplelist role="layout">
					<member>identifier</member>
					<member>identikey-type</member>
					<member>? function getter</member>
					<member>? function setter</member>
				</simplelist>
				
				<para role="process">Must have a getter and/or setter. If only identifier and identikey-type are given, an error results.</para>
			</section>
			
			<programlisting>
class Foo {
	...
	construct() {...}
	impl Bar {...}
}

interface of Foo {
	inherit Bar
	call() Bar
}

(Foo as Interface) == Bar //true
			</programlisting>
			
			<programlisting>
class Foo {
	...
	construct() {...}
	impl Bar default {...}
	impl define Bar2 {...} //the identifier "Bar2" is required
}

interface of Foo {
	inherit Bar + {{interface Bar2}}
	call() Bar
	get Interface Bar2
}

(Foo as Interface) == (Bar + Foo.Bar2) //true
			</programlisting>
		</section>

		<section xml:id="node.comprehension">
			<title>comprehension</title>
			
			<para>Used to build collections or generators. A slightly more general form of array/list comprehensions as found in other programming languages. Similar in nature to set-builder notation in mathematics.</para>
			
			<simplelist role="layout">
				<member>comprehension-type</member>
				<member>? expression destination collection</member>
				<member>expression source collection</member>
				<member>identifier element name</member>
				<member>? expression test</member>
				<member>? expression output</member>
			</simplelist>
			
			<para role="process">[comprehension-type] must be set to "provided" if [destination-collection] is present.</para>
			
			<section xml:id="node.comprehension-type">
				<title>comprehension-type</title>
				
				<para>Specifies one of: array, chain, generator, provided</para>
			</section>

			<programlisting>
$decl foo = [2*x for x in L if x^2 > 3]
container: L
element name: x
test: x^2 > 3
output: 2*x

$decl foo = [x in L if x^2 > 3]
container: L
element name: x
test: x^2 > 3
output: (implicit: x)

$decl foo = [x in L]
container: L
element name: x
test: (implicit: true)
output: (implicit: x)

for o in [2*x for x in L if x^2 > 3] {
	println o
}
			</programlisting>
		</section>
		
		<section xml:id="node.dictionary">
			<title>dictionary</title>
			
			<simplelist role="layout">
				<member>nullable-type key type</member>
				<member>nullable-type value type</member>
				<member>* dictionary-entry</member>
			</simplelist>
			
			<section xml:id="node.dictionary-entry">
				<title>dictionary-entry</title>
				
				<simplelist role="layout">
					<member>expression key</member>
					<member>expression value</member>
				</simplelist>
			</section>
		</section>
		
		<section xml:id="node.enum">
			<title>enum</title>
			
			<para>An enum is similar to an immutable dict.</para>
			
			<simplelist role="layout">
				<member>? nullable-type</member>
				<member>+ enum-entry</member>
			</simplelist>
			
			<para role="process">If [type] is not given, no enum entries can have a value. If [type] is given, all enum entries must have a value. Note that every enum entry has have a unique value. (XXX include restriction in execution instructions)</para>
			
			<section xml:id="node.enum-entry">
				<title>enum-entry</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>? expression value</member>
				</simplelist>
			</section>
			
			<para>If [type] is given:</para>
			<orderedlist role="exec">
				<listitem>Let EntryFace be a new interface that inherits from EnumDictEntry&lt;T> where T is specified by [type].</listitem>
				<listitem>For every [enum-entry], create a value with EntryFace as the active interface, where the "value" and "name" properties are those specified by the [enum-entry].</listitem>
				<listitem>Let ListFace be a new interface. For every [enum-entry], add a readonly property to ListFace with the type of EntryFace and a name specified by the [enum-entry].</listitem>
				<listitem>Let EnumFace be a new interface that inherits from Interface, EnumDict&lt;T, U>, and ListFace, where T is EntryFace and U is specified by [type].</listitem>
				<listitem>Let EnumInstance be a value with EnumFace as the active interface such that:
					<simplelist>
						<member>the value given from getting a property of ListFace is the value created in step 2 that is associated with the same [enum-entry] as the property</member>
						<member>the Interface implementation is EntryFace, i.e. EnumInstance cast to Interface is EnumFace</member>
					</simplelist>
				</listitem>
				<listitem>Produce EnumInstance.</listitem>
			</orderedlist>
			
			<para>If [type] is not given:</para>
			<orderedlist role="exec">
				<listitem>Let EntryFace be a new interface that inherits from EnumEntry.</listitem>
				<listitem>For every [enum-entry], create a value with EntryFace as the active interface, where the "name" property is that specified by the [enum-entry].</listitem>
				<listitem>Let ListFace be a new interface. For every [enum-entry], add a readonly property to ListFace with the type of EntryFace and a name specified by the [enum-entry].</listitem>
				<listitem>Let EnumFace be a new interface that inherits from Interface, Enum&lt;T>, and ListFace, where T is EntryFace.</listitem>
				<listitem>Let EnumInstance be a value with EnumFace as the active interface such that:
					<simplelist>
						<member>the value given from getting a property of ListFace is the value created in step 2 that is associated with the same [enum-entry] as the property</member>
						<member>the Interface implementation is EntryFace, i.e. EnumInstance cast to Interface is EnumFace</member>
					</simplelist>
				</listitem>
				<listitem>Produce EnumInstance.</listitem>
			</orderedlist>
			
			<para>Note that the sections specifying Enum, EnumDict, EnumEntry, and EnumDictEntry have additional requirements on the behavior of instances of these interfaces.</para>
			
			<screen>
<![CDATA[
enum Animal {
	dog, cat, fish, parrot, ferret, gerbil, hamster
}

interface EntryFace
	inherit EnumEntry

interface ListFace
	get EntryFace dog
	get EntryFace cat
	get EntryFace fish
	get EntryFace parrot
	get EntryFace ferret
	get EntryFace gerbil
	get EntryFace hamster

interface EnumFace
	inherit Interface
	inherit Enum<EntryFace>
	inherit EnumList

Animal a = Animal.dog
Animal b = Animal.fromName("cat")
println Animal.size //assuming size is specified by Collection<T>

for animal in Animal
	println animal.name

activeInterface(Animal) == Interface + Enum<EntryFace> + EnumList
(Animal as Interface) == EntryFace
]]>
			</screen>
		</section>
		
		<section xml:id="node.extract-member">
			<title>extract-member</title>
			
			<simplelist role="layout">
				<member>expression source</member>
				<member>identifier member name</member>
			</simplelist>
			
			<para>Retrieves the a method or the value of a property from the value specified by [source]. If the active interface of the value specified by [source] does not have a property or method with the specified name, throw an exception.</para>
		</section>

		<section xml:id="node.function">
			<title>function</title>
			
			<simplelist role="layout">
				<member>* parameter</member>
				<member>? nullable-type return info</member>
				<member>expression body</member>
			</simplelist>

			<para role="xxx">Specify barrier, which is like the kind of barrier that is in class nodes. Compare this kind of barrier to scope barriers -- nodes that "have scope". The [body] node is not executed when this node is executed, but it may be executed after this node has executed.</para>
			
			<para>If [return info] is not present, the function does not return anything. I.e., it does not produced a value when call.</para>
			
			<para>When this node is executed, it produces a value with a function interface as the active interface. Only the [parameter] node and [return info]'s [interface] nodes are executed at this time. When the resultant value is called, the [body] node is executed in the scope of this function node.</para>
		</section>
		
		<section xml:id="node.function-interface">
			<title>function-interface</title>
			
			<simplelist role="layout">
				<member>? expression template-argument-count</member>
				<member>* parameter</member>
				<member>? nullable-type return info</member>
			</simplelist>
		</section>
		
		<section xml:id="node.generator">
			<title>generator</title>

			<para>Produces a value that implements an instantiation of the Generator generic interface.</para>
			
			<simplelist role="layout">
				<member>? nullable-type</member>
				<member>expression</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<para>If [type] is not given, the generator does not produce. (The generator could still be useful for producing side effects.)</para>
			
			<programlisting>
$decl foo = $generator {
	$decl Int i = 2
	$while i &lt; 5 {
		$yield i
		i++
	}
}

$for i $in foo {
	print foo
	print " "
}

prints: '2 3 4 '

interface of foo == Generator&lt;Int>
			</programlisting>

			<programlisting>
$decl foo = $func(Int a, Int b) Generator&lt;Int> {
	$return $generator {
		$decl Int i = a
		$while i &lt; b {
			$yield i
			i++
		}
	}
}

$for i $in foo(2, 5) {
	print foo
	print " "
}

prints: '2 3 4 '
			</programlisting>
			
			<programlisting>
A representation could provide a construct like that in other languages by combining functions and generators.

$decl foo = $generator(Int a, Int b) Int {
	$decl Int i = a
	$while i &lt; b {
		$yield i
		i++
	}
}

$for i $in foo(2, 5) {
	print foo
	print " "
}

prints: '2 3 4 '
			</programlisting>
		</section>
		
		<section xml:id="node.generic-class">
			<title>generic-class</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>class</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the class node.</para>
		</section>
		
		<section xml:id="node.generic-function">
			<title>generic-function</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>function</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the function node.</para>
			
			<programlisting>
generic(T)
func larger(T a, T b) T {
	if a &lt; b
		return b
	return a
}

println larger(2, 7) //prints "7"
			</programlisting>
		</section>
		
		<section xml:id="node.generic-interface">
			<title>generic-interface</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>interface</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the interface node.</para>
			
			<programlisting>
generic(T)
interface List {
	func addFront(T)
	func addBack(T)
	func removeFront() T
	func removeBack() T
}

List(Int) list = ...
list.addFront(2)
list.addBack(3)
list.addFront(1)
println list.removeFront() //prints "1"
println list.removeBack() //prints "3"
			</programlisting>
		</section>
		
		<section xml:id="node.identifier">
			<title>identifier</title>
			
			<para>Base node. Identifiers can sometimes evaluate to object references. Object references point to an object and have an active interface. Only properties declared by the active interface can be accessed, even if the object implements other interfaces.</para>
			
			<para>When evaluating an identifier to an object: If the identifier is undefined in the current scope, move to the containing scope. If there is no containing scope, throw an UndefinedIdentifier error. Continue moving to outer scopes until the identifier is found or there is no containing scope. If the identifier is bound to an object, the identifier evaluates to that object. If the identifier has been declared that it can be bound to objects, but it is currently not bound to anything, return null. If the identifier is bound to a function, the identifier evaluates to the wrapper for that function, as defined in function-wrapper xxx. If the identifier is bound to a namespace, a NamespaceIdentifier error results.</para>
		</section>
		
		<section xml:id="node.instantiate-generic">
			<title>instantiate-generic</title>
			
			<para role="xxx">Need to decide how to include type information. Type value, or type node? Write down and compare pros and cons. (Some related info in "type occurrence.txt")</para>
			
			<simplelist role="layout">
				<member>expression generic</member>
				<member>+ argument</member>
			</simplelist>
		</section>
		
		<section xml:id="node.integer">
			<title>integer</title>
			
			<para>Base node. Evaluates to an object reference with BigInt as the active interface. The object may implement other interfaces if they do not conflict with the BigInt interface. Must not implement the LimInt interface.</para>
		</section>
		
		<section xml:id="node.interface">
			<title>interface</title>
			
			<simplelist role="layout">
				<member>* expression inheritees</member>
				<member>* statused-member</member>
			</simplelist>
			
			<section xml:id="node.statused-member">
				<title>statused-member</title>
				
				<simplelist role="layout">
					<member>member-status</member>
					<member>interface-member</member>
				</simplelist>
			</section>
			
			<section xml:id="node.member-status">
				<title>member-status</title>
				
				<para>Base node. Specifies "new", "normal", or "deprecated".</para>
			</section>
			
			<section xml:id="node.interface-member">
				<title>interface-member</title>
				
				<para>Supertype. Includes convertor, callee, property, and method.</para>
			</section>
			
			<section xml:id="node.convertor">
				<title>convertor</title>
				
				<simplelist role="layout">
					<member>? expression interface</member>
				</simplelist>
				
				<para>Specifies that implementations of that interface can be converted into the specified type. Or, if [interface] isn't given, that the value can be copied.</para>
			</section>
			
			<section xml:id="node.callee">
				<title>callee</title>
				
				<simplelist role="layout">
					<member>* parameter</member>
					<member>? nullable-type return info</member>
				</simplelist>
				
				<para>If [return info] is not present, the callee does not produce anything when called.</para>
			</section>
			
			<section xml:id="node.property">
				<title>property</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>nullable-type</member>
					<member>access access</member>
				</simplelist>
			</section>
			
			<section xml:id="node.method">
				<title>method</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>expression interface</member>
				</simplelist>
			</section>
			
			<section xml:id="node.access">
				<title>access</title>
				
				<para>Access nodes must specify one of three access levels: only reading, only writing, or both reading and writing.</para>
			</section>
		</section>
		
		<section xml:id="node.implements">
			<title>implements</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>expression interface</member>
			</simplelist>
			
			<para>Returns a bool object reference to the true or false objects. True if [object] implements [interface], false otherwise.</para>
			
			<programlisting>
if (o impls Foo)
	(o as Foo).propOfFoo()
			</programlisting>
		</section>
		
		<section xml:id="node.rational">
			<title>rational</title>
			
			<para>Base node. Evaluates to an object with BigRat as the active interface. The object may implement other interfaces if they do not conflict with the BigRat interface. Must not implement the LimRat interface.</para>
		</section>
		
		<section xml:id="node.set-property">
			<title>set-property</title>

			<simplelist role="layout">
				<member>expression source</member>
				<member>identifier property name</member>
				<member>expression value</member>
			</simplelist>
			
			<para>Sets the value of a property. If the active interface of the value does not have a property with the specified name, or the property cannot be set, an error results. Evaluates to the value given by [value].</para>
		</section>

		<section xml:id="node.string">
			<title>string</title>
			
			<para>string nodes consist of text</para>
			
			<para>strings are expressions</para>
			
			<para>Base node. Evaluates to an object with interface string as the active interface. The object may implement other interfaces if they do not conflict with the string interface.</para>
		</section>
	</section>
</chapter>