<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="node-types">
	<title>Node types</title>

	<para>This chapter describes the various types of nodes.</para>
	
	<section xml:id="base-node-types">
		<title>Base nodes</title>
		
		<para>These node types do not contain child nodes, and are thus the only nodes that must encode information themselves (as opposed to containing child nodes which together provide information).</para>
		
		<simplelist>
			<member linkend="node.access">access</member>
			<member linkend="node.boolean">boolean</member>
			<member linkend="node.direction">direciton</member>
			<member linkend="node.identifier">identifier</member>
			<member linkend="node.identikey-category">identifier-category</member>
			<member linkend="node.integer">integer</member>
			<member linkend="node.rational">rational</member>
			<member linkend="node.string">string</member>
		</simplelist>
	</section>
	
	<section xml:id="tree-node-layout-key">
		<title>Tree node layout key</title>
		
		<para>This section describes how the layout of a node type is represented in this specification.</para>
		
		<para>The layout for a node type is represented in this specification as a list of items. Each item represents a child node or multiple child nodes with the same meaning. Nodes represented by different items are considered to have different meaning.</para>
		
		<para>Each item in these lists first specifies how many child nodes with that meaning may appear, or it says nothing about the number, which means there must be one (and only one). The ways of representing these amounts is described below.</para>
		
		<variablelist>
			<varlistentry>
				<term>?</term>
				<listitem>0 or 1</listitem>
			</varlistentry>
			<varlistentry>
				<term>*</term>
				<listitem>0 or more</listitem>
			</varlistentry>
			<varlistentry>
				<term>+</term>
				<listitem>1 or more</listitem>
			</varlistentry>
			<varlistentry>
				<term>2</term>
				<listitem>2 (used only for the <link linkend="node.enum">enum</link> node)</listitem>
			</varlistentry>
		</variablelist>
		
		<para>Next comes the name of a node type or "expression". The child node represented by that list item must be of that type. The string "expression" means the node must be executable.</para>
		
		<para>Lastly comes a label for referring to the child nodes with that meaning. These labels carry no semantic information, and are only a means used to refer to specific nodes. The meaning of child nodes can certainly be represented by other means. However, people creating representations for Desal trees are encouraged to at least consider using these same labels when it makes sense to do so.</para>
	</section>
	
	<section xml:id="non-executable">
		<title>Non-executable</title>
		
		<para>Nodes that cannot be executed. Most server only to group other nodes together.</para>
		
		<section xml:id="node.return-info">
			<title>return-info</title>
			
			<simplelist role="layout">
				<member>boolean return</member>
				<member>? expression interface</member>
			</simplelist>
			
			<para role="process">If [interface] is present, [return] must be true.</para>
			
			<para>[return] tells whether the function returns a value. If [return] and [interface] are absent, the function does not return a value. If [return] is absent and [interface] is present, the function returns a value. If [return] is present, it's value determines whether the function returns a value (true) or doesn't (false).</para>
		</section>
		
		<section xml:id="node.argument">
			<title>argument</title>
			
			<simplelist role="layout">
				<member>? identifier parameter name</member>
				<member>? expression value</member>
			</simplelist>
			
			<programlisting>
func doSomething(Int a = 1, Int b = 2, Int c = 3, Int d) {...}
doSomething(7, default, default, 8)
doSomething(7, c = default, 8)
			</programlisting>
		</section>
		
		<section xml:id="node.boolean">
			<title>boolean</title>
			
			<para>Base node. Must specify either true or false.</para>
			
			<para>Cannot be evaluated because that would conflict with the prevalent "true" and "false" identifiers. Use "true" and "false" identifiers for expressions instead.</para>
		</section>
		
		<section xml:id="node.bundle">
			<title>bundle</title>
			
			<para>A grouping of library references (import) and groups of declarations (plane).</para>
			
			<simplelist role="layout">
				<member>* import</member>
				<member>* alias</member>
				<member>+ plane</member>
			</simplelist>
			
			<para>The bundle node type is the type of the root node. No node can contain an bundle node. All Desal nodes that are executed in any way must be part of a complete Desal tree, which means having an bundle node as the root node.</para>
			
			<para role="xxx">Program arguments are no longer passed to the main function, because developers should have a choice of accessing program arguments in different ways, and some implementations may not have program arguments, or have non-string program arguments, etc. The old way just isn't flexible enough. Implementations should give program arguments through some API instead of passing them to the main function.</para>

			<orderedlist role="exec">
				<listitem>1. Create the identikeys specified in section XXX to this node's scope.</listitem>
				<listitem>2. Create any implementation-specific identikeys.</listitem>
				<listitem>3. Execute each child identifier-const node in order.</listitem>
			</orderedlist>
			
			<para>When the complete Desal tree is treated as a standalone program, section xxx applies. Otherwise, besides layout and setup, the abilities and behavior of the bundle node is implementation-specific, and execution or evaluation of Desal nodes may occur directly, without going through the bundle node.</para>
			
			<para>The section XXX mentioned above should specify a value bound to "main" with a callee that takes no arguments and either returns nothing or returns an Int.</para>
			
			<para role="xxx">Need a means of hiding/showing certain child namespaces of the global namespace. For example, a bundle acting as a library may have declarations in the global namespace and in a "private" namespace. The bundle should expose the declarations in the global namespace but hide the declarations in the private namespace.</para>
		</section>
		
		<section xml:id="node.direction">
			<title>direction</title>
			
			<para>Specifies the direction of a function parameter, one of: in, in-mutable, out, in-out, in-mutable-out</para>
			
			<para>A value passed to a function as an "in" parameter will not be mutated by the function. This means if the function uses the value in ways that may mutate the value, the value will be copied. If an action in the function may mutate the value, and the value does not declare a copy converter, an error results.</para>
			
			<para>Instances where the value may be mutated include when the interface of the value does not provide opacity information and the function calls a method, or if the interface does provide opacity information but the function calls a mutator method, or if the value is passed to another function as an in-mutable or in-mutable-out parameter.</para>
				
			<programlisting>
func alpha(in Int num) {
	println num
}

func beta(in-mutable Int num) {
	num += 567
}

func gamma(out Int num) {
	//num not currently assigned to anything
	num = 987
}

func delta(in-out Int num) {
	println num
	num = 1001
}

func epsilon(in-mutable-out Int num) {
	num += 55555
	num = 19591
}

Int num = 123
alpha(num)
beta(num) //value mutated
gamma(num) //num assigned to different value
delta(num) //num assigned to different value
epsilon(num) //value mutated and num assigned to different value
			</programlisting>
		</section>
		
		<section xml:id="node.identikey-category">
			<title>identikey-category</title>
			
			<para>specifies one of: namespace, dynamic, automatic, strict, function</para>
			
			<para>See the <link linkend="identikeys">section on identikeys</link>.</para>
		</section>
		
		<section xml:id="node.identikey-type">
			<title>identikey-type</title>
			
			<simplelist role="layout">
				<member>identikey-category</member>
				<member>? expression interface</member>
				<member>? boolean constant</member>
			</simplelist>

			<para role="process">[constant] must not be specified if identikey-category is namespace. [constant] must be false (or not specified) if category is dynamic. The interface must be given if the category is strict. The interface must not be given if the category is namespace, dynamic, or automatic.</para>

			<para>If the category is strict, the active interface of any value bound to the identikey must be that interface. If the category is function, and the interface is given, functions bound to the identikey must specify that interface as the return type.</para>
			
			<para>The default value of [constant] is false. If [constant] is true, the identifier thereafter always refers to the same value. The identifier cannot be bound to a different value, or unbound. The active interface also cannot be changed.</para>
			
			<programlisting>
Int a = 3
func Int a = func()Int { return 3 }
			</programlisting>
		</section>
		
		<section xml:id="node.import">
			<title>import</title>
			
			<simplelist role="layout">
				<member>string library</member>
				<member>? identifier library alias</member>
				<member>* alias-member</member>
			</simplelist>
			
			<para>Assigns values from libraries to global identikeys.</para>
			
			<programlisting>
import "XmlLib" as Xml
/*
library: "XmlLib"
library alias: Xml */

from "XmlLib" import XmlDocument as Doc
/*
library: "XmlLib"
library alias: (not given)
alias-member: XmlDocument, Doc */

from "XmlLib" as Xml import XmlDocument as Doc
/*
library: "XmlLib"
library alias: Xml
alias-member: XmlDocument, Doc */

from "XmlLib" as Xml import XmlReader, XmlDocument as Doc, XmlElement
/*
library: "XmlLib"
library alias: Xml
alias-member: XmlReader
alias-member: XmlDocument, Doc
alias-member: XmlElement */

from "XmlLib" as Xml import
	XmlReader,
	XmlDocument as Doc,
	XmlElement
			</programlisting>
			
			<section xml:id="node.alias-member">
				<title>alias-member</title>
				
				<simplelist role="layout">
					<member>identifier target</member>
					<member>? identifier new name</member>
				</simplelist>
			</section>
		</section>
		
		<section xml:id="node.import-all">
			<title>import-all</title>
			
			<simplelist role="layout">
				<member>string library</member>
			</simplelist>
			
			<para>Imports every identikey in the library.</para>
			
			<programlisting>
import all from "XmlLib"
//library: "XmlLib"
			</programlisting>
		</section>
		
		<!-- xxx remove
		<section xml:id="node.namespace-reference">
			<title>namespace-reference</title>
			
			<simplelist role="layout">
				<member>+ identifier</member>
			</simplelist>
			
			<para>Used to refer to a namespace that is the child of another namespace.</para>
		</section>
		-->

		<section xml:id="node.parameter">
			<title>parameter</title>
			
			<para>A function parameter.</para>
			
			<simplelist role="layout">
				<member>direction</member>
				<member>? boolean nullable</member>
				<member>? expression interface</member>
				<member>identifier name</member>
				<member>? expression default value</member>
			</simplelist>
			
			 <para role="process">[nullable] must not be specified if direction is "out".</para>
		</section>
				
		<section xml:id="node.plane">
			<title>plane</title>
			
			<para>A group of declarations within a bundle.</para>
			
			<simplelist role="layout">
				<member>* alias</member>
				<member>* identifier namespace</member>
				<member>+ declare-first</member>
			</simplelist>
			
			<para>This node has scope, but only private identifiers are bound to it. Public and exported identifiers are bound to the scope of the bundle node.</para>
			
			<para>Planes aren't expressions because their declare-first nodes might rely on declare-first nodes in other planes, so all the declare-first nodes in a single plane can't just be executed all together.</para>
		</section>
	</section>

	<section xml:id="non-producing-expressions">
		<title>Non-producing expressions</title>
		
		<para>Nodes that can be executed, but never produce.</para>

		<section xml:id="iteration">
			<title>Iteration</title>
			
			<section xml:id="node.do-while">
				<title>do-while</title>
				
				<simplelist role="layout">
					<member>block action</member>
					<member>expression test</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
do {
	something()
} while test()
				</programlisting>
			</section>
			
			<section xml:id="node.do-times">
				<title>do-times</title>
				
				<simplelist role="layout">
					<member>expression times</member>
					<member>block action</member>
					<member>? expression test</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
do 8 times {
	something()
}

do 8 times {
	something()
} while test()
				</programlisting>
			</section>
			
			<section xml:id="node.for-key">
				<title>for-key</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression key interface</member>
					<member>identifier name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<orderedlist role="exec">
					<listitem>1. Call getKeyIterator on [container].</listitem>
					<listitem>2. Call getNext on [1]. If an exception is thrown with an active interface of GeneratorDone, swallow it and end execution. If anything else is thrown, follow normal exception rules.</listitem>
					<listitem>3. Create a scope.</listitem>
					<listitem>4. Assign [2] to [identifier] in [3].</listitem>
					<listitem>5. Execute [block] with scope [3].</listitem>
					<listitem>6. Go to step 2.</listitem>
				</orderedlist>
				
				<programlisting>
for key x in foo
	doStuff(x)

for key Int x in foo
	doStuff(x)
				</programlisting>
			</section>
			
			<section xml:id="node.for-pair">
				<title>for-pair</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression key interface</member>
					<member>identifier key name</member>
					<member>? expression value interface</member>
					<member>identifier value name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
for pair x y in coords
	drawPoint(x, y)

for pair Int x, Int y in coords
	drawPoint(x, y)
				</programlisting>
			</section>

			<section xml:id="node.for-manual">
				<title>for-manual</title>
				
				<para>Used for manual iteration, as opposed to letting the Desal implementation deal with iteration, like with a for-value node.</para>
				
				<simplelist role="layout">
					<member>* expression initializers</member>
					<member>? expression test</member>
					<member>* expression post actions</member>
					<member>? block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<para>The initializers are executed before iteration begins. Test is evaluated before each iteration. Post actions are executed after each iteration.</para>
				
				<screen>
initializers

test
action
post actions

test
action
post actions

...

test
action
post actions

test

(end of loop)
				</screen>
				
				<programlisting>
for( Int i = 0 ; i &lt; container.length ; i++ ) {
	println container[i]
}

for( Iterator&lt;Int> iterator = container.getIterator() ;
iterator.hasMore? ; iterator.moveNext() ) {
	println iterator.current
}
				</programlisting>
			</section>
			
			<section xml:id="node.for-range">
				<title>for-range</title>
				
				<simplelist role="layout">
					<member>? identifier name</member>
					<member>expression start</member>
					<member>expression limit</member>
					<member>boolean inclusive</member>
					<member>? expression test</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<para>[inclusive] determines whether the loop should iterate one last time if the iteration value is equal to the limit, and it is false by default.</para>
				
				<programlisting>
for 0 to 100
	println "test"

for x from 0 to 100
	println x

for x from 0 to 100 inclusive
	println x

for 0 to string.length while not container.full
	container.push( string.unshift!() )

for x from 0 to 100 while not foo.done?
	foo.runTest(x)
				</programlisting>
			</section>
			
			<section xml:id="node.for-value">
				<title>for-value</title>
				
				<simplelist role="layout">
					<member>expression container</member>
					<member>? expression value interface</member>
					<member>identifier name</member>
					<member>block action</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
for name in names
	println name

for String name in names
	println name
				</programlisting>
			</section>
			
			<section xml:id="node.loop">
				<title>loop</title>
				
				<simplelist role="layout">
					<member>block</member>
				</simplelist>
				
				<para>Executes block continuously. Can only be exited by expressions in the block such as break and return.</para>
			
				<programlisting>
loop {
	Event event = getNextEvent()
	switch( event ) {
		case Events.QUIT :
			break
	}
}
				</programlisting>
			</section>
			
			<section xml:id="node.while">
				<title>while</title>
				
				<simplelist role="layout">
					<member>expression test</member>
					<member>? block</member>
				</simplelist>
				
				<para>Has scope.</para>
				
				<programlisting>
while printNext()

while container.hasMore?
	print container.next
				</programlisting>
			</section>
		</section>
		
		<section xml:id="node.break">
			<title>break</title>
			
			<simplelist role="layout">
				<member>? identifier label</member>
			</simplelist>
		</section>
		
		<section xml:id="node.continue">
			<title>continue</title>
			
			<simplelist>
				<member>? identifier label</member>
			</simplelist>
		</section>
		
		<section xml:id="node.declare-empty">
			<title>declare-empty</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
			</simplelist>
			
			<para role="process">The identikey-type must not be constant.</para>
			
			<para>Creates an identikey in the parent scope with the specified type. After this node executes, the produced identikey does not yet point to any values.</para>

			<programlisting>
decl func Int foo
foo = func()Int { return 3 }
foo = func(Int a)Int { return a * 2 }
print foo() //prints 3
print foo(2) //prints 4

//xxx does this produce error or replace?
foo = func()Int { return 5 }
			</programlisting>

			<programlisting>
decl func()Int foo
foo = func()Int { return 3 }
print foo() //prints 3
foo = func()Int { return 5 }
print foo() //prints 5
foo = func(Int a)Int { return a * 2 } //error - interface mismatch
			</programlisting>
		</section>
		
		<section xml:id="node.declare-first">
			<title>declare-first</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
				<member>expression value</member>
			</simplelist>
			
			<para role="process">The identikey-type must be constant, and must have a category of automatic, strict, or function.</para>
			
			<para>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</para>
			
			<para>When a block contains declare-first nodes, the declare-first nodes are executed before the other expressions in the block are executed. The value expressions of declare-first nodes may depend on the values of other declare-first nodes in the same block. For example, two interfaces could reference each other.</para>
			
			<programlisting>
decl-first auto Foo = interface {
	get Bar bar
}

decl-first auto Bar = interface {
	get Foo foo
}

Foo foo = ...
foo.bar.foo.bar...
			</programlisting>
		</section>
		
		<section xml:id="node.return">
			<title>return</title>
			
			<simplelist role="layout">
				<member>? expression</member>
			</simplelist>
			
			<para>Function call ends and evaluates to expression.</para>
		</section>
		
		<section xml:id="node.throw">
			<title>throw</title>
			
			<simplelist role="layout">
				<member>expression</member>
			</simplelist>
			
			<para>If the expression isn't an Exception, wrap it with NonExceptionThrownError.</para>
		</section>
		
		<section xml:id="node.labeled">
			<title>labeled</title>
			
			<simplelist role="layout">
				<member>identifier label</member>
				<member>expression child</member>
			</simplelist>
			
			<para role="process">The [child] node must be an iteration node, a block node, a possibility node, a conditional node, or a select node. (XXX update and explain requirements instead of just listing nodes that meet requirements)</para>
			
			<programlisting>
$func setupCell(Int searchID) {
	$decl Cell wantedCell
	
	outer: $for row $in table {
		$for cell $in row {
			$if cell.ID == searchID {
				wantedCell = cell
				$break outer
			}
		}
	}
	
	$if wantedCell != null {
		doSomething(wantedCell)
	}
}
			</programlisting>
		</section>
	
		<section xml:id="node.yield">
			<title>yield</title>
			
			<para>Within a generator, specifies the next value for the generator to yield.</para>
			
			<simplelist role="layout">
				<member>expression</member>
			</simplelist>
			
			<para role="process">Must be a descendant of a generator node, and not inside a function or class node. (XXX spec out the kind of barriers function and class nodes create)</para>
		</section>
	</section>

	<section xml:id="sometimes-producing-expressions">
		<title>Sometimes producing expressions</title>
		
		<para>Nodes that can be executed, and sometimes produce.</para>
		
		<section xml:id="node.block">
			<title>block</title>
			
			<simplelist role="layout">
				<member>* expression</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<orderedlist role="exec">
				<listitem>Execute each expression in order. Produce the result of the last expression. (Produce nothing if the block contained no expressions or the last expression didn't produce.)</listitem>
			</orderedlist>
			
			<para>Note: This node type is different from the Dextr concept of blocks. To differentiate between the two, nodes of this type can be called "block nodes", and the syntactic construct of Dextr can be called "Dextr blocks" or "syntactic blocks".</para>
		</section>
		
		<section xml:id="node.possibility">
			<title>possibility</title>
			
			<simplelist role="layout">
				<member>expression test</member>
				<member>expression result</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<para role="process">An error results if the implementation knows [test] will never evaluate to a value that can be downcast to Bool.</para>
			
			<orderedlist role="exec">
				<listitem>Evaluate [test].</listitem>
				<listitem>Downcast [1] to Bool.</listitem>
				<listitem>If [2] is true, evaluate [result].</listitem>
				<listitem>Evaluate this node to [3].</listitem>
			</orderedlist>
			
			<programlisting>
if not foo.isSetup? {
	foo.setup()
}
			</programlisting>
		</section>
			
		<section xml:id="node.conditional">
			<title>conditional</title>
			
			<simplelist role="layout">
				<member>+ possibility</member>
				<member>? expression else</member>
			</simplelist>
			
			<para role="exec">Execute the [test] of the first [possibilty]. Downcast the resultant value to a Bool. If it is true, execute the [result] of that [possibilty] and produce the result. Otherwise, move on to the next node. If no [test] produces true, and [else] is given, execute [else] and produce its result.</para>
			
			<programlisting>
$decl Int a = (x ? 0 : 1)

$if foo == 1
	doStuff1()
$elif foo == 2
	doStuff2()
$else
	doDefault()

$decl bar =
	(foo == 1) ? getOne() :
	(foo == 2) ? getTwo() :
	getDefault()

$decl bar =
	$if foo == 1 : $eval getOne()
	$elif foo == 2 : $eval getTwo()
	$else : $eval getDefault()
			</programlisting>
		</section>
		
		<section xml:id="node.select">
			<title>select</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>* case</member>
				<member>? expression else</member>
			</simplelist>
			
			<para role="exec">Execute [value]. Execute each [values] child of each [case] and compare them to the [value] value (with the .equals? method of the [value] value) until finding a match. Then, execute the [result] of that case and produce the result. If no match is found, and [else] is given, execute [else] and produce its result.</para>
			
			<section xml:id="node.case">
				<title>case</title>
				
				<simplelist role="layout">
					<member>+ expression values</member>
					<member>expression result</member>
				</simplelist>
			</section>
			
			<programlisting>
$select event.type
$case Events.QUIT {
	$return
}
$case Events.FOO, Events.BAR, Events.MAZ {
	//no action
}
$else {
	$throw ErrorClass("unknown event type")
}

$select foo
$case 1
	doStuff1()
$case 2
	doStuff2()
$else
	doDefault()

$decl bar = $select foo
	$case 1 : $eval getOne()
	$case 2 : $eval getTwo()
	$else $eval getDefault()
			</programlisting>
		</section>
		
		<section xml:id="node.try-catch">
			<title>try-catch</title>
			
			<simplelist role="layout">
				<member>expression try</member>
				<member>* exception-handler</member>
				<member>? expression else</member>
				<member>? expression finally</member>
			</simplelist>
			
			<para role="xxx">The term "else" is not descriptive enough in this situation. Possible replacements: "onsuccess", "then"</para>
			
			<para role="process">Must contain more than just [try].</para>
			
			<section xml:id="node.exception-handler">
				<title>exception-handler</title>

				<simplelist role="layout">
					<member>boolean catch</member>
					<member>expression interface</member>
					<member>? identifier name</member>
					<member>expression result</member>
				</simplelist>
			</section>
			
			<programlisting>
$try {
	$decl foo = getSomething()
}
$observe( OutOfMemoryError ) {
	println "I'm not catching that!"
	//exception is noticed by this try-catch node, but not caught
	//the exception continues to rise out
}
$catch( NullError ) {
	println "null error"
}
$catch( FooError e ) {
	println "FooError: $(e.message)"
}
$catch( Error ) {
	println "unknown error"
}
$catch( Exception ) {
	println "unknown exception"
}
$observe {
	println "how execution reach here? am not good with computer"
}
$else {
	println "no errors!"
	doSomeStuff() //don't catch errors from this in this node
}
$finally {
	cleanup(foo)
}

$decl Status stat =
$try {
	doSomething()
	Statuses.SUCCESS
}
$catch( NotSoBadError ) {
	Statuses.ERROR
}
$observe {
	println "something bad when trying to doSomething()"
}
			</programlisting>
		</section>
		
		<section xml:id="node.call">
			<title>call</title>

			<simplelist role="layout">
				<member>expression value</member>
				<member>? identifier method name</member>
				<member>* argument</member>
			</simplelist>
			
			<para>If [method name] is not given:</para>
			
			<orderedlist role="exec">
				<listitem>Execute [value].</listitem>
				<listitem>If the resultant value is not callable, throw an error.</listitem>
				<listitem>Execute the argument expressions in order.</listitem>
				<listitem>Send argument values to the [value] value for execution.</listitem>
				<listitem>Produce the returned value.</listitem>
			</orderedlist>
			
			<para>If [method name] is given:</para>
			
			<orderedlist role="exec">
				<listitem>Execute [value].</listitem>
				<listitem>If the resultant value is not callable, throw an error.</listitem>
				<listitem>Execute the argument expressions in order.</listitem>
				<listitem>Send argument values to the method with name [method name] of the [value] value for execution.</listitem>
				<listitem>Produce the returned value.</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.curry">
			<title>curry</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>? identifier method name</member>
				<member>* argument</member>
			</simplelist>
			
			<para>Provides the type of currying that is also known as "partial application". Note that Desal provides no built-in means of doing the other kind of currying, where a multi-argument function is converted into a chain of single-argument functions.</para>

			<para role="process">If this node is acting as an expression, and the function receives all it's arguments, which would result in the function being called, and the function doesn't return anything, an error results.</para>
			
			<programlisting>
func foo(Int a, Rat b, String c, Bool d) Int {
	...
}

//partial application
func(String,Bool)Int foo2 = foo(1, 2.34)
print foo2("text", true)

//other type of currying
func(Int)(
	func(Rat)(
		func(String)(
			func(Bool)Int ))) foo3 = curry(foo)
print foo3(1)(2.34)("text")(true)

//The above two are equivalent to:
print foo(1, 2.34, "text", true)
			</programlisting>
			
			<para>If the arguments match only one of the callees/methods of [value], this node evaluates to a value with a function interface as the active interface. If the arguments match more than one of the callees/methods on [value], this node evaluates to a value with an active interface that is produced from adding the function interfaces of the callees/methods together.</para>
			
			<para>After evaluation, the specified parameters have values, so they do not appear on the resultant function.</para>
			
			<para>Once the function has all its arguments supplied, it is called. Note that this is different from the <link linkend="node.bind">bind node</link>.</para>
			
			<programlisting>
func doStuff1(Int a, String b, Bool alpha) {...}
func doStuff1(Int a, Rat b, Bool alpha) {...}
func doStuff2 = doStuff1~(3, alpha=false)
doStuff2("test")
doStuff2(123.456)
			</programlisting>
			
			<para>The middle line perhaps might also be represented this way:</para>
			<programlisting>
(declare-first
	(identifier.name "doStuff2")
	(curry
		(identifier.value "doStuff1")
		(argument
			(integer.value 3))
		(argument
			(identifier.name "alpha")
			(identifier.value "false"))))
			</programlisting>
		</section>
		
		<section xml:id="node.ignore">
			<title>ignore</title>
			
			<para>Instructs an agent to not output certain warnings.</para>
			
			<simplelist role="layout">
				<member>expression content</member>
				<member>+ ignore-member</member>
			</simplelist>
			
			<section xml:id="node.ignore-member">
				<title>ignore-member</title>
				
				<simplelist role="layout">
					<member>string name</member>
					<member>integer depth</member>
				</simplelist>
			
				<para>The [name] can be a warning name from the <link linkend="warnings-list">specified warnings</link> or an agent-defined warning name. Unknown warning names should by default produce a warning that the warning name is unknown. Agents should provide an option to disable warnings for unknown warning names.</para>
				
				<para>The [depth] specifies what descendant nodes are affected by the ignore node. Counting begins at one with the [content] node of the ignore node and increments by one for each further descendant.</para>
				
				<programlisting>
(ignore
	(ignore-member
		(string.name "always null")
		(integer.depth ...))
	(call.content
		(function.identifier println)
		(assignment.argument
			(identifier.name foo)
			(for-value.value
				...))))
				</programlisting>
				
				<para>Here, if the [depth] was 1, a warning should be output by the agent for the assignment node that the [value] node will never produce a value when executed (a.k.a. always evaluate to null).</para>
			</section>
		</section>
	</section>
	
	<section xml:id="pure-producers">
		<title>Pure producers</title>
		
		<para>Nodes that always produce when executed, and are not intended to have side effects. When the output of one of these nodes is not used, a warning should be emitted, because pure producers serve only to produce values. (xxx which warning?) For example, if a block contains an integer node (that is not last), an agent should emit a warning that the integer node has no effect.</para>
		
		<section xml:id="node.active-interface">
			<title>active-interface</title>
			
			<simplelist role="layout">
				<member>expression value</member>
			</simplelist>
			
			<para>Evaluates to the interface that is the active interafce of the specified value.</para>
		</section>
		
		<section xml:id="node.array">
			<title>array</title>
			
			<simplelist role="layout">
				<member>expression [interface]</member>
				<member>* expression [element]</member>
			</simplelist>
			
			<para>Evaluates to an object with interface array as the active interface. The object may implement other interfaces if they do not conflict with the array interface.</para>
			
			<para>Each [element] is cast to [interface]. If a cast error results, it raises out of the array node, so that the array node doesn't evaluate to anything.</para>
		</section>
		
		<section xml:id="node.bind">
			<title>bind</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>? identifier method name</member>
				<member>* argument</member>
			</simplelist>
			
			<para>Performs partial application. Evaluates to a function.</para>
			
			<para>Note that if all arguments are supplied, the function will not be called. Contrast this with the <link linkend="node.curry">curry node</link>.</para>
			
			<programlisting>
interface Alpha
	func bar(Int a, Rat b, String c)

Alpha alpha = AlphaClass()

alpha.bar(0, 0.0, "0")

func()void bar1 = alpha:bar()
bar(1, 2.3, "4")

func()void bar2 = alpha:bar(c="text")
bar2(7, 9.8)

func()void bar3 = alpha:bar(-9, 0.001, "stuff")
bar3()
			</programlisting>
		</section>
		
		<section xml:id="node.cast">
			<title>cast</title>
			
			<simplelist role="layout">
				<member>expression [object]</member>
				<member>expression [interface]</member>
			</simplelist>
			
			<para>Evaluates to an object reference where the active interface is [interface] and the object is [object]. If [object] does not implement [interface], an error results.</para>
			
			<programlisting>
Int o = getIntAndString()
print (o as String).length
			</programlisting>
		</section>
		
		<section xml:id="node.chain">
			<title>chain</title>
			
			<simplelist role="layout">
				<member>boolean namespaced-identikey</member>
				<member>boolean get-property</member>
				<member>boolean bind</member>
				<member>? expression starting value</member>
				<member>+ identifier</member>
			</simplelist>
			
			<para>This node exists for Desal representations that use the same syntax for different associations between identifiers. The associations supported by this node are the same as those of the <link linkend="node.namespaced-identikey">namespaced-identikey</link>, <link linkend="node.get-property">get-property</link>, and <link linkend="node.bind">bind</link> nodes. The optional boolean nodes are all true by default, meaning all associations are supported. If namespaced-identikey is true, the starting value must not be present.</para>
			
			<para>namespaced-identikey associations can be used to evaluate namespaced identikeys.</para>
			
			<screen>
namespace.identikey
namespace.namespace.identikey
			</screen>
			
			<para>get-property associations can be used to get properties of values.</para>
			
			<screen>
starting-value.property.property.property

if namespaced-identikey is also true:
namespace.identikey.property
			</screen>
			
			<para>bind associations can be used to bind a method of a value to a value.</para>
			
			<screen>
alpha.doStuff.apply
			</screen>
			
			<screen>
Different syntax for namespaced identikeys, getting properties, and method binding.

alpha::beta.gamma=>delta

(bind
	(get-property
		(namespaced-identikey
			(namespace alpha)
			(identifier beta))
		(identifier gamma))
	(identifier delta))

Here, alpha must be a namespace, beta must be an identikey, gamma must be a property, and delta must be a method.
			</screen>
			
			<screen>
Shared syntax for namespaced identikey references and getting properties, but different syntax for method binding.

alpha.beta.gamma:delta

(bind
	(chain
		(bind false)
		(identifier alpha)
		(identifier beta)
		(identifier gamma))
	(identifier delta))

Here, alpha could be a free identikey or a namespace. If alpha is a namespace, beta could be a namespace. gamma could be an identikey in the alpha.beta namespace, or a property of the value that beta evaluated to. delta must be a method.
			</screen>
			
			<screen>
Shared syntax for getting properties and method binding, but different syntax for referring to namespaced identikey references.

alpha::beta.gamma.delta

(chain
	(namespaced-identikey false)
	(starting-value
		(namespaced-identikey
			(namespace alpha)
			(identifier beta)))
	(identifier gamma)
	(identifier delta))

Here, alpha must be a namespace and beta must be an identikey within that namespace. gamma could be a property or method of beta. delta could be a property or method of gamma.
			</screen>
			
			<screen>
Same syntax for all.

alpha.beta.gamma.delta

(chain
	(identifier alpha)
	(identifier beta)
	(identifier gamma)
	(identifier delta))

Delta cannot be a namespace.
			</screen>
			
			<screen><![CDATA[
A representation could provide different syntax for each association, but also provide a way to specify that one of multiple assocations are allowed.

alpha :: beta {. or =>} gamma . delta => epsilon

<bind>
	<get-property label="value">
		<chain label="value">
			<bool label="namespaced-idenkey">false</bool>
			<namespaced-identikey label="starting-value">
				<identifer label="namespace">alpha</identifer>
				<identifer label="member">beta</identifer>
			</namespaced-identifer>
			<identifer>gamma</identifer>
		</chain>
		<identifer label="property-name">delta</identifer>
	</get-property>
	<identifier label="method-name">epsilon</identifer>
</bind>

Here, alpha must be a namespace, and beta must be an identikey within that namespace. Gamma can be a property or method of beta. delta must be a property of gamma. epsilon must be a method of delta.
]]>
			</screen>
		</section>
		
		<section xml:id="node.class">
			<title>class</title>
			
			<para>Evaluates to a value that, when called, produces other values. The interfaces supported by the produced values are implemented in the way specified by this class node. The active interface of the produced value is specified by this class.</para>
			
			<para>The active interface of the value that is produced when a class node is executed inherits from the master interface of the class. The master interface is the sum of all the root interfaces implemented by the class.</para>
			
			<para role="xxx">XML comments with important information</para>
			
			<simplelist role="layout">
				<!-- private and possibly public; can't be "call" or "callee" -->
				<member>* declare-class static declarations</member>
				
				<!-- private -->
				<member>? block static constructor</member>
				
				<!-- public -->
				<member>* function static callees</member>
				
				<!-- public -->
				<member>* class-property static properties</member>
				
				<!-- private and public -->
				<member>* function instance constructors</member>
				
				<!-- private -->
				<member>* declaration instance declarations</member>
				
				<!-- private and public -->
				<member>* interface-implementation</member>
			</simplelist>
			
			<para>XXX The static callees and static properties may not always be visible in the class node's scope. (An example of being visible is assigning the value produced by the class node to an identifier.) Should some identifier (e.g. "thisClass") be introduced that evaluates to the class's value? (e.g. thisClass.property = foo) Or should a general means of accessing the enclosing expression node's value be introduced? (e.g. thisValue.property = foo)</para>
			
			<para>The above is not a problem for interface implementations due to the "this" identikey being bound to the active instance.</para>
			
			<para>The children of class nodes can be grouped by several means.</para>
			
			<para>By count:</para>
			<table>
				<tbody>
					<tr>
						<th></th>
						<th>public</th>
						<th>private</th>
					</tr>
					<tr>
						<th>static - only 1</th>
						<td>callees, getters/setters, methods, interface-implementations</td>
						<td>static constructor, instance constructors, static declarations, instance methods</td>
					</tr>
					<tr>
						<th>instance - 1 per instance</th>
						<td></td>
						<td>instance declarations</td>
					</tr>
				</tbody>
			</table>
			
			<para>By scopes: (in scope means something can be accessed through a single identifier as a free identikey)</para>
			<simplelist>
				<member>static scope
					<simplelist>
						<member>public
							<simplelist>
								<member>defined by: static declarations (as properties and methods; must have access with get and/or set), static properties, instance constructors (as callees)</member>
								<member>in scope: (none)</member>
							</simplelist>
						</member>
						<member>private
							<simplelist>
								<member>defined by: static declarations, instance constructors (as functions bound to "construct")</member>
								<member>in scope: static constructor, callees, getters/setters, methods, expressions in static declarations</member>
							</simplelist>
						</member>
					</simplelist>
				</member>
				<member>instance scope
					<simplelist>
						<member>public
							<simplelist>
								<member>defined by: interface-implementations (or really, by the interface)</member>
								<member>in scope: (none)</member>
							</simplelist>
						</member>
						<member>private
							<simplelist>
								<member>defined by: instance declarations, instance methods</member>
								<member>in scope: expressions in instance declarations, instance methods, interface implementations, instance constructors</member>
							</simplelist>
						</member>
					</simplelist>
				</member>
			</simplelist>
			
			<para>Note: Instance scopes are children of the static scope.</para>
			
			<para role="process">Must have at least one interface-implementation. Including the interface-implementation nodes that are inherited by this class's child interface-implementation nodes, one and only one of the interface-implementation nodes must be specified as default.</para>
			
			<orderedlist role="exec">
				<listitem>Create scope, STATIC_SCOPE.</listitem>
				<listitem>Create an interface, CLASS_INTERFACE.</listitem>
				<listitem>Add instance constructors as free functions to STATIC_SCOPE.</listitem>
				<listitem>Add instance constructors as callees to CLASS_INTERFACE.</listitem>
				<listitem>Evaluate every <link linkend="node.declare-class">declare-class</link> that has a <link linkend="node.declare-first">declare-first</link> in the scope of STATIC_SCOPE. If the identikey-type of the <link linkend="node.declare-first">declare-first</link> is function, and it has access of get, add a method to CLASS_INTERFACE with the same function interface and name. Otherwise, create a property with a getter if declared public.</listitem>
				<listitem>Evaluate the rest of the declare-class nodes in the scope of STATIC_SCOPE, except for the declare-class nodes with a declare-const-empty. Create properties as appropriate when the access nodes specify to do so.</listitem>
				<listitem>In the scope of STATIC_SCOPE, evaluate the declare-class nodes that have declare-const-empty nodes. Create properties as appropriate when the access nodes specify to do so.</listitem>
				<listitem>Add the static callees as free functions in STATIC_SCOPE.</listitem>
				<listitem>Add the static callees and the static properties to CLASS_INTERFACE.</listitem>
				<listitem>Execute the static constructor.</listitem>
				<listitem>Seal the identikeys created by the declare-const-empty nodes, meaning don't allow their bound status to change.</listitem>
				<listitem>Create a value with CLASS_INTERFACE as the active interface.</listitem>
				<listitem>Evaluate this node to the above value.</listitem>
			</orderedlist>
			
			<para>When a constructor is called:</para>
			<orderedlist role="exec">
				<listitem>Create a scope, INSTANCE_SCOPE. Set STATIC_SCOPE as the parent scope.</listitem>
				<listitem>Evaluate all declare-first nodes in scope of INSTANCE_SCOPE.</listitem>
				<listitem>Execute the appropriate constructor.</listitem>
				<listitem>Evaluate the function-call that lead to this constructor being evaluated to a value with INSTANCE_SCOPE as the object and the default interface implementation of the class as the active interface implementation.</listitem>
				<listitem>Note: When the interface implementation is used, the value will pass the object into the interface implementation.</listitem>
			</orderedlist>
			
			<section xml:id="node.declare-class">
				<title>declare-class</title>
				
				<simplelist role="layout">
					<member>declaration</member>
					<member>? access</member>
				</simplelist>
				
				<para role="process">If the declaration declares a const identifier, and access is present, the access node must be declared get.</para>
				
				<para role="xxx">poorly named</para>
			</section>
			
			<section xml:id="node.declaration">
				<title>declaration</title>
				
				<para>declaration is a family of node types, like expression. The node types included in this family are:</para>
				
				<simplelist role="family-members">
					<member>declare-empty</member>
					<member>declare-assign</member>
					<member>declare-first</member>
					<member>declare-const-empty</member>
				</simplelist>
			</section>
			
			<section xml:id="node.declare-const-empty">
				<title>declare-const-empty</title>
				
				<simplelist role="layout">
					<member>identifier</member>
					<member>identikey-type</member>
				</simplelist>
				
				<para role="process">If identikey-type is function, the interface is the return type. (xxx why?)</para>
				
				<para>Identifiers created by this node are always const. [identikey-type] must be value or function. The class's static constructor is allowed to assign values to static identifiers created by this node. If anthing tries to assign a value to an identikey create by this node, and the identikey is already bound to something, throw an error. The class's instance constructors are allowed to assign values to instance identifiers created by this node. An error results if identikeys produced by declare-const-empty nodes are dereferenced before being bound to anything.</para>
			</section>
	
			<section xml:id="node.interface-implementation">
				<title>interface-implementation</title>
				
				<simplelist role="layout">
					<member>* interface-implementation children</member>
					<member>expression interface</member>
					<member>* function callee</member>
					<member>* named-function getter</member>
					<member>* named-function setter</member>
					<member>* named-function method</member>
					<member>boolean default</member>
				</simplelist>
			</section>
			
			<section xml:id="node.named-function">
				<title>named-function</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>function function</member>
				</simplelist>
			</section>
			
			<section xml:id="node.class-property">
				<title>class-property</title>
				
				<simplelist role="layout">
					<member>identifier</member>
					<member>identikey-type</member>
					<member>? function getter</member>
					<member>? function setter</member>
				</simplelist>
				
				<para role="process">Must have a getter and/or setter. If only identifier and identikey-type are given, an error results.</para>
			</section>
			
			<programlisting>
class Foo {
	...
	construct() {...}
	impl Bar {...}
}

interface of Foo {
	inherit Bar
	call() Bar
}

(Foo as Interface) == Bar //true
			</programlisting>
			
			<programlisting>
class Foo {
	...
	construct() {...}
	impl Bar default {...}
	impl define Bar2 {...} //the identifier "Bar2" is required
}

interface of Foo {
	inherit Bar + {{interface Bar2}}
	call() Bar
	get Interface Bar2
}

(Foo as Interface) == (Bar + Foo.Bar2) //true
			</programlisting>
		</section>
		
		<section xml:id="node.copy">
			<title>copy</title>
			
			<para>Attempts to copy a given value.</para>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>? expression interface</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Evaluate the value expression.</listitem>
				<listitem>Evaluate the interface expression or get the active interface of the value.</listitem>
				<listitem>Find the converter to the specified interface (XXX how?) using the same method as finding a property or method.</listitem>
				<listitem>Activate the converter.</listitem>
				<listitem>Evaluate this node to the returned value.</listitem>
			</orderedlist>
			
			<programlisting>
decl Int $num = 3

decl Int $num2 = copy($num)
decl Rat $num3 = ($num as Rat)

decl Int $num4 := $num
decl Rat $num5 := $num
			</programlisting>
		</section>
		
		<section xml:id="node.enum">
			<title>enum</title>
			
			<para>An enum is similar to an immutable dict.</para>
			
			<simplelist role="layout">
				<member>? expression value interface</member>
				<member>+ enum-entry</member>
			</simplelist>
			
			<para role="process">If [value interface] is not given, no enum entries can have a value. (XXX [value interface] should become some kind of Type value/node which can express that the value can be a dyn) If one or more enum entries have a value, all enum entries must have a value.</para>
			
			<section xml:id="node.enum-entry">
				<member>enum-entry</member>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>? expression value</member>
				</simplelist>
			</section>
			
			<para role="xxx">clean up</para>
			
			<screen>
<![CDATA[

//T is the type of an entry in this enum
//U is the type of a value of an enum entry
interface<T, U> Enum
	get Collection<T> entries
	//or maybe: inherit Collection<T>
	get Int size
	func fromName(String str) T
	func fromValue(U val) T

//U is the type of a value of an enum entry
interface<U> EnumElement
	get String name
	get U value

Enum and EnumElement cannot be implemented manually.

These two interfaces are used in the examples below:

interface {{AnimalInterface}}
	inherit EnumElement<Int>

interface {{Properties}}
	inherit Enum< {{AnimalInterface}}, Int >
	get {{AnimalInterface}} dog
	get {{AnimalInterface}} cat
	get {{AnimalInterface}} fish
	get {{AnimalInterface}} parrot
	get {{AnimalInterface}} ferret
	get {{AnimalInterface}} gerbil
	get {{AnimalInterface}} hamster

When [value-type] is not given:
	no entries can have values
	the value property of EnumEntry will return null
	the fromValue method of Enum will return null

When a [value-type] is given, all entries must have values.

Multiple identifiers can be assigned the same value. In such a case, each identifier will refer to the same object, and the str property of that object will give the first identifier as a string.

layout:
	identifier [interface]
	? expression [value-type]
	boolean [expose]
	(+ identifier [name]) | (+ enum-entry [element])

enum-entry layout:
	identifier [name]
	? expression [value]

----- example 1

enum Animal {
	dog, cat, fish, parrot, ferret, gerbil, hamster
}

Animal a = Animal.dog
Animal b = Animal["cat"]
println Animal.size

for animal in Animal
	println animal.str " " animal.value

----- example 2

enum Animal expose {
	DOG, CAT, FISH, PARROT, FERRET, GERBIL, HAMSTER
}

Animal a = Animal.DOG
Animal b = Animal["CAT"]
Animal c = FISH
println Animal.size

for animal in Animal
	println animal.str " " animal.value

-----

typeOf(Animal) == Interface + {{Properties}}
(Animal as Interface) == {{AnimalInterface}}
typeOf(DOG) == typeOf(Animal.DOG)

]]>
			</screen>
		</section>

		<section xml:id="node.function">
			<title>function</title>
			
			<simplelist role="layout">
				<member>* parameter</member>
				<member>return-info</member>
				<member>block</member>
			</simplelist>
			
			<para>When this node is evaluated, it evaluates to a value with a function interface as the active interface. Only the [parameter] node and [return-info]'s [interface] nodes are evaluated at this time. When the resultant value is called, the [block] node is executed in the scope of this function node.</para>
		</section>
		
		<section xml:id="node.function-interface">
			<title>function-interface</title>
			
			<simplelist role="layout">
				<member>? expression template-argument-count</member>
				<member>* parameter</member>
				<member>return-info</member>
			</simplelist>
		</section>

		<section xml:id="node.generator-producer">
			<title>generator-producer</title>
			
			<para>When executed, produces a function that returns a value that implements an instantiation of the Generator generic interface.</para>
			
			<simplelist role="layout">
				<member>* parameter</member>
				<member>? output-info</member>
				<member>block</member>
			</simplelist>
			
			<programlisting>
$decl foo = $generator(Int a, Int b) Int {
	$decl Int i = a
	$while i &lt; b {
		$yield i
		i++
	}
}

$for i $in foo(2, 5) {
	print foo
	print " "
}

prints: '2 3 4 '

interface of foo {
	call() Generator&lt;Int>
}

foo is a function that returns a Generator&lt;Int>
			</programlisting>
		</section>
		
		<section xml:id="node.generator">
			<title>generator</title>
			
			<programlisting>
$decl foo = $generator {
	$decl Int i = 2
	$while i &lt; 5 {
		$yield i
		i++
	}
}

$for i $in foo {
	print foo
	print " "
}

prints: '2 3 4 '

interface of foo == Generator&lt;Int>

$decl foo = $func(Int a, Int b) Int {
	$return $generator {
		$decl Int i = a
		$while i &lt; b {
			$yield i
			i++
		}
	}
}
			</programlisting>
		</section>
		
		<section xml:id="node.build-list">
			<title>build-list</title>
			
			<para>Produces an array.</para>
			
			<simplelist role="layout">
				<member>expression container</member>
				<member>identifier element name</member>
				<member>? expression test</member>
				<member>? expression output</member>
			</simplelist>
			
			<programlisting>
$decl foo = [2*x for x in L if x^2 > 3]
container: L
element name: x
test: x^2 > 3
output: 2*x

$decl foo = [x in L if x^2 > 3]
container: L
element name: x
test: x^2 > 3
output: (implicit: x)

$decl foo = [x in L]
container: L
element name: x
test: (implicit: true)
output: (implicit: x)
			</programlisting>
		</section>
		
		<section xml:id="node.build-generator">
			<title>build-generator</title>
			
			<para>Produces a generator. (Compare to <link linkend="node.generator-producer">generator-producer</link>, which produces a function.)</para>
			
			<simplelist role="layout">
				<member>expression container</member>
				<member>identifier element name</member>
				<member>? expression test</member>
				<member>expression output</member>
			</simplelist>
			
			<programlisting>
for o in [2*x for x in L if x^2 > 3] {
	println o
}
			</programlisting>
		</section>
		
		<section xml:id="node.generic-class">
			<title>generic-class</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>class</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the class node.</para>
		</section>
		
		<section xml:id="node.generic-function">
			<title>generic-function</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>function</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the function node.</para>
			
			<programlisting>
generic(T)
func larger(T a, T b) T {
	if a &lt; b
		return b
	return a
}

println larger(2, 7) //prints "7"
			</programlisting>
		</section>
		
		<section xml:id="node.generic-interface">
			<title>generic-interface</title>
			
			<simplelist role="layout">
				<member>+ generic-parameter parameters</member>
				<member>interface</member>
			</simplelist>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the interface node.</para>
			
			<programlisting>
generic(T)
interface List {
	func addFront(T)
	func addBack(T)
	func removeFront() T
	func removeBack() T
}

List(Int) list = ...
list.addFront(2)
list.addBack(3)
list.addFront(1)
println list.removeFront() //prints "1"
println list.removeBack() //prints "3"
			</programlisting>
		</section>
		
		<section xml:id="node.generic-parameter">
			<title>generic-parameter</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>? expression default interface</member>
			</simplelist>
		</section>
		
		<section xml:id="node.identifier">
			<title>identifier</title>
			
			<para>Base node. Identifiers can sometimes evaluate to object references. Object references point to an object and have an active interface. Only properties declared by the active interface can be accessed, even if the object implements other interfaces.</para>
			
			<para>When evaluating an identifier to an object: If the identifier is undefined in the current scope, move to the containing scope. If there is no containing scope, throw an UndefinedIdentifier error. Continue moving to outer scopes until the identifier is found or there is no containing scope. If the identifier is bound to an object, the identifier evaluates to that object. If the identifier has been declared that it can be bound to objects, but it is currently not bound to anything, return null. If the identifier is bound to a function, the identifier evaluates to the wrapper for that function, as defined in function-wrapper xxx. If the identifier is bound to a namespace, a NamespaceIdentifier error results.</para>
		</section>

		<section xml:id="node.instantiate-generic-interface">
			<title>instantiate-generic-interface</title>
			
			<simplelist role="layout">
				<member>expression generic interface</member>
				<member>+ argument</member>
			</simplelist>
			
			<para>All the arguments must be interfaces. Pass interfaces in to get a function.</para>
		</section>
		
		<section xml:id="node.instantiate-generic-class">
			<title>instantiate-generic-class</title>
			
			<simplelist role="layout">
				<member>expression generic class</member>
				<member>+ argument</member>
			</simplelist>
			
			<para>All the arugments must be interfaces. Pass interfaces in to get a function.</para>
		</section>
		
		<section xml:id="node.intantiate-generic-function">
			<title>instantiate-generic-function</title>
			
			<simplelist role="layout">
				<member>expression generic function</member>
				<member>+ argument</member>
			</simplelist>
			
			<para>All the arguments must be interfaces. Pass interfaces in to get a function.</para>
		</section>
		
		<section xml:id="node.namespaced-identikey">
			<title>namespaced-identikey</title>
			
			<simplelist role="layout">
				<member>+ identifier namespaces</member>
				<member>identifier identikey name</member>
			</simplelist>
			
			<programlisting>
namespace::namespace::identikey

namespace foo {
	namespace bar {
		Int alpha = ...
	}
}
Int alpha = foo::bar::alpha
			</programlisting>
		</section>
		
		<section xml:id="node.implements">
			<title>implements</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>expression interface</member>
			</simplelist>
			
			<para>Returns a bool object reference to the true or false objects. True if [object] implements [interface], false otherwise.</para>
			
			<programlisting>
if (o imps Foo)
	(o as Foo).propOfFoo()
			</programlisting>
		</section>
		
		<section xml:id="node.integer">
			<title>integer</title>
			
			<para>Base node. Evaluates to an object reference with BigInt as the active interface. The object may implement other interfaces if they do not conflict with the BigInt interface. Must not implement the LimInt interface.</para>
		</section>
		
		<section xml:id="node.interface">
			<title>interface</title>
			
			<simplelist role="layout">
				<member>* expression inheritees</member>
				<member>* statused-member</member>
			</simplelist>
			
			<section xml:id="node.statused-member">
				<title>statused-member</title>
				
				<simplelist role="layout">
					<member>member-status</member>
					<member>interface-member</member>
				</simplelist>
			</section>
			
			<section xml:id="node.member-status">
				<title>member-status</title>
				
				<para>Base node. Specifies "new", "normal", or "deprecated".</para>
			</section>
			
			<section xml:id="node.interface-member">
				<title>interface-member</title>
				
				<para>Supertype. Includes convertor, callee, property, and method.</para>
			</section>
			
			<section xml:id="node.convertor">
				<title>convertor</title>
				
				<simplelist role="layout">
					<member>? expression interface</member>
				</simplelist>
				
				<para>Specifies that implementations of that interface can be converted into the specified type. Or, if [interface] isn't given, that the value can be copied.</para>
			</section>
			
			<section xml:id="node.callee">
				<title>callee</title>
				
				<simplelist role="layout">
					<member>* parameter</member>
					<member>return-info</member>
				</simplelist>
			</section>
			
			<section xml:id="node.property">
				<title>property</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>? expression interface</member>
					<member>access access</member>
				</simplelist>
			</section>
			
			<section xml:id="node.method">
				<title>method</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>expression interface</member>
				</simplelist>
			</section>
			
			<section xml:id="node.access">
				<title>access</title>
				
				<para>Access nodes must specify one of three access levels: only reading, only writing, or both reading and writing.</para>
			</section>
		</section>
		
		<section xml:id="node.same-object">
			<title>same-object</title>
			
			<simplelist role="layout">
				<member>expression</member>
				<member>expression</member>
			</simplelist>
			
			<para>Tells whether the values are associated with the same object.</para>
			
			<programlisting>
Alpha a = getAlpha()
Beta b = getBeta()
if( a === b )
	print "same objects"
			</programlisting>
		</section>
		
		<section xml:id="node.list">
			<title>list</title>
			
			<simplelist role="layout">
				<member>expression [interface]</member>
				<member>* expression [element]</member>
			</simplelist>
			
			<para>Evaluates to a list, as if calling CList{ [interface] } ( [element], [element], ... )</para>
			
			<para>Each [element] is cast to [interface]. If a cast error results, it raises out of the list node, so that the list node doesn't evaluate to anything.</para>
		</section>
		
		<section xml:id="node.object-number">
			<title>object-number</title>
			
			<simplelist role="layout">
				<member>Expression value</member>
			</simplelist>
			
			<para>Every object is associated with a constant non-negative integer. No two objects that are still accessible can have the same object number. This node evaluates to a value, with Int as the active interface, that encodes the object number for the object associated with the given value.</para>
		</section>
		
		<section xml:id="node.rational">
			<title>rational</title>
			
			<para>Base node. Evaluates to an object with BigRat as the active interface. The object may implement other interfaces if they do not conflict with the BigRat interface. Must not implement the LimRat interface.</para>
		</section>
		
		<section xml:id="node.get-property">
			<title>get property</title>
			
			<simplelist role="layout">
				<member>expression value</member>
				<member>identifier property name</member>
			</simplelist>
			
			<para>Retrieves a property of a value. If the active interface of the value does not have a property with the specified name, an error results.</para>
		</section>

		<section xml:id="node.string">
			<title>string</title>
			
			<para>string nodes consist of text</para>
			
			<para>strings are expressions</para>
			
			<para>Base node. Evaluates to an object with interface string as the active interface. The object may implement other interfaces if they do not conflict with the string interface.</para>
		</section>
		
		<section xml:id="node.xor">
			<title>xor</title>
			
			<para>Evaluates to true if the child expressions evaluate to different values.</para>

			<simplelist role="layout">
				<member>2 expression</member>
			</simplelist>

			<orderedlist role="exec">
				<listitem>Evaluate the first [expression] node.</listitem>
				<listitem>Downcast [1] to Bool.</listitem>
				<listitem>Evaluate the second [expression] node.</listitem>
				<listitem>Downcast [3] to Bool.</listitem>
				<listitem>If [2] and [4] are different, evaluate to true. Otherwise, evaluate to false.</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.xnor">
			<title>xnor</title>
			
			<para>Evaluates to true if the child expressions evaluate to the same value.</para>

			<simplelist role="layout">
				<member>2 expression</member>
			</simplelist>

			<orderedlist role="exec">
				<listitem>Evaluate the first [expression] node.</listitem>
				<listitem>Downcast [1] to Bool.</listitem>
				<listitem>Evaluate the second [expression] node.</listitem>
				<listitem>Downcast [3] to Bool.</listitem>
				<listitem>If [2] and [4] are the same, evaluate to true. Otherwise, evaluate to false.</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.create-caller">
			<title>create-caller</title>
			<para role="xxx">come up with better name</para>
			
			<simplelist role="layout">
				<member>? expression interface</member>
				<member>identifier method name</member>
			</simplelist>
			
			<para>Creates a function that, when passed the type specified by [interface], calls the method named [method name] with the rest of the arguments sent to it. It's purpose is to help with functional programming.</para>
			
			<programlisting>
interface Foo {
	func doStuff(Int, Int) Rat
}

Foo foo = getFoo()
func(Foo,Int,Int)Rat doStuffer = Foo::doStuff
println doStuffer(foo,3,7)

dyn doStuffer2 = dyn::doStuff
println doStuffer2(foo,3,7)

//all equilavent
println Foo::doStuff(foo,3,7)
println dyn::doStuff(foo,3,7)
println foo.doStuff(3,7)
			</programlisting>
		</section>
	</section>
	
	<section xml:id="always-produce">
		<title>Always produce</title>
		
		<para>Nodes that always produce a value when executed, and can have side effects.</para>
	
		<section xml:id="node.and">
			<title>and</title>
			
			<para>Evaluates to false if either child expression evaluates to false.</para>
			
			<simplelist role="layout">
				<member>2 expression</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Evaluate the first [expression] node.</listitem>
				<listitem>Downcast [1] to Bool.</listitem>
				<listitem>If [2] is false, evaluate this node to false.</listitem>
				<listitem>Evaluate the second [expression] node.</listitem>
				<listitem>Downcast [4] to Bool.</listitem>
				<listitem>Evaluate this node to [5].</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.nand">
			<title>nand</title>
			
			<para>Evaluates to true if either child expression evaluates to false.</para>

			<simplelist role="layout">
				<member>2 expression</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Evaluate the first [expression] node.</listitem>
				<listitem>Downcast [1] to Bool.</listitem>
				<listitem>If [2] is false, evaluate this node to true.</listitem>
				<listitem>Evaluate the second [expression] node.</listitem>
				<listitem>Downcast [4] to Bool.</listitem>
				<listitem>Evaluate this node to the inverse of [5].</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.or">
			<title>or</title>
			
			<para>Evaluates to true if either child expression evaluates to true.</para>

			<simplelist role="layout">
				<member>2 expression</member>
			</simplelist>

			<orderedlist role="exec">
				<listitem>Evaluate the first [expression] node.</listitem>
				<listitem>Downcast [1] to Bool.</listitem>
				<listitem>If [2] is true, evaluate this node to true.</listitem>
				<listitem>Evaluate the second [expression] node.</listitem>
				<listitem>Downcast [4] to Bool.</listitem>
				<listitem>Evaluate this node to [5].</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.nor">
			<title>nor</title>
			
			<para>Evaluates to false if either child expression evaluates to true.</para>

			<simplelist role="layout">
				<member>2 expression</member>
			</simplelist>

			<orderedlist role="exec">
				<listitem>Evaluate the first [expression] node.</listitem>
				<listitem>Downcast [1] to Bool.</listitem>
				<listitem>If [2] is true, evaluate this node to false.</listitem>
				<listitem>Evaluate the second [expression] node.</listitem>
				<listitem>Downcast [4] to Bool.</listitem>
				<listitem>Evaluate this node to the inverse of [5].</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.assign">
			<title>assign</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>expression value</member>
			</simplelist>
			
			<para>Assigns the value to the identikey. If the identikey's type is not function, the identikey will be unbound first if it is already bound to something. The identikey's type must be dynamic, automatic, strict, or function. If the identikey's type is automatic, strict, or function, identifier must be variable.</para>
		</section>
		
		<section xml:id="node.declare-assign">
			<title>declare-assign</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>identikey-type</member>
				<member>expression value</member>
			</simplelist>
			
			<para role="process">The identikey-category of the identikey-type node must be dynamic, automatic, strict, or function.</para>
			
			<para>Creates an identikey in the parent scope with the specified type, then assigns the specified value to it.</para>
		</section>
		
		<section xml:id="node.unassign">
			<title>unassign</title>
			
			<simplelist role="layout">
				<member>expression</member>
			</simplelist>
			
			<para>Unassigns the values bound to the given reference. If the identikey is a function identikey, all bound functions are unbound.</para>
			
			<para role="xxx">Is this needed? Why not just assign null?</para>
		</section>
		
		<section xml:id="node.unassign-function">
			<title>unassign-function</title>
			
			<simplelist role="layout">
				<member>expression</member>
				<member>interface</member>
			</simplelist>
			
			<para>Unassigns the function with the specified interface from the given value.</para>
			
			<para role="xxx">What to do when such a function isn't bound? throw an error?</para>
		</section>
	</section>
	
	<section xml:id="unsorted-nodes">
		<title>Unsorted nodes</title>

		<section xml:id="node.alias">
			<title>alias</title>
			
			<simplelist role="layout">
				<member>chain target</member>
				<member>? identifier name</member>
			</simplelist>

			<para>Note: Due to the whole "everything's an object" business, this node should probably be removed. XXX But what about namespaces?!</para>
			
			<programlisting>
alias FooBarBaz as FBZ
alias Alpha.Beta.Gamma //the "as Gamma" part is implied
alias System.out.print as puts
puts( FBZ.toString(Gamma) )
			</programlisting>
			
			<programlisting>
auto FBZ = FooBarBaz
auto Gamma = Alpha.Beta.Gamma
auto puts = System.out.print
puts( FBZ.toString(Gamma) )
			</programlisting>
			
			<programlisting>
//if Gamma is a namespace
namespace Gamma = Alpha.Beta.Gamma
			</programlisting>
		</section>
	</section>
</chapter>