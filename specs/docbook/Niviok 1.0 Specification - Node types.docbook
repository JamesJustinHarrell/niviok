<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="node-types">
	<title>Node types</title>

	<para>This chapter describes the various types of nodes. A node type is either a family, tree, or terminal node type. A family node type is a collection of node types. A tree node is a node that is composed of other nodes. Tree nodes do not directly encode any data themselves. The nodes a tree node type contains is specified by the tree node's layout. When the a layout specifies the type of a child node is that of a family node type, the type of the child that takes that place must be in the collection of that family node type. A terminal node encodes data directly and does not contain other nodes.</para>
	
	<section xml:id="terminal-node-types">
		<title>Terminal nodes</title>
		
		<para>These node types do not contain child nodes, and are thus the only nodes that must encode information themselves (as opposed to containing child nodes which together provide information).</para>

		<!-- filled in by "genhtml.py" -->
		<simplelist xml:id="terminal-node-types-list"/>
	</section>
	
	<section xml:id="family-node-types">
		<title>Family node types</title>
		
		<section xml:id="node.expression">
			<title>expression</title>
			
			<para>Any node type specified directly in one the following listed sections is an expression node.  (Excludes node types specified in the sections of other node types.) Expression nodes can be executed, and may produce values.</para>
			
			<simplelist role="family-members">
				<member linkend="non-producing-expressions">Non-producing Expressions</member>
				<member linkend="sometimes-producing-expressions">Sometimes producing expressions</member>
				<member linkend="always-producing-expressions">Always producing expressions</member>
			</simplelist>
		</section>
		
		<section xml:id="node.statement-declaration">
			<title>statement-declaration</title>
			
			<para>Declares new local identikeys and assigns new stuff to them.</para>
			
			<para>This family node type includes these types:</para>
			
			<simplelist role="family-members">
				<member>declare-first</member>
				<member>sieve</member>
			</simplelist>
		</section>
		
		<section xml:id="node.interface-member">
			<title>interface-member</title>
			
			<para>This family node type includes these types:</para>
			
			<simplelist role="family-members">
				<member>breeder</member>
				<member>callee</member>
				<member>property</member>
				<member>method</member>
			</simplelist>
		</section>
	</section>
	
	<section xml:id="tree-node-layout-key">
		<title>Tree node layout key</title>
		
		<para>This section describes how the layout of a node type is represented in this specification.</para>
		
		<para>The layout for a node type is represented in this specification as a list of items. Each item represents a child node, or multiple child nodes with the same meaning.</para>
		
		<para>Each item in these lists first specifies how many child nodes with that meaning may appear, or it says nothing about the number, which means there must be one (and no more). The ways of representing these amounts is described below.</para>
		
		<variablelist>
			<varlistentry>
				<term>?</term>
				<listitem>0 or 1</listitem>
			</varlistentry>
			<varlistentry>
				<term>*</term>
				<listitem>0 or more</listitem>
			</varlistentry>
			<varlistentry>
				<term>+</term>
				<listitem>1 or more</listitem>
			</varlistentry>
		</variablelist>
		
		<para>Next comes the name of a node type. The child node represented by that list item must be of that type.</para>
		
		<para>Lastly comes a optional label for refering to the child nodes represented by that item, when the type alone isn't enough to disambiguate which item is being referred to. These labels carry no semantic information, and are merely used by this specification to refer to specific child nodes. (Note this label is always singular, even for collections.)</para>
		
		<para>Example layout:</para>
		
		<screen>
alpha
? beta gamma
? beta delta
* epsilon
+ expression zeta
		</screen>
		
		<para>The first item represents a single required child node of type "alpha". The second item represents an optional child node of type "beta", which can be referred to using the label "gamma". The third item represents an optional child node of type "beta", which can be referred to using the label "delta". The fourth item refers to a collection of child nodes of type "epsilon"; the collection can be empty. The fifth item refers to a collection of expression child nodes; the collection must contain at least one node; nodes in this collection can be refered to using the label "zeta".</para>
	</section>
	
	<section xml:id="non-executable">
		<title>Non-executable</title>
		
		<para>Nodes that cannot be executed. Most serve only to group other nodes together.</para>
		
		<section xml:id="node.argument">
			<title>argument</title>
			
			<simplelist role="layout">
				<member>? identifier parameter name</member>
				<member>? expression value</member>
			</simplelist>
			
			<programlisting>
func doSomething(Int a = 1, Int b = 2, Int c = 3, Int d) {...}
doSomething(7, default, default, 8)
doSomething(7, c = default, 8)
			</programlisting>
		</section>
		
		<section xml:id="node.boolean">
			<title>boolean</title>
			
			<para>Terminal node. Specifies one of:</para>
			
			<simplelist role="enum">
				<member>true</member>
				<member>false</member>
			</simplelist>
			
			<para>Cannot be evaluated because that would conflict with the "true" and "false" members of the Bool enum. Boolean values in the node tree use a boolean node, and boolean values in code use the "true" and "false" identikeys.</para>
		</section>
		
		<section xml:id="node.direction">
			<title>direction</title>
			
			<para>Specifies the direction of a function parameter.</para>
			
			<para>Terminal node. Specifies one of:</para>
			
			<simplelist role="enum">
				<member>in</member>
				<member>out</member>
				<member>inout</member>
			</simplelist>
			
			<para role="xxx">At one time also included "in-mutable" and "in-mutable-out". The nun-mutable version would create copies. It is not clear whether these should be kept. Parameter direction is currently ignored.</para>
			
			<para>A value passed to a function as an "in" parameter will not be mutated by the function. This means if the function uses the value in ways that may mutate the value, the value will be copied. If an action in the function may mutate the value, and the value does not declare a copy converter, an error results.</para>
			
			<para>Instances where the value may be mutated include when the interface of the value does not provide opacity information and the function calls a method, or if the interface does provide opacity information but the function calls a mutator method, or if the value is passed to another function as an in-mutable or in-mutable-out parameter.</para>
			
			<programlisting>
func alpha(in Int num) {
println num
}

func beta(in-mutable Int num) {
num += 567
}

func gamma(out Int num) {
//num not currently assigned to anything
num = 987
}

func delta(in-out Int num) {
println num
num = 1001
}

func epsilon(in-mutable-out Int num) {
num += 55555
num = 19591
}

Int num = 123
alpha(num)
beta(num) //value mutated
gamma(num) //num assigned to different value
delta(num) //num assigned to different value
epsilon(num) //value mutated and num assigned to different value
			</programlisting>
		</section>
		
		<section xml:id="node.import">
			<title>import</title>
			
			<para>Binds a library to a namespace identikey.</para>
			
			<simplelist role="layout">
				<member>identifier alias</member>
				<member>+ import-attempt</member>
			</simplelist>
			
			<para>Each import-attempt node attempts to refer to a library. The agent should try each import-attempt node in order until it is able to find one with a scheme that it recognizes and leads to a library the agent is able to load. If the agent is not able to load a library after trying all import-attempt nodes, it must output an error message and end execution immediately.</para>
				
			<programlisting>
import Xml
	"name" : "XmlLib"
	"UUID" : "9d0d5fdc-5a23-4375-892a-8cbfd80f0927"
	"local absolute path" : "/usr/bin/xmllib/niviok/xmllib.niviok.so"
	"local absolute path" : "C:\Program Files\XmlLib\bin\Niviok\xmllib.niviok.so"
	"local relative path" : "bin/xmllib.niviok.so"
	"URL" : "https://www.xmllib.org/repository/xmllib.niviok.so"

def doc = Xml:Document()
doc.appendChild(doc.createElement("foo"))
def Xml:Element root = doc.documentElement
			</programlisting>
			
			<para>Note that this specification does not define any schemes. Which schemes are supported by an agent is agent-specific.</para>
			
			<para role="xxx">Need versioning information. Could just include versioning information in the body of each import-attempt, but then the version information would have to be repeated for every import-attempt. Even if going with that, example should be updated to inclue versioning information. But what if different schemes wanted to denote versioning information in different ways? For example, shared libraries on Unix have their own versioning system, with version numbers different from the public version number associated with a piece of software.</para>
		</section>
			
		<section xml:id="node.import-attempt">
			<title>import-attempt</title>
			
			<simplelist role="layout">
				<member>string scheme</member>
				<member>string body</member>
			</simplelist>
			
			<para>Used by the @@import node.</para>
		</section>
		
		<section xml:id="node.member-implementation">
			<title>member-implementation</title>
			
			<simplelist role="layout">
				<member>member-type</member>
				<member>? identifier name</member>
				<member>? expression interface</member>
				<member>expression function</member>
			</simplelist>
		</section>
		
		<section xml:id="node.member-type">
			<title>member-type</title>
			
			<para>Terminal node. Specifies one of:</para>
			
			<simplelist role="enum">
				<member>breeder</member>
				<member>callee</member>
				<member>getter</member>
				<member>setter</member>
				<member>method</member>
			</simplelist>
		</section>

		<section xml:id="node.parameter-impl">
			<title>parameter-impl</title>
			
			<simplelist role="layout">
				<member>direction</member>
				<member>expression type</member>
				<member>identifier name</member>
				<member>? expression default value</member>
			</simplelist>
			
			<para>When a [default value] is given, [default value] is executed for every call to the function. It is not executed when the function node is executed.</para>
		</section>

		<section xml:id="node.parameter-info">
			<title>parameter-info</title>
			
			<simplelist role="layout">
				<member>direction</member>
				<member>expression type</member>
				<member>identifier name</member>
				<member>boolean has default value</member>
			</simplelist>
		</section>

		<section xml:id="node.worker">
			<title>worker</title>
			
			<simplelist role="layout">
				<member>expression face</member>
				<member>* worker child worker</member>
				<member>* member-implementation</member>
			</simplelist>
			
			<para>Note: May actually correspond to multiple workers, since some of the member-implementation nodes may implement members of inherited interfaces.</para>
		</section>
	</section>
	
	<section xml:id="statements">
		<title>Statements</title>
		
		<para>Statements can be executed. Statements do not produce when executed. Statements differ from non-producing expressions in that statements have special execution rules that greatly restrict where they can appear.</para>
		
		<section xml:id="node.declare-first">
			<title>declare-first</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>boolean overload</member>
				<member>expression type</member>
				<member>boolean breed</member>
				<member>expression value</member>
			</simplelist>
			
			<para role="xxx">Should [breed] be required to be false if [wo-scidentre-category] is "function"?</para>
			
			<para>Creates an scidentre in the parent scope ash assigns the specified value to it. If [overload] is true, creates on overload scidentre; otherwise creates a constant scidentre.</para>
			
			<para>The value expressions of declare-first nodes may depend on the values of other declare-first nodes that appear before or after it. Some types of expressions are allowed to reference the scidentres of each other. For example, two interfaces could reference each other.</para>
			
			<para>For more (xxx outdated) information, see <link linkend="handling-declare-first">this section</link>.</para>
			
			<programlisting>
func b {3}

!declfirst !functionworef b = !function(->Int) { 3 }

declfirst Foo = interface {
	get Bar bar
	get Int number
}

declfirst Bar = interface {
	get Foo foo
}

const Foo foo = getFoo()
println( foo.bar.foo.bar.foo.bar.foo.number )
			</programlisting>
		</section>
		
		<section xml:id="node.hidable">
			<title>hidable</title>

			<simplelist role="layout">
				<member>boolean hidden</member>
				<member>statement-declaration declaration</member>
			</simplelist>
		</section>
		
		<section xml:id="node.sieve">
			<title>sieve</title>
			
			<para>Limits reach of expose and using nodes. Can hide child scidentres.</para>
			
			<para>Like some other special expressions, screen nodes add identikeys to their parent scope, as well as creating their own scope and adding identikeys to it.</para>
			
			<simplelist role="layout">
				<member>* expression expose</member>
				<member>* hidable</member>
			</simplelist>
			
			<para>Example of sieve nodes used to contain the effects of "using" nodes:</para>
			
			<programlisting>
--- file A
module
	import as Foo [...]
	sieve
		include B
		include C

--- file B
using Foo as Bar

--- file C
func main {
	println(Bar:something)
}

--- all together
module
	import as Foo
	sieve
		sieve
			using Foo as Bar
		sieve
			func main {
				Bar:do_something() #error - Bar namespace not defined
			}
			</programlisting>
		</section>
		
		<section xml:id="node.module">
			<title>module</title>
			
			<para>A grouping of identikey declarations, for use as a library or a standalone program.</para>
			
			<simplelist role="layout">
				<member>integer niviok major version number</member>
				<member>integer niviok minor version number</member>
				<member>* import</member>
				<member>sieve</member>
			</simplelist>
			
			<para>No node can contain a module node. Module nodes are the only nodes which can ever be parentless. All nodes that are ever executed in any way must be part of a complete tree, with a module node as the rootmost node.</para>
			
			<para role="xxx">Following stuff needs to be moved. Also, see "executing module.txt".</para>
			
			<para>Implementations must not pass any arguments to the main function when executing a bundle as a standalone executable. Implementations should instead provide program arguments through a library which can be imported with the import node. Note that the program arguments are not required by this specification to be a sequence of strings.</para>
			
			<para>The result produced by executing a bundle node as a standalone executable may be converted as necesary to suit the containing environment. How this conversion is performed depends on the containing environment and the Desal implementation, and is not covered by this specification.</para>
			
			<para>When treating a bundle as a standalone executable:</para>
			
			<orderedlist role="exec">
				<listitem>Let globalScope be a new scope.</listitem>
				<listitem>Create the identikeys required by <link linkend="reserved-identikey-names">Reserved identikey names</link>.</listitem>
				<listitem>For each @@import and expose child node, add the identikeys to globalScope specified by that node.</listitem>
				<listitem>Execute all declaration-first children of each plane together as required by <link linkend="handling-declare-first">Handling declare-first nodes</link>.</listitem>
				<listitem>Let mainKey be the identikey in globalScope that is associated with identifier "main". If such an identikey does not exist, throw an error.</listitem>
				<listitem>Let mainVal be the result of evaluating mainKey. If mainVal is null, throw an error.</listitem>
				<listitem>Call mainVal with no arguments and let rv be the result. If mainVal is not callable, throw an error. If mainVal does not have a callee that takes no arguments, throw an error.</listitem>
				<listitem>If rv is null, produce a value, with Int as the active interface, that encodes the number zero. Else if rv has an active interface that inherits from Int, downcast rv to Int and produce the result. Else if rv, with it's current active interface, can breed an Int, have rv breed an Int, and produce the result. Else throw an error.</listitem>
			</orderedlist>
			
			<para>When treating a bundle as a library:</para>
			
			<orderedlist role="exec">
				<listitem>Let globalScope be a new scope.</listitem>
				<listitem>Create the identikeys required by <link linkend="reserved-identikey-names">Reserved identikey names</link>.</listitem>
				<listitem>For each @@import and expose child node, add the identikeys to globalScope specified by that node.</listitem>
				<listitem>Execute all declaration-first children of each plane together as required by <link linkend="handling-declare-first">Handling declare-first nodes</link>.</listitem>
				<listitem>Expose globalScope, in an immutable form, to the containing environment. How this is done depends on the containing enviornment and the Desal implementation, and is not covered by this specification.</listitem>
			</orderedlist>
			
			<para role="xxx">When acting as a standalone executable, need to specify what happens to exceptions that bubble all the way up to the bundle node. They are caught, an error message is output, and the bundle node returns some value, like 1. The bundle may expose to the containing environment additional information, depending on the enclosing environment and Desal implementation.</para>
			
			<para role="xxx">When acting as a standalone executable, what kind of errors should bundle by throwing? This is a problem that applies to many other nodes as well.</para>
			
			<para role="xxx">For when acting as a library, need a means of hiding/showing certain child namespaces/identikeys of the global namespace. For example, a bundle may have declarations in the global namespace and in a "private" namespace. The bundle should expose the declarations in the global namespace but hide the declarations in the private namespace. There has also been consideration of an "export" attribute/node that would expose specified identikeys, and all other identikeys would not be exposed.</para>
			
			<para role="xxx">The identikeys added to globalScope by import, using, and expose nodes should not be exposed to the containing environment when the bundle is acting as a library.</para>
		</section>
	</section>
	
	<section xml:id="non-producing-expressions">
		<title>Non-producing expressions</title>
		
		<para>Nodes that can be executed, but never produce.</para>

		<section xml:id="control-flow-alteration">
			<title>Control flow alteration</title>
			
			<para>The nodes alter the control flow when executed. For example, if present in a sequence of statements that are executed in order, executing a node of this type alters control flow in such a way that the following statements in the sequence are not executed (or execution is delayed until other expression nodes have been executed).</para>
			
			<section xml:id="node.remit">
				<title>remit</title>
				
				<simplelist role="layout">
					<member>? identifier label</member>
				</simplelist>
				
				<para role="process">Must have REMIT allowance. If [label] is specified, must have labled REMIT allowance of that name.</para>
				
				<para>The catch nodes that follows the catch node that this node was in are checked, as if the catch node that this node was in was never entered.</para>
			</section>
			
			<section xml:id="node.throw">
				<title>throw</title>
				
				<simplelist role="layout">
					<member>expression value</member>
				</simplelist>
				
				<para>If the expression isn't an Exception, throw a NonExceptionThrownError with the value from [value] as the wrapped value.</para>
			</section>
	
			<section xml:id="node.yield">
				<title>yield</title>
				
				<para>Within a generator, specifies the next value for the generator to yield.</para>
				
				<simplelist role="layout">
					<member>expression value</member>
				</simplelist>
				
				<para role="process">Must have YIELD allowance.</para>
				
				<para>Note that this node may, in the future, become more like Python's yield expression, so that the yield node would become a sometimes-producing expression.</para>
			</section>
		</section>
		
		<section xml:id="node.declare-empty">
			<title>declare-empty</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>expression type</member>
			</simplelist>
			
			<para>Creates a variable scidentre in the parent scope. After this node executes, the produced scidentre does not yet point to a value.</para>

			<programlisting>
var foo
var any foo
var ? foo
var ?any foo
decl Int foo
decl ?Int foo
			</programlisting>
			
			<programlisting>
var bar
bar = 123
println(bar)
bar = 456
println(bar)
			</programlisting>
		</section>
	</section>

	<section xml:id="sometimes-producing-expressions">
		<title>Sometimes producing expressions</title>
		
		<para>Nodes that can be executed, and sometimes produce.</para>

		<section xml:id="node.assign">
			<title>assign</title>
			
			<para>Assigns a value to an identikey.</para>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>boolean breed</member>
				<member>expression value</member>
			</simplelist>
			
			<para role="process">The identikey's type must be dynamic, automatic, or strict. If the identikey's type is automatic or strict, the identifier must be variable (not constant).</para>
			
			<para>If bree is false:</para>
			
			<orderedlist>
				<listitem>Let key by the identikey that [name] refers to.</listitem>
				<listitem>Execute [value] and let value be the product.</listitem>
				<listitem>Associate key with value so that key now refers (only) to value.</listitem>
			</orderedlist>
			
			<para>If breed is true:</para>
			
			<orderedlist>
				<listitem>Let key be the identikey that [name] refers to.</listitem>
				<listitem>Execute [value] and let parentValue be the product.</listitem>
				<listitem>Let faceValue be the required interface for key. If key does not require a particular interface, let faceValue be the active interface of parentValue.</listitem>
				<listitem>Find parentValue's breeder that produces values with an active interface of faceValue. If such a breeder is not found, throw an error.</listitem>
				<listitem>Activate the found breeder and let value be the product.</listitem>
				<listitem>Associate key with value so that key now refers (only) to value.</listitem>
			</orderedlist>
			
			<para>Example of difference between breeding and not breeding:</para>
			
			<programlisting>
decl Person person1
decl Person person2

person1 = Person()
person1.name = "John"
person2 = person1 //not breeding - person1 and person2 refer to same object
person2.name = "Suzy"
println( person1.name ) //Suzy

person1 = Person()
person1.name = "Michael"
person2 := person1 //breeding - person1 and person2 refer to different objects
person2.name = "Kim"
println( person1.name ) //Michael
			</programlisting>
		</section>
		
		<section xml:id="node.call">
			<title>call</title>

			<simplelist role="layout">
				<member>expression receiver</member>
				<member>* argument</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Execute [receiver], and let receiver be the result.</listitem>
				<listitem>If result is not callable, throw an error.</listitem>
				<listitem>Execute the argument values in order.</listitem>
				<listitem>Send argument values to receiver for execution.</listitem>
				<listitem>Produce the result on the previous step.</listitem>
			</orderedlist>
		</section>
		
		<section xml:id="node.compound">
			<title>compound</title>
			
			<simplelist role="layout">
				<member>* expression expose</member>
				<member>* statement-declaration declaration</member>
				<member>+ expression member</member>
			</simplelist>
			
			<para>Has scope.</para>
			
			<orderedlist role="exec">
				<listitem>Execute each expression in order. Produce the result of the last expression. (Produce nothing if the instance contained no expressions or the last expression didn't produce.)</listitem>
			</orderedlist>
			
			<programlisting>
compound {
	using System:Console
	using System:Collections as Boxes
	const numbers = Boxes:List&lt;MyFace>()
	Console.WriteLine(numbers.Count.ToString())
}
			</programlisting>
		</section>
			
		<section xml:id="node.conditional">
			<title>conditional</title>
			
			<simplelist role="layout">
				<member>expression test</member>
				<member>expression result</member>
				<member>? expression else</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Execute [test] and let test1 be the result.</listitem>
				<listitem>Downcast test2 to Bool and let test2 be the result.</listitem>
				<listitem>If test2 is true, execute [result] and produce it's result, ending execution.</listitem>
				<listitem>If [else] is not present, produce null, ending execution.</listitem>
				<listitem>Execute [else] and produce it's result.</listitem>
			</orderedlist>
			
			<programlisting>
decl Int a = (x ? 0 : 1)

if foo == 1
	doStuff1()
elif foo == 2
	doStuff2()
else
	doDefault()

decl bar =
	(foo == 1) ? getOne() :
	(foo == 2) ? getTwo() :
	getDefault()

decl bar =
	if foo == 1 : getOne()
	elif foo == 2 : getTwo()
	else : getDefault()

if not foo.isSetup?
	foo.setup()

unless prefs.dont_do_it
	do_it()
			</programlisting>
		</section>
		
		<section xml:id="node.curry">
			<title>curry</title>
			
			<para>Provides a built-in means of partial application. (Note that Desal provides no built-in support for the original type of currying, where a multi-argument function is converted into a chain of single-argument functions.)</para>
			
			<simplelist role="layout">
				<member>expression function</member>
				<member>* argument</member>
				<member>boolean call</member>
			</simplelist>

			<para>If [call] is true, and this node results in the function receiving enough arguments to be called, the function will be called.</para>
			
			<programlisting>
func foo(Int a, Rat b, String c, Bool d) Int {
	...
}

//partial application
func(String,Bool)Int foo2 = foo(1, 2.34)
print foo2("text", true)

//other type of currying
func(Int)(
	func(Rat)(
		func(String)(
			func(Bool)Int ))) foo3 = curry(foo)
print foo3(1)(2.34)("text")(true)

//The above two are equivalent to:
print foo(1, 2.34, "text", true)
			</programlisting>
			
			<para>Assuming the function is not called: If the arguments match only one of the callees/methods of [value], this node produces a value with a function interface as the active interface. If the arguments match more than one of the callees/methods on [value], this node produces a value with an active interface that is made by adding the function interfaces of the callees/methods together.</para>
			
			<para>After execution, the specified parameters have values, so they do not appear on the resultant function.</para>
			
			<para>Once the function has all its arguments supplied, it is called if [call] is true, and the result of that call is produced.</para>
			
			<programlisting>
func doStuff1(Int a, String b, Bool alpha) {...}
func doStuff1(Int a, Rat b, Bool alpha) {...}
func doStuff2 = doStuff1~(3, alpha=false)
doStuff2("test")
doStuff2(123.456)
			</programlisting>
			
			<para>The middle line perhaps might also be represented this way:</para>
			<programlisting>
(declare-first
	(identifier.name "doStuff2")
	(curry
		(identifier.value "doStuff1")
		(argument
			(integer.value 3))
		(argument
			(identifier.name "alpha")
			(identifier.value "false"))))
			</programlisting>

			<programlisting>
interface Alpha
func bar(Int a, Rat b, String c)

Alpha alpha = AlphaClass()

alpha.bar(0, 0.0, "0")

func()void bar1 = alpha.bar~()
bar(1, 2.3, "4")

func()void bar2 = alpha.bar~(c="text")
bar2(7, 9.8)

func()void bar3 = alpha.bar~(-9, 0.001, "stuff")
bar3()
			</programlisting>
		</section>
		
		<section xml:id="node.declare-assign">
			<title>declare-assign</title>
			
			<simplelist role="layout">
				<member>identifier name</member>
				<member>boolean constant</member>
				<member>expression type</member>
				<member>boolean breed</member>
				<member>expression value</member>
			</simplelist>

			<para>Creates a scidentre in the parent scope and assigns the specified value to it. If [constant] is false, creates a constant scidentre; otherwise, creates a variable scidentre.</para>
			
			<programlisting>
var any foo = 123
var Nullable&lt;any> foo = 123
var ?any foo = 123
var Int foo = 123
var Nullable&lt;Int> foo = 123
var ?Int foo = 123
			</programlisting>
		</section>
		
		<section xml:id="node.identifier">
			<title>identifier</title>
			
			<para>Base/terminal node.</para>
			
			<orderedlist role="exec">
				<listitem>Let ident be the identifier specified by this node.</listitem>
				<listitem>Let scope be the current scope.</listitem>
				<listitem>If scope has an identikey that is associated with ident, let scope be the parent scope of scope. If scope has no parent scope, throw an error. Continue moving through parent scopes until an identikey associated with ident is found. Let key be this identikey.</listitem>
				<listitem>If key is a function identikey, find parent function identikeys with that name, but with different types, and merge all the functions together. (XXX elaborate)</listitem>
				<listitem>If key is bound to a value, produce the value that key is bound to. If key has been declared that it can be bound to values, but it is currently not bound to anything, return null.</listitem>
				<listitem>If key is bound to a namespace, throw an error.</listitem>
			</orderedlist>
			
			<programlisting>
println( foo )
			</programlisting>
			
			<programlisting>
(println foo)
			</programlisting>
		</section>
	
		<section xml:id="node.select">
			<title>select</title>
			
			<simplelist role="layout">
				<member>expression input value</member>
				<member>* case</member>
				<member>? expression else</member>
			</simplelist>
			
			<para role="exec">Execute [value]. Execute each [values] child of each [case] and compare them to the [value] value (with the .equals? method of the [value] value) until finding a match. Then, execute the [result] of that case and produce the result. If no match is found, and [else] is given, execute [else] and produce its result.</para>
			
			<section xml:id="node.case">
				<title>case</title>
				
				<simplelist role="layout">
					<member>+ expression test value</member>
					<member>expression result</member>
				</simplelist>
			</section>
			
			<programlisting>
select event.type
case Events.QUIT {
	return
}
case Events.FOO, Events.BAR, Events.MAZ {
	//no action
}
else {
	throw ErrorClass("unknown event type")
}

select foo
case 1
	doStuff1()
case 2
	doStuff2()
else
	doDefault()

decl bar = select foo
	case 1 : getOne()
	case 2 : getTwo()
	else getDefault()
			</programlisting>
		</section>
		
		<section xml:id="node.set-property">
			<title>set-property</title>

			<simplelist role="layout">
				<member>expression source</member>
				<member>identifier property name</member>
				<member>expression value</member>
			</simplelist>
			
			<para>Sets the value of a property. If the active interface of the value does not have a property with the specified name, or the property cannot be set, an error results. Evaluates to the value given by [value].</para>
			
			<programlisting>
alpha.beta = "gamma"
			</programlisting>
			
			<programlisting>
(= alpha.beta "gamma")
			</programlisting>
		</section>
		
		<section xml:id="node.try-catch">
			<title>try-catch</title>
			
			<simplelist role="layout">
				<member>expression try</member>
				<member>* catcher</member>
				<member>? expression on success</member>
				<member>? expression finally</member>
			</simplelist>
			
			<para role="process">Must contain more than just [try].</para>
			
			<section xml:id="node.catcher">
				<title>catcher</title>

				<simplelist role="layout">
					<member>expression type</member>
					<member>? identifier name</member>
					<member>? expression test</member>
					<member>expression result</member>
				</simplelist>
				
				<para role="allowance">The [result] node adds a REMIT allowance.</para>
			</section>
			
			<screen>
function execute ( Node_TryCatch node, IScope parentScope ) -> IWorker {
	IScope tryCatchScope = new Scope(parentScope)
	IWorker result
	try {
		result = execute(node.try, tryCatchScope)
	}
	catch( ClientException exception ) {
		for(Node_Catch c in node.catchs) {
			try {
				Type type = Type.wrap(execute(c.type, tryCatchScope))
				if (can_downcast(exception.worker, type)) {
					IScope catchScope = new Scope(parentScope)
					if (c.name != null) {
						G.declareAssign(
							c.name.value
							WoScidentreCategory.CONSTANT,
							type,
							exception.worker,
							catchScope)
					}
					if (c.test != null) {
						if (unwrapBoolean(execute(c.test, catchScope)) == false) {
							continue
						}
					}
					try {
						result = execute(c.result, catchScope)
					}
					catch( ClientRemit remit ) {
						continue
					}
				}
			}
			catch( ClientException exception2 ) {
				if (node.finally != null) {
					execute(node.finally, tryCatchScope)
					throw exception2
				}
			}
		}
		if (node.finally != null) {
			execute(node.finally, tryCatchScope)
			throw exception
		}
	}
	if (node.onSuccess != null) {
		try {
			result = execute(node.onSuccess, tryCatchScope)
		}
		catch( ClientException exception ) {
			if (node.finally != null) {
				execute(node.finally, tryCatchScope)
				throw exception
			}
		}
	}
	if (node.finally != null) {
		execute(node.finally, tryCatchScope)
	}
	return result
}

Execute [try] and let result be the result.
If an exeception raised up through [try] as it was being executed:
	Let exception be the exception.
	For each [catch] child:
		Execute the type expression and let type be the result.
		If the [type] of catch does not match exception, continue to the next catch.
		If the catch specifies a name, bind the exception to that name as a constant.
		If tha catch specifies a test, execute the test, and continue to the next catch if the result is false.
		Execute the [result] of catch and set result to be the product, then stop looking for a catch.
		If a remit signal raises out of the catch while executing it, continue the search for a catch.
		If an exception raises out of the type, test, or result expressions, execute [finally] if present, and then allow the exception to rise out.
	If no matching catch nodes were found, execute [finally] if present, and then allow the exception to rise out.
Otherwise, execute [on success] if present and set [result] to be the result. If an exception raises out of [on success] while executing it, execute [finally] and allow the exception to rise out.
Execute [finally] if present.
Produce result.
			</screen>
			
			<programlisting>
try
	decl foo = getSomething()
observe( OutOfMemoryError )
	println "I'm not catching that!"
	//exception is noticed by this try-catch node, but not caught
	//the exception continues to rise out
catch( NullError )
	println "null error"
catch( FooError e )
	println "FooError: (e.message)"
catch( Error )
	println "unknown error"
catch( Exception )
	println "unknown exception"
observe
	println "how execution reach here? am not good with computer"
else
	println "no errors!"
	doSomeStuff() //don't catch errors from this in this node
finally
	cleanup(foo)

decl Status stat =
try
	doSomething()
	Statuses.SUCCESS
catch( NotSoBadError ) {
	Statuses.ERROR
observe
	println "something horrible not caught when trying to doSomething()"
			</programlisting>
			
			<para role="xxx">This node is too complicated. Try to simplify it. In particular, see about removing remit node and reintroducing catch/observe distinction.</para>
		</section>
		
		<section xml:id="node.type-select">
			<title>type-select</title>
			
			<simplelist role="layout">
				<member>expression input value</member>
				<member>? identifier casted name</member>
				<member>? boolean require match</member>
				<member>* type-case</member>
				<member>? expression else</member>
			</simplelist>
			
			<para role="process">[require match] must be present if and only if an [else] is not given.</para>
			
			<para>If [require match] is true (which means an [else] was not given) and no match was found, an exception is thrown.</para>
			
			<section xml:id="node.type-case">
				<title>type-case</title>
				
				<simplelist role="layout">
					<member>+ expression test type</member>
					<member>expression result</member>
				</simplelist>
			</section>
			
			<screen>
if e is declare-assign
	e2 = e as declare-assign
	sb.reserveWoScidentre( e2.name, e2.category )
elif e is declare-empty
	e2 = e as declare-empty
	sb.reserveWoScidentre( e2.name, e2.category )

typeselect e as e2
case declare-assign
	sb.reserveWoScidentre( e2.name, e2.category )
case declare-empty
	sb.reserveWoScidentre( e2.name, e2.category )

typeselect e as e2
case declare-assign, declare-empty
	sb.reserveWoScidentre( e2.name, e2.category )
			</screen>
		</section>
	</section>
	
	<section xml:id="always-producing-expressions">
		<title>Always producing expressions</title>
		
		<para>Expressions that, aside from e.g. exceptions, always produce when executed. These nodes, other than the and, nand, or, and nor nodes, are not intended to have side effects.</para>
		
		<section xml:id="boolean-logic">
			<title>Boolean logic</title>
			
			<section xml:id="node.and">
				<title>and</title>
				
				<para>Evaluates to false if either child expression evaluates to false.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is false, evaluate this node to false.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.nand">
				<title>nand</title>
				
				<para>Evaluates to true if either child expression evaluates to false.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is false, evaluate this node to true.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to the inverse of [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.or">
				<title>or</title>
				
				<para>Evaluates to true if either child expression evaluates to true.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is true, evaluate this node to true.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.nor">
				<title>nor</title>
				
				<para>Evaluates to false if either child expression evaluates to true.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>If [2] is true, evaluate this node to false.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [4] to Bool.</listitem>
					<listitem>Evaluate this node to the inverse of [5].</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.xor">
				<title>xor</title>
				
				<para>Evaluates to true if the child expressions evaluate to different values.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [3] to Bool.</listitem>
					<listitem>If [2] and [4] are different, evaluate to true. Otherwise, evaluate to false.</listitem>
				</orderedlist>
			</section>
			
			<section xml:id="node.xnor">
				<title>xnor</title>
				
				<para>Evaluates to true if the child expressions evaluate to the same value.</para>
				
				<simplelist role="layout">
					<member>expression first</member>
					<member>expression second</member>
				</simplelist>
				
				<orderedlist role="exec">
					<listitem>Evaluate the first [expression] node.</listitem>
					<listitem>Downcast [1] to Bool.</listitem>
					<listitem>Evaluate the second [expression] node.</listitem>
					<listitem>Downcast [3] to Bool.</listitem>
					<listitem>If [2] and [4] are the same, evaluate to true. Otherwise, evaluate to false.</listitem>
				</orderedlist>
			</section>
			
			<programlisting>
true and false
true xnor false
			</programlisting>
			
			<programlisting>
(and true false)
(xnor true false)
			</programlisting>
		</section>
		
		<section xml:id="node.breed">
			<title>breed</title>
			
			<para>Creates a new object ("offspring") that encodes some or all of the information from the parent, and exposes that information through the specified interface. If an interface is not specified, the new object has same type as the parent, and should encode most or all of the information from the parent. If an interface is specified, the new object may be an exact copy of the parent object, or it may be of a completetly different form that encodes very little information from the parent object.</para>
			
			<para>This node can be used to copy a value, or to convert a value into a different type.</para>
			
			<simplelist role="layout">
				<member>expression parent</member>
				<member>? expression interface</member>
			</simplelist>
			
			<orderedlist role="exec">
				<listitem>Execute [parent] and let parentValue be the product.</listitem>
				<listitem>Execute [interface] and let faceValue be the product. If [interface] is not given, let faceValue be the active interface of parentValue.</listitem>
				<listitem>Find parentValue's breeder that produces values with faceValue as the active interface. If such a breeder is not found, throw an error.</listitem>
				<listitem>Activate the found breeder.</listitem>
				<listitem>Produce the new value produced by the breeder.</listitem>
			</orderedlist>
			
			<programlisting>
decl Int num1 = 987
decl Int num2 = copy(num)
decl Rat num3 = (num to Rat)
			</programlisting>
			
			<programlisting>
(decl Int num1 987)
(decl Int num2 (copy num))
(decl Rat num3 (breed num Rat))
			</programlisting>
		</section>
		
		<section xml:id="node.caller">
			<title>caller</title>
			
			<simplelist role="layout">
				<member>? expression interface</member>
				<member>identifier method name</member>
			</simplelist>
			
			<para>Creates a function that, when passed the type specified by [interface], calls the method named [method name] on the first argument with the rest of the arguments sent to it. It's purpose is to help with functional programming.</para>
			
			<programlisting>
interface Foo {
	func doStuff(Int, Int) Rat
}

decl Foo foo = getFoo()
decl func(Foo,Int,Int)Rat doStuffer = Foo::doStuff
println doStuffer(foo,3,7)

decl doStuffer2 = dyn::doStuff
println doStuffer2(foo,3,7)

//below all equilavent:
println Foo::doStuff(foo,3,7)
println dyn::doStuff(foo,3,7)
println foo.doStuff(3,7)
			</programlisting>
			
			<programlisting>
(decl Foo foo
	(getFoo))
(decl auto doStuffer
	(caller Foo doStuff))
(println (doStuffer foo 3 7))

(decl const doStuffer2
	(caller dyn doStuff))
(println (doStuffer2 foo 3 7))
			</programlisting>
		</section>
		
		<section xml:id="node.object">
			<title>object</title>
			
			<simplelist role="layout">
				<member>+ worker</member>
			</simplelist>
		</section>
		
		<section xml:id="node.dictionary">
			<title>dictionary</title>
			
			<simplelist role="layout">
				<member>expression key type</member>
				<member>expression value type</member>
				<member>* dictionary-entry</member>
			</simplelist>
			
			<section xml:id="node.dictionary-entry">
				<title>dictionary-entry</title>
				
				<simplelist role="layout">
					<member>expression key</member>
					<member>expression value</member>
				</simplelist>
			</section>
			
			<programlisting>
decl ages = dict (String, Int) {
	"Saray" : 12,
	"John" : 70,
	"Mike" : 23
}

for pair name, age in ages
	println name " " age
			</programlisting>
			
			<programlisting>
(decl const ages
	(dict String Int
		(("Saray" 12) ("John" 70) ("Mike" 23))))

(forpair name age ages
	(println name " " age))
			</programlisting>
		</section>
		
		<section xml:id="node.enum">
			<title>enum</title>
			
			<para>An enum is similar to an immutable dict.</para>
			
			<simplelist role="layout">
				<member>expression type</member>
				<member>+ enum-entry</member>
			</simplelist>
			
			<para role="process">If [type] is not given, no enum entries can have a value. If [type] is given, all enum entries must have a value. Note that every enum entry has have a unique value. (XXX include restriction in execution instructions)</para>
			
			<section xml:id="node.enum-entry">
				<title>enum-entry</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>? expression value</member>
				</simplelist>
			</section>
			
			<para>If [type] is given:</para>
			<orderedlist role="exec">
				<listitem>Let EntryFace be a new interface that inherits from EnumDictEntry&lt;T> where T is specified by [type].</listitem>
				<listitem>For every [enum-entry], create a value with EntryFace as the active interface, where the "value" and "name" properties are those specified by the [enum-entry].</listitem>
				<listitem>Let ListFace be a new interface. For every [enum-entry], add a readonly property to ListFace with the type of EntryFace and a name specified by the [enum-entry].</listitem>
				<listitem>Let EnumFace be a new interface that inherits from Interface, EnumDict&lt;T, U>, and ListFace, where T is EntryFace and U is specified by [type].</listitem>
				<listitem>Let EnumInstance be a value with EnumFace as the active interface such that:
					<simplelist>
						<member>the value given from getting a property of ListFace is the value created in step 2 that is associated with the same [enum-entry] as the property</member>
						<member>the Interface implementation is EntryFace, i.e. EnumInstance cast to Interface is EnumFace</member>
					</simplelist>
				</listitem>
				<listitem>Produce EnumInstance.</listitem>
			</orderedlist>
			
			<para>If [type] is not given:</para>
			<orderedlist role="exec">
				<listitem>Let EntryFace be a new interface that inherits from EnumEntry.</listitem>
				<listitem>For every [enum-entry], create a value with EntryFace as the active interface, where the "name" property is that specified by the [enum-entry].</listitem>
				<listitem>Let ListFace be a new interface. For every [enum-entry], add a readonly property to ListFace with the type of EntryFace and a name specified by the [enum-entry].</listitem>
				<listitem>Let EnumFace be a new interface that inherits from Interface, Enum&lt;T>, and ListFace, where T is EntryFace.</listitem>
				<listitem>Let EnumInstance be a value with EnumFace as the active interface such that:
					<simplelist>
						<member>the value given from getting a property of ListFace is the value created in step 2 that is associated with the same [enum-entry] as the property</member>
						<member>the Interface implementation is EntryFace, i.e. EnumInstance cast to Interface is EnumFace</member>
					</simplelist>
				</listitem>
				<listitem>Produce EnumInstance.</listitem>
			</orderedlist>
			
			<para>Note that the sections specifying Enum, EnumDict, EnumEntry, and EnumDictEntry have additional requirements on the behavior of instances of these interfaces.</para>
			
			<screen>
<![CDATA[
enum Animal {
	dog, cat, fish, parrot, ferret, gerbil, hamster
}

interface EntryFace
	inherit EnumEntry

interface ListFace
	get EntryFace dog
	get EntryFace cat
	get EntryFace fish
	get EntryFace parrot
	get EntryFace ferret
	get EntryFace gerbil
	get EntryFace hamster

interface EnumFace
	inherit Interface
	inherit Enum<EntryFace>
	inherit EnumList

Animal a = Animal.dog
Animal b = Animal.fromName("cat")
println Animal.size //assuming size is specified by Collection<T>

for animal in Animal
	println animal.name

activeInterface(Animal) == Interface + Enum<EntryFace> + EnumList
(Animal as Interface) == EntryFace
]]>
			</screen>
			
			<programlisting>
(enum Animal
	(dog cat fish parrot ferret gerbil hamster)

(for animal Animal
	(println animal.name))
			</programlisting>
		</section>
		
		<section xml:id="node.extract-member">
			<title>extract-member</title>
			
			<simplelist role="layout">
				<member>expression source</member>
				<member>identifier member name</member>
			</simplelist>
			
			<para>Retrieves the a method or the value of a property from the value specified by [source]. If the active interface of the value specified by [source] does not have a property or method with the specified name, throw an exception.</para>
			
			<programlisting>
println( alpha.beta )
alpha.doStuff()
			</programlisting>
			
			<programlisting>
(println alpha.beta)
(alpha.doStuff)
			</programlisting>
		</section>

		<section xml:id="node.function">
			<title>function</title>
			
			<simplelist role="layout">
				<member>* parameter-impl</member>
				<member>expression return type</member>
				<member>expression body</member>
			</simplelist>

			<para role="allowance">The [body] node adds a RETURN allowance and removes REMIT and YIELD allowances.</para>
			
			<para>If [return info] is not present, the function does not return anything, meaning it does not produce a value when called.</para>
			
			<para>When this node is executed, it produces a value with a function interface as the active interface. Only the [parameter] node and [return info]'s [interface] nodes are executed at this time. When the resultant value is called, the [body] node is executed in the scope of this function node.</para>
			
			<programlisting>
func square = { n | n * n }

println( square(3) )
=> 9
			</programlisting>
			
			<programlisting>
(decl const square
	(function (a) void
		(* a a)))

(println (square 2))
			</programlisting>
			
			<programlisting>
decl square = {a|a*a}
println( square(2) )
			</programlisting>
			
			<programlisting>
println( {a|a*a} 2 )
			</programlisting>
		</section>
		
		<section xml:id="node.function-interface">
			<title>function-interface</title>
			
			<simplelist role="layout">
				<member>? expression template-argument-count</member>
				<member>* parameter-info</member>
				<member>expression return type</member>
			</simplelist>
			
			<programlisting>
println( func(Int,Int)Rat )
			</programlisting>
			
			<programlisting>
(println (funcface (Int Int) Rat))
			</programlisting>
		</section>
		
		<section xml:id="node.generator">
			<title>generator</title>

			<para>Produces a value that implements an instantiation of the Generator generic interface.</para>
			
			<simplelist role="layout">
				<member>expression type</member>
				<member>expression body</member>
			</simplelist>
			
			<para role="allowance">The [body] adds a YIELD allowance and removes REMIT and RETURN allowances.</para>
			
			<para>If [type] is not given, the generator does not produce. (The generator could still be useful for producing side effects.)</para>
			
			<programlisting>
decl foo = generator {
	decl Int i = 2
	while i lt 5 {
		yield i
		i++
	}
}

for i in foo {
	print i " "
}

prints: '2 3 4 '

interface of foo == Generator&lt;Int>
			</programlisting>
			
			<programlisting>
(decl const foo
	(generator
		(decl Int i 2)
		(while (lt i 5)
			(compound
				(yield i)
				(++ i)))))

(forin i foo
	(print i " "))
			</programlisting>

			<programlisting>
decl foo = func(Int a, Int b) Generator&lt;Int> {
	return generator {
		decl Int i = a
		while i lt b {
			yield i
			i++
		}
	}
}

for i in foo(2, 5) {
	print i " "
}

prints: '2 3 4 '
			</programlisting>
			
			<programlisting>
decl foo = genfunc(Int a, Int b) Int {
	decl Int i = a
	while i &lt; b {
		yield i
		i++
	}
}

for i in foo(2, 5) {
	print i " "
}

prints: '2 3 4 '
			</programlisting>
			
			<programlisting>
decl foo = [2*x for x in L if x^2 > 3]
decl foo = [x in L if x^2 > 3]
decl foo = [x in L]
for o in [2*x for x in L if x^2 > 3] {
	println o
}

//convert to Array
Array&lt;Int>([2*x for x in L if x^2 > 3])

//insert into existing collection
collection.insert([2*x for x in L if x^2 > 3])
			</programlisting>
		</section>

		<section xml:id="node.generic-function">
			<title>generic-function</title>
			
			<simplelist role="layout">
				<member>+ parameter-info parameter</member>
				<member>function</member>
			</simplelist>
			
			<para role="process">The direction of the [parameter-info] must be "in".</para>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the function node.</para>
			
			<programlisting>
func larger&lt;T>(T a, T b) T {
	if a lt b
		return b
	return a
}

println larger(2, 7) //prints "7"
			</programlisting>
			
			<programlisting>
(declfirst auto larger
	(genericfunction (T) ((T a) (T b)) T
		(if (lt a b)
			(return b))
		(return a)))

(println (larger 2 7))
			</programlisting>
		</section>
		
		<section xml:id="node.generic-interface">
			<title>generic-interface</title>
			
			<simplelist role="layout">
				<member>+ parameter-info parameter</member>
				<member>interface</member>
			</simplelist>
			
			<para role="process">The direction of the [parameter-info] must be "in".</para>
			
			<para>Evaluates to a value with an active interface that inherits from GenericClass and one or more function interfaces. When called, the value returns the value returned from evaluating the interface node.</para>
			
			<programlisting>
interface List&lt;T> {
	func addFront(T)
	func addBack(T)
	func removeFront() T
	func removeBack() T
}

decl List&lt;Int> list = getNumbers()
list.addFront(2)
list.addBack(3)
list.addFront(1)
println list.removeFront() //prints "1"
println list.removeBack() //prints "3"
			</programlisting>
			
			<programlisting>
(declfirst auto List
	(genericinterface (T)
		(func addFront (T) void)
		(func addBack (T) void)
		(func removeFront () T)
		(func removeBack () T)))

(decl List&lt;Int> list
	(getNumbers))
(list.addFront 2)
(list.addBack 3)
(list.addFront 1)
(println (list.removeFront))
(println (list.removeBack))
			</programlisting>
		</section>
		
		<section xml:id="node.instantiate-generic">
			<title>instantiate-generic</title>
			
			<para role="xxx">Need to decide how to include type information. Type value, or type node? Write down and compare pros and cons. (Some related info in "type occurrence.txt")</para>
			
			<simplelist role="layout">
				<member>expression generic</member>
				<member>+ argument</member>
			</simplelist>
			
			<programlisting>
decl List&lt;Int> numbers
			</programlisting>
			
			<programlisting>
(decl List&lt;Int> numbers)
			</programlisting>
		</section>
		
		<section xml:id="node.integer">
			<title>integer</title>
			
			<para>Base node. Evaluates to an object reference with BigInt as the active interface. The object may implement other interfaces if they do not conflict with the BigInt interface. Must not implement the LimInt interface.</para>
			
			<programlisting>
println( 789 )
			</programlisting>
			
			<programlisting>
(println 789)
			</programlisting>
		</section>
		
		<section xml:id="node.interface">
			<title>interface</title>
			
			<simplelist role="layout">
				<member>* expression inheritee</member>
				<member>* statused-member member</member>
			</simplelist>
			
			<section xml:id="node.statused-member">
				<title>statused-member</title>
				
				<simplelist role="layout">
					<member>member-status</member>
					<member>interface-member member</member>
				</simplelist>
			</section>
			
			<section xml:id="node.member-status">
				<title>member-status</title>
			
				<para>Terminal node. Specifies one of:</para>
				
				<simplelist role="enum">
					<member>new</member>
					<member>normal</member>
					<member>deprecated</member>
				</simplelist>
			</section>
			
			<section xml:id="node.breeder">
				<title>breeder</title>
				
				<simplelist role="layout">
					<member>? expression type</member>
				</simplelist>
				
				<para>Specifies that implementations of that interface can be converted into the specified type. Or, if [interface] isn't given, that the value can be copied.</para>
				
				<para role="xxx">What is rationale for not just having an "* expression breedable interface" layout entry of interface nodes?</para>
			</section>
			
			<section xml:id="node.callee">
				<title>callee</title>
				
				<simplelist role="layout">
					<member>* parameter-info</member>
					<member>expression return type</member>
				</simplelist>
			</section>
			
			<section xml:id="node.method">
				<title>method</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>expression interface</member>
				</simplelist>
			</section>
			
			<section xml:id="node.property">
				<title>property</title>
				
				<simplelist role="layout">
					<member>identifier name</member>
					<member>boolean writable</member>
					<member>expression type</member>
				</simplelist>
			</section>
		</section>
		
		<section xml:id="node.rational">
			<title>rational</title>
			
			<para>Base node. Evaluates to an object with BigRat as the active interface. The object may implement other interfaces if they do not conflict with the BigRat interface. Must not implement the LimRat interface.</para>
			
			<programlisting>
println( 123.456 )
			</programlisting>
			
			<programlisting>
(println 123.456)
			</programlisting>
		</section>

		<section xml:id="node.string">
			<title>string</title>
			
			<para>string nodes consist of text</para>
			
			<para>strings are expressions</para>
			
			<para>Base node. Evaluates to an object with interface string as the active interface. The object may implement other interfaces if they do not conflict with the string interface.</para>
			
			<programlisting>
println( "this is a string" )
			</programlisting>
			
			<programlisting>
(println "this is a string")
			</programlisting>
		</section>
	</section>
</chapter>