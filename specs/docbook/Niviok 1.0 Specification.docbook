<!--

preprocessor features:
@@foo becomes <link linkend="node.foo">foo</link>
##foo becomes <link linkend="def.foo">foo</link>
$$CURRENTDATE becomes the current date in YYYY-MM-DD format
$$NODECOUNT becames the node count

-->

<book xmlns="http://docbook.org/ns/docbook" version="5.0"
xmlns:xi="http://www.w3.org/2003/XInclude">
	
	<title>Niviok 1.0 Specification</title>
	<subtitle>Edition 1 Draft $$CURRENTDATE</subtitle>
	
	<info>
		<copyright>
			<year>2008</year>
			<holder>James Justin Harrell</holder>
		</copyright>
		
		<legalnotice>Permission is granted to use, copy, display, modify, sell, and distribute this document. This document is provided "as is" without warranty of any kind. In no event shall anyone be liable for any damages or other liability arising from use of this document.</legalnotice>
	</info>
	
	<chapter xml:id="Overview">
		<title>Overview</title>
		
		<para>This document is a draft for the first edition of the specification describing the 1.0 version of Niviok. It can be represented as "Niviok 1.0 Edition 1 Draft $$CURRENTDATE".</para>
	
		<para>This document is a draft of the first edition of the specification describing the 1.0 version of Niviok.</para>
		
		<para>Niviok is an abstract programming language. This document defines several node types which are used to represent Niviok source code. How Niviok nodes are represented is outside the scope of this standard. While syntax and semantics are not completetly separate, Niviok does contain much less syntax-influenced semantics than most programming languages.</para>
		
		<para>Nodes that can be executed are statements or expressions. Statements are greatly restricted in where they can appear, while expressions are more relaxed and can be interchanged for on another. An expression may produce a value when executed.</para>

		<para>Niviok contains some dynamic aspects, but in several ways is very static. For example, the tree of ##scopes and ##scidentres can be entirely known before runtime; scidentres cannot be declared conditionally like in highly dynamic languages such as JavaScript.</para>
	</chapter>
	
	<chapter xml:id="versioning">
		<title>Versioning</title>
		
		<para>Each version of Niviok is described by a specification with one or more editions.</para>
		
		<section xml:id="niviok-version">
			<title>Niviok version</title>
		
			<para>Each version of Niviok is identified by a major version number and a minor version number, both integers. Each new version that is mostly backwards compatible with the previous version increments the minor version number by one. Each new version that is significantly backwards incompatible increments the major version number by one and resets the minor version number to 0.</para>
		</section>
		
		<section xml:id="specification-version">
			<title>Specification version</title>
			
			<para>Each version of Niviok is described by a specification that can have multiple editions. Each edition of a specification describing a particular version of Niviok is identified by an integer which starts at one and is incremented by one for each new edition.</para>
			
			<para>A document that is intended to become an edition is a draft. A finalized edition is no longer in the draft stage. Each draft is identified by the date on which it was published.</para>
			
			<para>Newer editions should serve only to better describe a particular version of Niviok, not to modify that version of Niviok. Newer editions should not attempt to correct problems with Niviok, only errors in describing that version of Niviok.</para>
		</section>
		
		<section xml:id="version-notation">
			<title>Version notation</title>
			
			<para>A version of Niviok may be represented as "Niviok X.Y" where X is the major version number and Y is the minor version number.</para>
			
			<para>A finalized specification for Niviok may be represented as "Niviok X.Y Edition A" where A is the edition number.</para>
			
			<para>A draft of a specification edition may be represented as "Niviok X.Y Edition A Draft YYYY-MM-DD" where YYYY-MM-DD is the date on which the draft was published.</para>
			
			<para>Example: Niviok 2.3 Edition 4 Draft 2008-01-20</para>
		</section>
	</chapter>
	
	<chapter xml:id="Glossary">
		<title>Glossary</title>

		<glosslist>
			<glossentry>
				<glossterm>Niviok agent</glossterm>
				<glossterm>agent</glossterm>
				<glossdef>An implementation of the Niviok language. Could be a source interpreter, a bytecode intepreter, a bytecode compiler, a machine code compiler, etc. If it recognizes the semantics of what it's running, and follows the rules of this document, it could be called a Niviok agent. Each agent should define what representations it supports.</glossdef>
			</glossentry>
			
			<glossentry>
				<glossterm>object</glossterm>
				<glossdef>A collection of data that holds state. Created by a class. Only the class that created it can access an object's state. Values are associated with objects.</glossdef>
			</glossentry>
			
			<glossentry>
				<glossterm>scidentre</glossterm>
				<glossdef>bound to one or more values. An identifier in a certain scope is associated with an identikey. In other programming languages, the terms "variable" or "constant" may refer to a similar concept. (Previously called "identikey" by this draft. Transition has only barely begun.)</glossdef>
			</glossentry>
		
			<glossentry>
				<glossterm>value</glossterm>
				<glossdef>Associated with an object and an interface implementation, except for the null value, which is associated with nothing or associated with an interface</glossdef>
			</glossentry>
			
			<glossentry>
				<glossterm>active interface implementation</glossterm>
				<glossdef>the interface implementation a value is directly associated with</glossdef>
			</glossentry>
			
			<glossentry>
				<glossterm>active interface</glossterm>
				<glossdef>the interface that the active interface implementation is associated with</glossdef>
			</glossentry>
			
			<glossentry>
				<glossterm>global scope</glossterm>
				<glossdef>the scope of the bundle node. a bundle node has one and only one scope each time the bundle is executed</glossdef>
			</glossentry>
			
			<glossentry>
				<glossterm>element</glossterm>
				<glossdef>A value stored in a container.</glossdef>
			</glossentry>
			
			<glossentry>
				<glossterm>member</glossterm>
				<glossdef>A callee, property, method, or conversion of an interface.</glossdef>
			</glossentry>
			
			<glossentry>
				<glossterm>method</glossterm>
				<glossdef>A member function of an interface.</glossdef>
			</glossentry>
			
			<glossentry>
				<glossterm>scope</glossterm>
				<glossdef>"Environment" in some languages.</glossdef>
			</glossentry>
		</glosslist>
	</chapter>
	
	<chapter xml:id="executing-nodes">
		<title>Executing nodes</title>
		
		<para>No node besides the bundle node can be executed directly. All other nodes must only be executed when required by the execution instructions of another node, or as required to call a callee/method (such as when calling a value created by a function node). ((XXX clarify execution through calling)) Because values can only be created, directly or indirectly, by executing the bundle node, and because all node execution instructions only every instruct to execute child nodes, all node execution occurs as a result of executing the root bundle node.  All Niviok nodes that are executed in any way must be part of a complete Niviok node tree, which means having an bundle node as the root node.</para>
		
		<para>Note: A bundle might not have a main function. It might just expose its members, such as for scripting or a library.</para>
		
		<para>interpreted:</para>
		<orderedlist>
			<listitem>a bundle representation is parsed to extract a tree of Niviok nodes</listitem>
			<listitem>libraries are loaded and linked</listitem>
			<listitem>tree is processed</listitem>
			<listitem>optimization</listitem>
			<listitem>execution of the planes' declaration-first nodes</listitem>
			<listitem>execution of the function bound to "main" attached to the bundle node's scope, which may return an exit status</listitem>
			<listitem>returning exit status, or 0 if none specified</listitem>
		</orderedlist>
		
		<para>runtime compilation:</para>
		<orderedlist>
			<listitem>a bundle representation is parsed to extract a tree of Niviok nodes</listitem>
			<listitem>libraries are loaded and linked</listitem>
			<listitem>tree is processed</listitem>
			<listitem>optimization</listitem>
			<listitem>tree translated to bytecode and/or machine code</listitem>
			<listitem>execution of bytecode and/or machine code, which produces an exit status</listitem>
		</orderedlist>
		
		<para>beforehand compilation:</para>
		<orderedlist>
			<listitem>a bundle representation is parsed to extract a tree of Niviok nodes</listitem>
			<listitem>static libaries are loaded</listitem>
			<listitem>information about shared libraries is obtained</listitem>
			<listitem>tree is processed</listitem>
			<listitem>optimization</listitem>
			<listitem>tree translated to bytecode and/or machine code and stored</listitem>
			<listitem>code is loaded</listitem>
			<listitem>shared libraries are loaded and linked</listitem>
			<listitem>processing</listitem>
			<listitem>execution of bytecode and/or machine code, which produces an exit status</listitem>
		</orderedlist>
		
		<para>This spec should define how to:</para>
		<simplelist>
			<member>process a bundle (a valid tree of Niviok nodes with a bundle node as the root node)</member>
			<member>execute nodes of a processed tree</member>
			<member>execute a bundle</member>
		</simplelist>
		
		<para>Implementations that aren't interpreters should produce equivalent behavior when being executed.</para>
	</chapter>
	
	<chapter xml:id="overview-part-2">
		<title>Overview part 2</title>
		
		<para>Niviok is represented by a node tree. The way this node tree is represented is not covered in this specification. This specification explains what kind of node tree a representation can represent, the meaning of the nodes in a Niviok node tree, and how to execute the node tree.</para>
		
		<para>This node tree has scopes attached at various places. These scopes contain identikeys that are bound to namespaces and values.</para>
		
		<section xml:id="identifiers">
			<title>Identifiers</title>
			
			<glosslist>
				<glossentry>
					<glossterm>identifier</glossterm>
					<glossdef>sequence of words, with an optional ending exclamation mark or question mark</glossdef>
				</glossentry>
				<glossentry>
					<glossterm>word</glossterm>
					<glossdef>sequence of Unicode characters, where each Unicode character is a letter or an Arabic numerical digit</glossdef>
				</glossentry>
				<glossentry>
					<glossterm>letter</glossterm>
					<glossdef>member of an alphabet, abjad, abugida, syllabary, or logogram</glossdef>
				</glossentry>
			</glosslist>
		
			<para>Because identifiers are defined in terms of Unicode characters, letters are case sensitive wherever Unicode defines an uppercase and lowercase character for the same letter. Control characters, surrogates, whitespace characters, punctuation marks, and combining characters are not letters. This specification does not specify all characters that do or do not qualify as letters, but it does list some characters that must be recognized a certain way.</para>
			
			<para>Arabic numerical digits: (complete)</para>
			<screen>0 1 2 3 4 5 6 7 8 9</screen>
			
			<para>letters: (incomplete)</para>
			<screen>
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
			</screen>
			
			<para>not letters: (incomplete)</para>
			<screen>0 1 2 3 4 5 6 7 8 9 ` ~ ! @ # $ % ^ &amp; * ( ) { } [ ] / ? = + \ | - _ ' " , &lt; > .</screen>
			
			<para>Examples of how identifiers might be represented:</para>
			<programlisting>
do some stuff
XML_HTTP_request
we\are\finished?
mutate`this`thing!
			</programlisting>
		</section>
			
		<section xml:id="scidentres">
			<title>Scidentres</title>
			
			<para role="xxx">Need to replace "identikey" with "scidentre".</para>
			
			<para>An identikey is associated with a scope and an identifier. It may be associated with a nullable-type, a worker, multiple workers, and/or a namespace. Some identikeys can be mutated.</para>

			<para>Every scope is assocciated with zero or more identikeys. Identikeys associated with the same scope must each be associated with a different identifier.</para>

			<para>When an identifier node is executed, every identikey in the scope the identifier node resides in is checked to see if the identikey is associated with an equivalent identifier. If it is, the value produce by executing the identifier node is obtained from the identikey. The identifier node execution process moves up through the scope tree (not to be confused with the scope formula tree) looking for an identikey associated with an equivalent identifier.</para>
			
			<glosslist>
				<glossentry>
					<glossterm>namespace</glossterm>
					<glossdef>associated with a namespace when created. immutable. multiple declarations of the same scidentre can be made in the same scope.</glossdef>
				</glossentry>
				
				<glossentry>
					<glossterm>constant</glossterm>
					<glossdef>associated with a worker when created. immutable.</glossdef>
				</glossentry>
				
				<glossentry>
					<glossterm>overload</glossterm>
					<glossdef>associated with a worker when created. immutable. multiple declarations of the same scidentre can be made in the same scope.</glossdef>
				</glossentry>
				
				<glossentry>
					<glossterm>variable</glossterm>
					<glossdef>can be mutated to point to different workers. only workers that match the type can be assigned to the identikey (note that the type could be e.g. any or Nullable&lt;any>)</glossdef>
				</glossentry>
			</glosslist>
			
			<para>A function identikey can be bound to multiple functions (objects that implement a function interface; xxx link) at the same time. A function identikey can never be bound to multiple functions with the same interface.</para>
			
			<para>If a value has multiple callees, the active interface is not a function interface, and thus it cannot be bound to a function identikey. The value must be cast to each function interface, and each resulting value bound individually to the function identikey.</para>

			<programlisting>
var foo 123
foo = "bar"
foo = getSomething()

var Int num
num = 2
num = 89

var ?auto bar getSomething()
bar = getSomethingWithSameTypeAsBefore()

interface Foo
	func fooMeth()

interface Bar
	func barMeth()

var obj getFoo()
obj.fooMeth()
obj = getBar()
obj.barMeth()

var foo
foo = getBar()
foo.barProp
foo = 3
foo.minus(5)
foo = "test"
foo.toUpperCase()
foo = CMyClass()
foo.myClassProp
foo = cast&lt;BazInterface>(alpha)
foo.bazProp
foo = (alpha as MazInterface)
foo.mazProp
foo = alpha as GazInterface
foo.gazProp
(BazInterface foo).bazProp
(MazInterface foo).mazProp
			</programlisting>
		</section>
		
		<section xml:id="builtin-numbers">
			<title>Built-in numbers</title>
			
			<para>The built-in implementations of the Int and Rat interfaces must be able to handle numbers of an arbitrary complexity. Built-in libraries should handle numbers of an arbitrary complexity. Niviok implementations must not ever introduce rounding errors or otherwise introduce numerical errors without being explicitly told that such errors may occur.</para>
			
			<para>For example, pow(10, pow(10,100)), must correctly return an Int object reference that accurately represents a googolplex, and must be able to perform operations on this number with perfect accuracy.</para>
			
			<para>Implementations may throw errors when they are unable to perfectly represent a number. Implementations must not silently introduce errors. This is the only alternative to perfectly representing the number.</para>
			
			<para>For example, if the implementation was directed by user code to print a googolplex without using scientific notation (i.e. a "1" followed by a googol "0"), the implementation may throw an error specifying that it is unable to create such a representation.</para>
		</section>
	</chapter>
	
	<chapter xml:id="values">
		<title>Values</title>
		
		<para>Values are associated with an object and an interface implementation.</para>
		
		<para>Objects hold which is used by the interface implementation. This state can only be accessed or modified by interface implementations that they object was intented to hold state for. Objects have an ID that never changes. Each interface implementation consists of the implementation of the members of that interface.</para>
		
		<para>This specification may speak of values implementing interfaces. In these cases, what is actually refered to is whether the interface implementation the value is associtiated with is in a tree where one of the interface implementations is an implementation of that interface. The value itself does not actually implement any interfaces.</para>
		
		<para>Interface implementations form a tree. Multiple interface implementations in the same tree can implement the same iterface. When a value has an active interface that has multiple implementations, the interface implementation that is used when the value is accessed is the interface implementation that the vaule is associated with.</para>
	</chapter>
	
	<chapter xml:id="functions">
		<title>Functions</title>
		
		<para>Functions are just values with an active interface that defines callees. Functions can be "called". Functions can have a return interface and parameters. Parameters have an interface and an optional default value.</para>
		
		<section xml:id="function-interfaces">
			<title>Function interfaces</title>
			
			<para>XXX this needs a lot of work</para>
			
			<para>Function interfaces implement FunctionInterface instead of Interface and inherit from Function. FunctionInterface simply inherits from Interface and defines no new members. Function interfaces declare a callee and an "apply" method that hides the members of the Function interface.</para>
			
			<screen>
interface Function
	callee(dyn[] params) dyn
	func apply(dyn[] arguments) dyn //actually takes an array
	func bind(dyn[] params) dyn
	func call(dyn[] params) dyn
	func curry(dyn[] params) dyn
	get List&gt;Parameter> parameters
	get Bool return?
	get nullable Interface returnInterface

all function interfaces
	inherit Function
	callee(...) ...
	func apply(dyn[] params) ...
	func call(...) ...

For example, for func(Int a, Rat b, String c) Bool :

interface (func(Int a, Rat b, String c) Bool)
	inherit Function
	callee(Int a, Rat b, String C) Bool
	func apply(dyn[] params) Bool
	func call(Int a, Rat b, String C) Bool
	get parameters returns List {
		Parameter { "a", Int },
		Parameter { "b", Rat },
		Parameter { "c", String } }
	get return? returns true
	get returnInterface returns Bool
			</screen>
		</section>
	</chapter>
	
	<chapter xml:id="interfaces">
		<title>Interfaces</title>
		
		<para>Interfaces define a means of interacting with an object's state. Interfaces declare that implementations will be able to provide object references with specified interfaces when asked for the object reference bound to identifiers specified by the interface and/or that implementations will be able to bind object references with specified interfaces to specified identifiers. Methods are a type of property. Methods are callable and cannot be assigned, only retrieved.</para>
		
		<para>Interfaces cannot inherit in a circle. (E.g., interface A cannot inherit interface B if interface B inherits interface A.) Interfaces cannot inherit from themselves. (However, interfaces created by instantiating values created from generic-interface nodes should not throw errors if the interface tries to inherit itself. Instead, the error should be silently ignored. This is to allow generic interfaces to inherit other forms of themselves.) Interfaces that do not explicitly inherit any interfaces, should implicitly inherit Object. Therefore, all interfaces inherit from Object, either directly or indirectly.</para>
		
		<para>Interfaces can declare that properties are "get only", "set only", or "get and set".</para>
		
		<para>Interface member functions can have default values. This differs from a class with abstract members because interfaces cannot have any private members, so these default functions can not store or extract state in the object. These functions are only intended to call other member functions or throw errors.</para>
		
		<para>There are two kinds of interfaces: object interfaces (Interface) and function interfaces (FuncInterface). Object interfaces define properties and methods. Function interfaces define parameters and a return type. An interface cannot be a function interface and an object interface, though an object interface can have call methods that allow implementations to be used like functions. A function interface can be wrapped to an object interface with a single call method.</para>
		
		<para>Interface callees and members may refer to the interface. This is useful when an interface wants to define a method that returns an object reference with itself as the active interface. For generic interfaces, it is also possible to refer to the generic template.</para>
		
		<programlisting>
<![CDATA[
interface Int
	func power(Self) Self
	r Self timesTwo

//some representations may be able to translate the below example as well

iterface Int
	func power(Int) Int
	r Int timesTwo

//note that the interface node will have no knowledge of the identifier it is being bound to

//generics:

interface<T> Print
	callee(T) Self

Print<Int> print = getIntPrinter()
print(3)(5)(8) //the print callee returns a Print<Int> object reference

//refering to Generic interface

interface<T> Print
	callee(T) GenericSelf

Print print = getGenericPrinter()
print <Int>(3) <String>("foo") <Rat>(1.23)

//some representations may also allow:
print 3 "foo" 1.23
]]>
		</programlisting>
		
		<section xml:id="interface-operations">
			<title>Adding and subtracting interfaces</title>
			
			<para>Interfaces can be added together to produce other interfaces. How this addition occurs depends on whether the operands were produce through addition, and the inherited interfaces of the operands.</para>
			
			<para>If an interface is "fromAddition", it was produced through addition and/or subtract. The <link linkend="ident.Interface">Interface interface</link> exposes this information as a property.</para>
			
			<para>Interfaces produced from addition don't define any members themeselves; they only inherit from other interfaces.</para>
			
			<para>No interface can inherit from an interface that is fromAddition. When a fromAddition interface is an operand of interface addition, the inheritees of the fromAddition interface are copied into the produced interface, but the produced interface does not inherit from the fromAddition operands.</para>
			
			<para>No interface that is fromAddition can inherit from a single interface. When subtracting from a fromAddition interface, and the produced interface would have otherwise only inherited from a single interface, the produced interface is actually that single interface that it would have inherited from.</para>
			
			<screen>
interface A
	fromAddition = false

interface B
	fromAddition = false

interface C
	fromAddition = true

interface D
	fromAddition = true

interface A+B
	inherit A
	inherit B

interface A+C
	inherit A
	C's inheritees (doesn't inherit from C)

interface A+D
	inherit A
	D's inheritees (doesn't inherit from D)

interface B+C
	inherit B
	C's inheritees (doesn't inherit from C)

interface B+D
	inherit B
	D's inheritees (doesn't inherit from D)

interface C+D
	C's inheritees (doesn't inherit from C)
	D's inheritees (doesn't inherit from D)

(A+B)-B must be A, not a fromAddition interface that inherits only from A.

consider this expression:
	(A+B+C)-(B+C)
if:
	* C is fromAddition
	* A and B are not fromAddition
	* C inherits from C1, C2, and C3
then the expresison is equal to:
	(A+B+C1+C2+C3)-(B+C1+C2+C3)
	(A+B+C1+C2+C3)-B-C1-C2-C3
	A
			</screen>

			<para>xxx ENSURE ORDER DOESN'T MATTER</para>
			
			<para>Addition with operands A and B:</para>
			<orderedlist>
				<listitem>Create an interface, PRODUCT, where fromAddition is true.</listitem>
				<listitem>If A is fromAddition, copy the inheritees of A to PRODUCT. If A is not fromAddition, add A as an inheritee to PRODUCT.</listitem>
				<listitem>If B is fromAddition, copy the inheritees of B to PRODUCT. If B is not fromAddition, add B as an inheritee to PRODUCT.</listitem>
				<listitem>If PRODUCT has only one inheritee, produce that inheritee. Otherwise, produce PRODUCT.</listitem>
			</orderedlist>
			
			<para>Note: An example of when PRODUCT would only have one inheritee from addition is when an interface that is not fromAddition is added to itself. i.e. A + A = A</para>
			
			<para>Subtraction with operands A and B:</para>
			<orderedlist>
				<listitem>If A is not fromAddition, throw an error.</listitem>
				<listitem>Copy A as PRODUCT. (i.e. Copy A. We'll refer to this copy as PRODUCT.)</listitem>
				<listitem>If B is fromAddition, remove every inheritee of B from the inheritees of PRODUCT. If any of the inheritees of B is not an inheritee of PRODUCT, throw an error.</listitem>
				<listitem>If B is not fromAddition, remove B from the inheritees of PRODUCT. If B is an inheritee of PRODUCT, throw an error.</listitem>
				<listitem>If PRODUCT has only one inheritee, produce that inheritee. If PRODUCT does not have any inheritees, throw an error. Otherwise, produce PRODUCT.</listitem>
			</orderedlist>
		</section>
	</chapter>

	<chapter xml:id="scopes">
		<title>Scopes</title>
		
		<para>Scopes consist of a collection of identikeys, and unless it is the scope of the bundle node, an association with a parent scope. Scopes form a hierarchy. When identifier nodes are executed, the current scope is searched for an identikey that is associated with that identifier. If one is not found, that scope's parent scope is searched, and so on, until a matching identikey is found. If such an identikey cannot be found, an error results.</para>
		
		<para>When execution enters a node that "has scope", before executing that node, all contained declare-first descendant nodes that do not have a closer "with scope" ancestor node, are handled according to <link linkend="handling-declare-first">this section</link>.</para> 
	</chapter>
	
	<chapter xml:id="handling-declare-first">
		<title>Handling declare-first nodes</title>
		
		<para role="xxx">Rename this section to something like "entering node that has scope" or "creating new scope"?</para>
		
		<para>This section specifies the actions that must take place when execution first reaches a node that "has scope".</para>
		
		<orderedlist role="exec">
			<listitem>Let scopeNode be the node that "has scope" that execution just reached, i.e., the node that lead to this process being performed.</listitem>
			<listitem>Let nodeList be an ordered list of all declare-first nodes that:
				<simplelist>
					<member>are descendants of scopeNode, and</member>
					<member>do not have an ancestor node that:
						<simplelist>
							<member>"has scope" or "has closure", and</member>
							<member>is a descendant of scopeNode</member>
						</simplelist>
					</member>
				</simplelist>
			</listitem>
			<listitem>Let listCount be the number of elements in nodeList.</listitem>
			<listitem>Let thisScope be a new scope.</listitem>
			<listitem>Add the identikeys specified by the nodes in nodeList to thisScope.</listitem>
			<listitem>Let currentNode be the first node in nodeList. If nodeList is empty, end this process and begin execution of scopeNode with thisScope as the associated scope.</listitem>
			<listitem>Begin executing the [value] member of currentNode.
				<simplelist>
					<member>If execution needs to evaluate an identikey created by this process, and the [value] member of the declare-first node associated with that identikey has not yet been evaluated and the product assigned to that identikey, pause the execution of this [value] member.</member>
					<member>If execution completes successfully, assign the product to the associated identikey, and remove currentNode from nodeList.</member>
				</simplelist>
			</listitem>
			<listitem>Set currentNode to the next node in nodeList and go to step 6. (If currentNode was removed, the next node would be the node that followed currentNode when currentNode was in the list.) If there is no next node, continue to the next step.</listitem>
			<listitem>If the number of elements in nodeList is equal to listCount, a cyclical dependency likely exists, where two or more expressions rely on the result of each other to execute. In this case, throw an error. If the number of elements in nodeList is not equal to listCount, set listCount to the number of elements in nodeList and go to step 5.</listitem>
		</orderedlist>
		
		<screen>
Example 1 of a cyclical dependency:

declfirst a = b + 2
declfirst b = a + 3

Example 2 of a cyclical dependency:

declfirst a = b + 2
declfirst b = c + 3
declfirst c = d + 4
declfirst d = e + 5
declfirst e = a + 6

Example 1 of a non-cyclical dependency:

declfirst a = b + 2
declfirst b = c + 3
declfirst c = d + 4
declfirst d = e + 5
declfirst e = 6

Example 2 of a non-cyclical dependency:

declfirst func foo = func() {
	bar()
}

declfirst func bar = func() {
	foo()
}
	</screen>
	
	<para>Concerning the last example: When one of these functions is called, infinite recursion occurs (negating intervention by the agent), but no such cycle is involved in just executing the function nodes. This is because the calls to foo and bar are not executed when the function nodes are executed.</para>
	</chapter>
	
	<chapter xml:id="nodes">
		<title>Nodes</title>
	
		<para>Niviok defines $$NODECOUNT nodes.</para>
		
		<para>Niviok code is represented by a tree of nodes. How this tree and its nodes are represented is outside the scope of this specification. Many means may exist of representing a Niviok tree.</para>

		<para>Nodes are either base nodes or tree nodes. Tree nodes only contain other nodes, and their entire meaning is derived from their child nodes. Base nodes do not contain any other child nodes, and must is some way encode their meaning themselves.</para>
		
		<para>When a node has multiple child nodes with equivalent meaning, the order of those child nodes is significant, so their order must be specified by some means. The order of nodes of different meaning in relation to each other is not significant, and must not have any observable side effects.</para>
		
		<para>The child nodes of tree nodes are sometimes executed in order, such as expressions in blocks and arguments in function calls. This means the order of the child nodes is sometimes significant and thus should always be preserved.</para>
			
		<para>How ordering is represented has no effect on the semantics (left-to-right, numbered, linked list, etc) as long as there is a specified order. Each representation should specify how nodes are ordered.</para>
		
		<para>Node type names are nouns or noun phrases. XXX find correct English terminology</para>
			
		<section xml:id="node-terminology">
			<title>Node terminology</title>
			
			<para>If a node can contain other nodes, it is a tree node. If a node is contained directly inside another node, the inner node is the child of the outer node, and the outer node is the parent of the inner node. If a node is contained inside another node, but not directly, the inner node is the descendant of the outer node, and the outer node is the ancestor of the inner node.</para>
			
			<para>Expressions can be executed. When executed, they may perform some kind of action; e.g. they can have side effects. Expressions may produce a value when executed.</para>
		</section>
		
		<section xml:id="tree-node-layout">
			<title>Tree node layout</title>
			
			<para>The number, type, and order of a tree nodes children is determined by the tree node's layout.</para>
		</section>
	
		<section xml:id="node-supertypes">
			<title>Node supertypes</title>
		
			<para>Where the layout for a tree node specifies that a child node is an expression, that child node can be any expression.</para>
		</section>
	</chapter>
	
	<xi:include href="Niviok%201.0%20Specification%20-%20Node%20types.docbook"/>
	
	<chapter xml:id="reserved-identikey-names">
		<title>Reserved identikey names</title>

		<para>No user-defined identikeys can be associated with these identifiers.</para>

		<simplelist>
			<member>global - Namespace identikey that refers to the scope associated with the bundle node. Defined in the global scope.</member>
			<member>std - Namespace identikey for the standard library. Defined in the global scope.</member>
			<member>true - Constant strict identikey bound to the Bool enum true member. Defined in the global scope.</member>
			<member>false - Constant strict identikey bound to the Bool enum false member. Defined in the global scope.</member>
			<member>outer - Namespace identikey that refers to the outer scope. Defined in all scopes except the global scope. Note that outer::outer may be valid, depending on which scope it appers in.</member>
			<member>inst - Namespace identikey that exposes private fields of objects created by the class node. Defined in child scopes of class nodes.</member>
			<member>std - The <link linkend="standard-library">Niviok standard library</link>. Defined in the global scope.</member>
		</simplelist>
		
		<para role="xxx">Other possibilites for the standard library: standard, system, language, and various capitalizations (Standard, System, Language) and abbreviations (std, stand, sys, lang).</para>
		
		<para role="xxx">Need to clarify somewhere (probably multiple places) that namespaces are not scopes, and that scidentres like global and std are not defined in those scopes. But note that this causes problems with e.g. outer:outer:outer. This hasn't been thought out enough yet.</para>
	</chapter>

	<xi:include href="Niviok%201.0%20Specification%20-%20Standard%20library.docbook"/>
	
	<chapter xml:id="warnings-list">
		<title>Warnings</title>
		
		<para>This is a list of warnings predefined by this specification. Agents should create other warnings whenever needed.</para>
		
		<table>
			<tbody>
				<tr>
					<th>name</th>
					<th>meaning</th>
				</tr>
				<tr>
					<td>always null</td>
					<td>A node that will never produce a value when executed is being used as if it will sometimes produce a value. This warning is produced by the node that attempts to make use of the output, such as an assignment node, and not the node that doesn't produce. A node that will never produce a value when executed is being used as if it will produce a value. Example: The result is being assigned to an identikey or passed as an argument. This applies to node types like @@call which can sometimes produce a value, if a particular instance can be determined to never produce a value. (XXX should this warning apply to using nodes like throw, break, or return as expressions?</td>
				</tr>
				<tr>
					<td>no effect</td>
					<td>The output of a node that does not have side effects is not being used. For example, a member of a @@compound that is an integer node and does not appear last. The integer node would have no effect.</td>
				</tr>
				<tr>
					<td>unreachable</td>
					<td>Code is unreachable. Execution will never reach a particular piece of code.</td>
				</tr>
			</tbody>
		</table>
	</chapter>

	<chapter xml:id="error-handling-processing">
		<title>Error handling during processing</title>
		
		<para>If an error is found during processing, and none of the already generated nodes have been executed, all generated nodes in the entire Niviok tree must not be used for purposes beyond explaining the source of errors. Construction of the Niviok node tree may continue after errors are found. The main() function must not be called, and the members should not be exposed as a library.</para>
			
		<para>If errors occur while generating the Niviok node tree, and execution has already begun, a warning should immediately be emitted describing the error. How this warning is emitted is undefined. Generation of the Niviok node tree may continue. When execution reaches the damaged section of the tree, an error should be thrown describing the error. If execution never reaches the damaged section of the tree, the error should have no effect.</para>
	</chapter>
	
	<chapter xml:id="rationales">
		<title>Rationales</title>
		
		<para>This chapter explains the decisions behind various choices made for Niviok.</para>
		
		<section xml:id="rationale.dynamic-static-typing">
			<title>Dynamic static typing</title>
			
			<para>Dynamic static typing refers to explicitly using and enforcing type information that isn't available until runtime. The type information isn't known until runtime, but after it's known, it's enforced and can't be changed.</para>
			
			<para>An example of this is loading an interface from a library and then using obtaining values with that interface through the library. The loaded interface can be used as the type for function parameters, free identifiers, etc. So although the interface wasn't known until runtime, one the information was known, it was enforced, and the values of that interface are only accessed by ensuring they are of that interface.</para>
			
			<para>Dynamic static typing can do nothing beforehand to ensure property/method access is correct, but it can ensure that various values are of the same type. For example, consider the case where an interface is loaded from a library and bound to an identifer. Then a free identifier is declared to be of that type, and a function is declared to accept a value of that type. An implementation will known that the free identifer and the function's parameter are of the same type, so the value bound to the free identifier can safely be passed to the function. This safety could not be ensured with fully dynamic typing.</para>
			
			<para>Dynamic static typing is not as safe as fully static typing, but interfaces cannot always be known before runtime, which is a requirement for fully static typing. Therefore, Niviok should provide something to give more type safety for the cases when interfaces cannot be known until runtime. Dynamic static typing is safer than fully dynamic typing.</para>
			
			<programlisting>
Interface Foo = lib['Foo']
Interface Bar = lib['Bar']
func()Foo getFoo = lib['getFoo']
func(Bar)Int doStuff = lib['doStuff']

Foo foo = getFoo() //static typing: known beforehand that types match
foo.somthing() //dynamic typing: don't know beforehand whether Foo declares a 'somthing' method
doStuff(foo) //static typing: known beforehand that types don't match

---

Dyn getFoo = lib['getFoo']
Dyn doStuff = lib['doStuff']

Dyn foo = getFoo() //dynamic typing: don't know beforehand whether types match
foo.somthing() //dynamic typing: don't know beforehand whether value of foo has a "somthing" method
doStuff(foo) //dynamic typing: don't know beforehand whether types match
			</programlisting>
			
			<para>Arguments against: Interfaces should almost always be known beforehand. Dynamic static typing may be very rarely used, and could encourage bad programming.</para>
		</section>
		
		<section xml:id="rationale.terms">
			<title>Terms</title>
			
			<section xml:id="rationale.get-set">
				<title>get/set</title>
								
				<table>
					<tbody>
						<tr>
							<th>term as verb</th>
							<th>term as noun</th>
							<th>good points</th>
							<th>bad points</th>
						</tr>
						
						<tr>
							<td>get</td>
							<td>getter</td>
							<td>short, easy to say, easy to spell, common amoung programming languages</td>
							<td>implies the property has been taken away</td>
						</tr>
						
						<tr>
							<td>set</td>
							<td>setter</td>
							<td>short, easy to say, easy to spell, common amoung programming languages</td>
							<td>sounds more like adding a new property than changing the value of a pre-existing property</td>
						</tr>
						
						<tr>
							<td>access</td>
							<td>accessor</td>
						</tr>
						
						<tr>
							<td>retrieve</td>
							<td>retriever</td>
						</tr>
						
						<tr>
							<td>read</td>
							<td>reader</td>
						</tr>
						
						<tr>
							<td>write</td>
							<td>writer</td>
						</tr>
						
						<tr>
							<td>mutate</td>
							<td>mutator</td>
						</tr>
					</tbody>
				</table>
				
				<para>Additional notes:</para>
				<para>The one letter difference between "get" and "set" (and "getter" and "setter") could cause errors more easily than if the difference were greater. Also, the noun form is slightly irregular; some people may expect "geter" and "seter" to be the noun form.</para>
			</section>
		</section>
		
		<section xml:id="rationale.executing-boolean-logic">
			<title>Executing boolean logic nodes</title>
			
			<para>In other languages, functions/methods that return boolean values are often chained together with short-circuiting boolean logic nodes. XOR and XNOR nodes cannot short-circuit, and thus this does not apply to them.</para>
			
			<programlisting>
list.empty? $or list.clear()
//similar to:
$if $not list.empty? : list.clear()

list.empty? $and list = getValues()
//similar to:
$if list.empty? : list = getValues()
			</programlisting>
		</section>
		
		<section xml:id="executing-declaration-first">
			<title>Disallowing executing declaration-first</title>
			
			<para>Children of declaration-first nodes are executed when the scope is first created, which may involve executing an identifier associated with a variable identikey. When execution reaches a declaration-first node, the identifiers used to create the initial value assigned to the identikey may be assigned to different values. Thus, executing a declaration-first node could produce unexpected results.</para>
			
			<programlisting>
$decl Int alpha = 12345

$block {
	alpha = 9000
	println ( $decl-first Int beta = alpha ) //prints "12345"
}
			</programlisting>
			
			<para>In the above example, alpha is executed and assigned to beta when the scope for the block node is created. Then, 9000 is assigned to alpha. Then, the declaration-first node is executed, producing the value assigned to beta, which is 12345. A programmer may have expected beta to be bound to the current value of alpha, which is 9000.</para>
		</section>
	</chapter>

	<chapter xml:id="unsorted-outdated-stuff">
		<title>Unsorted/outdated stuff</title>

		<section xml:id="closures">
			<title>Closures</title>
			
			<para>Functions and classes (amoung others) have references to their containing scope. Identifier references in these scopes can be accessed and modified by the functions/classes.</para>
			
			<para>Copy closures create copies of specific values when a function node is executed. Modifying this copy does not modify the captured scope.</para>
			
			<programlisting>
<![CDATA[
//regular closures

func makePrinters(Int max) func()void[] {
	func()void[] printers = new func()void[]
	Int i = 1
	while i <= max {
		printers << func()void {
			print i + ' '
		}
		i++
	}
	return printers
}

//array of functions that have no parameters and return nothing
func()void[] printers = makePrinters(10)
for printer in printers {
	printer()
}

//output
10 10 10 10 10 10 10 10 10 10 

Each of the anonymous functions held a reference to the same scope where i was defined. Because i held 10 when the functions were called, each output 10.
]]>
			</programlisting>
			
			<programlisting>
<![CDATA[
//copy closures

func makePrinters(Int max) func()void[] {
	func()void[] printers = new func()void[]
	Int i = 1
	while i <= max {
		printers << func()void {
			copyclosure i
			print i + ' '
		}
		i++
	}
	return printers
}

//array of functions that have no parameters and return nothing
func()void[] printers = makePrinters(10)
for printer in printers {
	printer()
}

//output
1 2 3 4 5 6 7 8 9 10

Each of the anynonymous functions held a copy of the value of i at the time the function was created.
]]>
			</programlisting>
		</section>

		<section xml:id="tree-examples">
			<title>Tree examples</title>
				
			<section xml:id="tree-example-1">
				<title>Example 1</title>
					
				<programlisting>
<![CDATA[

global
	declare-const
		identifier
			"main"
		expression [value] (function-definition)
			function-parameter
				identifier
					"args"
				expression [interface] (interface-template-instantiation)
					expression [interface-template] (identifier)
						"array"	
					expression [template-argument] (identifier)
						"string"
			expression [return-interface] (identifier)
				"int"
			expression (return)
				expression (integer)
					0

func main(string[] args) int
	return 0
]]>
				</programlisting>
			</section>
				
			<section xml:id="tree-example-2">
				<title>Example 2</title>
					
				<programlisting>
<![CDATA[
global (global)
	declaration (declaration > function-declaration)
		name (string)
			"main"
		return (expression > object-reference)
			name (string)
				"int"
		item (item > return)
			value (expression > integer)
				0

func main() int
	return 0

<global type="global">
	<declaration type="function-declaration">
		<name type="string">main</name>
		<return type="object-reference">
			<name type="string">int</name>
		</return>
		<item type="return">
			<value type="integer">0</value>
		</item>
	</declaration>
</global>
]]>
				</programlisting>
			</section>

			<section xml:id="tree-example-3">
				<title>Example 3</title>
					
				<programlisting>
<![CDATA[
global (global)
	name-bind (name-bind)
		identifier (identifier)
			"main"
		expression (function-definition)
			parameter (parameter)
				interface (interface > function-call)
					function (function > identifier)
						"array"
					argument (expression > identifier)
						"string"
				identifier (identifier)
					"args"
		return-interface (interface > identifier)
			"int"
		expression (expression > return)
			expression (expression > literal-integer)
				0

func main(string[] args) int
	return 0

<global type="global">
	<name-bind type="name-bind">
		<identifier type="identifier">main</identifier>
		<expression type="function-definition">
			<parameter-list type="parameter-list">
				<parameter type="parameter">
					<identifier type="identifier">args</identifier>
					<expression type="function-call">
						<identifier type="identifier">array</identifier>
						<argument-list type="argument-list">
							<identifier type="identifier">string</identifier>
						</argument-list>
					</expression>
				</parameter>
			</parameter-list>
			<return-interface type="identifier">int</return-interface>
			<expression-list type="expression-list">
				<expression type="return">
					<expression type="literal-integer">0</expression>
				</expression>
			</expression-list>
		</function>
	</name-bind>
</global>
]]>
				</programlisting>
			</section>
		</section>
		
		<section xml:id="get-interface">
			<title>get interface</title>
			
			<para>It's always possible to bind the interface of an object to an identifier.</para>
			
			<programlisting>
func getInterface{I}(I o) {
return I;
}

dynref o = getMysteryObj()
interface i = getInterface(o)
i o2 = o
			</programlisting>
		</section>
		
		<section xml:id="obj-interface">
			<title>obj interface</title>
			
			<para>All objects automatically implement the "obj" interface.</para>
			
			<programlisting>
obj foo = getAnObject()
(myinterface foo) .doStuff 3
			</programlisting>
		</section>
		
		<section xml:id="identifier-binding">
			<title>Binding to identifiers</title>
			
			<programlisting>int alpha</programlisting>
			<para>Declares that "alpha" can refer to objects that implement the "int" interface. alpha currently doesn't refer to anything; i.e. it refers to null.</para>
			
			<programlisting>alpha = 3</programlisting>
			<para>Creates an object that implements the int interface and makes alpha refer to it</para>
			
			<programlisting>int beta = 5</programlisting>
			<para>Declares that "beta" can refer to objects that implement the "beta" interface. Creates an object that implements the int interface. Binds the object to "beta".</para>
			
			<para>Multiple identifiers can refer to the same object.</para>
			<programlisting>
obj o = getObj()
int a = o
rat b = o
			</programlisting>
		</section>
		
		<section xml:id="print-println-return-interfaces">
			<title>Return interfaces of print and println</title>
			
			<para>Below, [unbound] means the interface is not bound to an identifier. However, these interfaces can be bound to identifiers and used like any user-created interface, and they have no special properties.</para>
			
			<simplelist>
				<member>func{I}(I)[unbound] print</member>
				<member>func{I}(I)[unbound] println</member>
			</simplelist>

			<screen>
interface{I} Print
	func call(I) Print

interface{I} PrintLine
	func call(I) PrintLine
			</screen>
			
			<para>When print is called, it returns an object that implements an interface like Print. When println is called, it returns an object that implements an interface like PrintLine. Neither interface is bound to an identifier when execution begins. They are not the same interface, meaning print(1).interface == println(1).interface executes to false.</para>
			
			<screen>
println 1 2 3 "a" "b" "c" 4.5 6.7 8.9
			</screen>
		</section>
		
		<section xml:id="adjuncts">
			<title>Adjuncts</title>
			
			<programlisting>
interface IMyInterface
	public func doStuffA()
	public func doStuffB()

class MyClass
	:implements(IMyInterface)
	...

func IMyInterface.doAB()
	this.doStuffA()
	this.doStuffB()

func testThing(ref IMyInterface arg)
	arg.doAB()

MyClass inst
testThing(inst)
			</programlisting>
		</section>
		
		<section xml:id="runtime-inteface">
			<title>runtime interface implementation</title>
		
			<para>With Niviok, you should be able to write a function that takes an interface (foo) and returns a function that takes an object of that interface (foo) and returns an object that implements that same interface (foo), but with an implementation that writes to a log anytime a method is called.</para>
		
			<screen>
log l = Log()
foo o = Foo()
foo wrapped = wrap(o, l)
doStuffWithAFoo(wrapped)
			</screen>
		
			<para>Now anytime a method is called on the object, a log entry could be written.</para>
		
			<screen>
func{I} wrap(I o, log l) I
objbuilder wrapper = newObjbuilder()
wrapper.implement(I)
for prop in I.props
wrapper.interfaces[I].setProp( prop.name,
func(:vararg)obj

interface i = newInterface()
i.inherit(I)
for prop in 

wrap(...) takes an interface and returns a function
wrap(foo)(...) takes a foo and returns a foo
			</screen>
		</section>
		
		<section xml:id="runtime-interface-creation">
			<title>Runtime interface creation</title>
			
			<screen>
func createInterface( map{string,dyn} methods ) interface
	interface rv = newInterface()
	for (name, meth) in methods
		rv.methods.add( pair(name, meth.functionSignature) )
	return rv

func foo(int b) string
...

func bar(float c, float d) myClass
...

func baz(widget1 e, widget4 f)
...

map(string, func) table = {
"methA": foo,
"methB": bar,
"methC": baz
}
interface myinterface = createInterface(table)

func alpha(int g) string
...

func beta(float h, float i) myClass
...

func gamma(widget1 j, widget4 k)
...

myinterface myobj = {
methA: alpha,
methB: beta,
methC: gamma
}
string str = obj.methA(3)
myClass val = obj.methB(5.5, 7.7)
obj.gamma( createWidget1(), Widget4Factory.makeOne() )
			</screen>
		</section>
		
		<section xml:id="self-return-type">
			<title>"self" return type</title>
			
			<screen>
func(int,float)self

is the same as

interface __foo__
	func call(int,float) __foo__

func example(int num) self
	...
	
example 1 2 3 4 5 6 7 8 9 0 //calls the example function 10 times
			</screen>
		</section>

		<section xml:id="bind">
			<title>Bind</title>
			
			<screen>
interface foo
	...

func bar(foo o, int num)
	...

foo fooInst = getAFoo()
bar(fooInst, 3)
(fooInst => bar) 3
func() funcy = (fooInst => bar)
funcy(3)
			</screen>
		
			<para>obj => func</para>
		
			<para>The "=>" operator binds the obj to the first argument of the function. It executes to a function. Semantically this creates a function-definition with a closure of the obj and func.</para>
		</section>

		<section xml:id="classes">
			<title>Classes</title>
			
			<para>Classes produce functors that, when called, create objects. If a class implements more than 1 interface, it can declare which of the implemented interfaces is the active interface of the returned object by marking an interface as default. If no interface is marked, the active interface is obj.</para>
		</section>

		<section xml:id="noninstantiated-interface-templates">
			<title>Noninstantiated interface templates</title>
		
			<screen>
interface list{I}
	readonly int count
	func pushFront(I o)
	func popFront() I

struct node{C}
	node{C} next = null
	node{C} value = null

class makeList{T}
	node{T} first
	
	interface list{T} #default //so makeList returns a list instead of an obj that has to be cast
		...

list{int} nums = makeList{int}()
nums.pushFront(3)
nums.pushFront(5)
print nums.size //2

list{string} names = makeList{string}()
names.pushFront("John")
names.pushFront("Sarah")
names.pushFront("Billy")
print names.size //3

list someList = nums
print someList.size //2
someList.pushFront(5) //error
			</screen>
			
			<para>someList may refer to any kind of list, such as list{foo}, list{bar}, etc, so only methods that have the same paramater and return interfaces for all list{}s can be called.</para>
		</section>

		<section xml:id="dynamic-library-loading">
			<title>Dynamic library loading</title>
		
			<para>The selectLibrary function enables gaining references to objects without knowing the nodes that created the objects.</para>
		
			<screen>
interface Library
	readonly String path
	readonly String name
	readonly String version
	readonly Bool loaded?
	func key(String name) Dyn
	func get{I}(String name) I
	func load()
	func unload()

//prototype
func selectLibrary(string identifier, string version, bool load? = true) Library

---

string identifier
string version
if platform == platforms.MacOSX or platform == platforms.Windows
	identifier = "libxml"
	version = "2.1"
elif platform == platforms.Linux
	identifier = "/usr/lib/libxml.so"
	version = "56"
else
	throw Error("unsupported platform")

Library XmlLib = selectLibrary(identifier, version)

Interface XmlElement = XmlLib.get{Interface}("XmlElement")
Dyn XmlReader = XmlLib["XmlReader"]

XmlElement element = XmlRead.read("foo.xml").documentElement
			</screen>
		</section>
		
		<section xml:id="static-typing">
			<title>Static typing</title>
			
			<para>XXX spec out static typing and demand that implementations check all typing as much as possible before running anything. Note the section on dynamic static typing.</para>
		</section>
	</chapter>
</book>