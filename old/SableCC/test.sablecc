
//This file was created programmatically, so
//DO NOT EDIT THIS FILE DIRECTLY.

Package Dextr.SableCC;

Helpers
	illegal = [0..8] ;
	reserved = [[[[[[[[[[[[[[[[[[[
		0x9 + //tab
		0xA ]+ //linefeed
		0x20 ]+ //space
		'+' ]+
		'-' ]+
		'*' ]+
		'/' ]+
		'.' ]+
		',' ]+
		'=' ]+
		'"' ]+
		''' ]+
		'(' ]+
		')' ]+
		'{' ]+
		'}' ]+
		'<' ]+
		'>' ]+
		'[' ]+
		']' ] ;
	numerical = [0 + [1..9]] ;
	free = [[[[0..0x10FFFF] - illegal] - reserved] - numerical] ;

Tokens
	document_open = 'BSDO' ;
	document_close = 'BSDC' ;
	indent_open = 'BSIO' ;
	indent_close = 'BSIC' ;
	newline = '\n' ;
	identifier = free (free | numerical)* ;
	integer = numerical+ ;
	rational = numerical+ '.' numerical+ ;
	string = '"' [[free + reserved] - '"']* '"' ;

	operator_ef = '-' ;
	operator_ed = '+' ;
	operator_eb = ')' ;
	keyword_lt = 'lt' ;
	keyword_or = 'or' ;
	keyword_dne = 'dne' ;
	keyword_xnor = 'xnor' ;
	keyword_gte = 'gte' ;
	keyword_plane = 'plane' ;
	operator_bcf = '}' ;
	operator_bcd = '{' ;
	keyword_else = 'else' ;
	keyword_elif = 'elif' ;
	operator_eh = '/' ;
	keyword_gt = 'gt' ;
	operator_ec = '*' ;
	keyword_if = 'if' ;
	operator_ea = '(' ;
	keyword_and = 'and' ;
	keyword_nand = 'nand' ;
	keyword_xor = 'xor' ;
	keyword_nor = 'nor' ;
	keyword_eql = 'eql' ;
	operator_gb = '=' ;
	keyword_decl = 'decl' ;
	keyword_func = 'func' ;
	keyword_lte = 'lte' ;
	keyword_expose = 'expose' ;
	operator_eg = '.' ;
	operator_ee = ',' ;

Productions


expression
	= {a}  simple
	| {b}  add
	| {c}  booleanlogic
	| {d}  declarefirst
	| {e}  ifelse
	| {f}  test ;

primary
	= {a}  identifier
	| {b}  integer
	| {c}  rational
	| {d}  string
	| {e}  parenthetical ;

parenthetical
	= operator_ea expression operator_eb ;

simple
	= {a}  block
	| {b}  call
	| {c}  extractmember
	| {d}  primary ;

call
	= {a}  simple operator_ea operator_eb
	| {b}  simple operator_ea argumentlist operator_eb ;

argumentlist
	= {a}  expression
	| {b}  argumentlist operator_ee expression ;

extractmember
	= simple operator_eg identifier ;

mult
	= {a}  simple
	| {b}   [a]:simple operator_ec  [b]:simple
	| {c}   [a]:simple operator_eh  [b]:simple ;

add
	= {a}  mult
	| {b}   [a]:mult operator_ed  [b]:mult
	| {c}   [a]:mult operator_ef  [b]:mult ;

booleanlogic
	=  [a]:simple booleanfunction  [b]:simple ;
booleanfunction
	= {a}  keyword_and
	| {b}  keyword_nand
	| {c}  keyword_or
	| {d}  keyword_nor
	| {e}  keyword_xor
	| {f}  keyword_xnor ;

declarefirst
	= {a}  declarefirstnormal
	| {b}  functiondeclaration ;

declarefirstnormal
	= keyword_decl identifier operator_gb expression ;

functiondeclaration
	= {a}  keyword_func identifier operator_ea operator_eb block
	| {b}  keyword_func identifier operator_ea parameterlist operator_eb block ;

parameterlist
	= {a}  parameter
	| {b}  parameterlist operator_ee parameter ;

parameter
	= identifier ;

block
	= {a}  braceblock
	| {b}  tabblock
	| {c}  bracetabblock ;

//to ensure this starts and ends on the same line,
//test linenumber of operator_bcd and operator_bcf tokens
//this can't be easily stated in bnf
braceblock
	= {a}  operator_bcd operator_bcf
	| {b}  operator_bcd braceblockinside operator_bcf ;
braceblockinside
	= {a}  expression
	| {b}  braceblockinside operator_ee expression ;

//the tokenizer ensures a newline comes before every indent open
//the newline is declared optional to allow, e.g.: newline tabblock
tabblock
	= {a}  indent_open indent_close
	| {b}  indent_open tabblockinside indent_close
	| {c}  newline tabblock ;
tabblockinside
	= {a}  expression newline
	| {b}  tabblockinside expression newline ;

bracetabblock
	= operator_bcd tabblock operator_bcf ;

test
	=  [a]:simple comparisonfunction  [b]:simple ;
comparisonfunction
	= {a}  keyword_lt
	| {b}  keyword_lte
	| {c}  keyword_eql
	| {d}  keyword_gte
	| {e}  keyword_gt
	| {f}  keyword_dne ;

ifelse
	= if elif? else? ;
ifexpr
	= {a}  simple
	| {b}  test ;
if
	= keyword_if ifexpr block ;
elif
	= {a}  keyword_elif ifexpr block
	| {b}  elif keyword_elif ifexpr block ;
else
	= keyword_else block ;

declarefirstlist
	= {a}  declarefirst
	| {b}  declarefirstlist newline declarefirst ;

bundledocument
	=
		document_open
		newline?
		expose*
		planereference*
		declarefirstlist?
		document_close
	;
expose
	= keyword_expose identifier newline ;
planereference
	= keyword_plane string newline ;

planedocument
	=
		document_open
		newline?
		declarefirstlist?
		document_close
	;


