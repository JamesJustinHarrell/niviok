//THIS FILE WAS GENERATED PROGRAMMATICALLY.
//DO NOT EDIT THIS FILE DIRECTLY.
//CHANGES TO THIS FILE WILL BE OVERRIDDEN.

Package Acrid.Ivan.SableCC;

Helpers

	h_all = [0..0x10FFFF] ;
	h_illegal = [0..8] ;
	h_legal = [h_all - h_illegal] ;
	h_numerical = ['0' + ['1'..'9']] ;
	h_astral = [0x010000..0x10FFFF] ;
	h_alpha = [ ['a'..'z'] + ['A'..'Z'] ] ;
	// wordchar = [ h_astral + h_alpha ] ;
	h_wordchar = h_alpha ;


Tokens

	identifier = h_wordchar (h_wordchar | h_numerical | '_')* ('?' | '!')? ;
	
	//other terminal nodes
	integer = h_numerical+ ;
	rational = h_numerical+ '.' h_numerical+ ;
	string = '"' [h_legal - '"']* '"' ;

	t_whitespace = [[[
		0x09 + //tab
		0x0A ]+ //linefeed
		0x0D ]+ //carriage return
		0x20 ] ; //space
	
	t_linecomment =
		'#' [[[h_legal - '#'] - 0x0A] - 0x0D]* ;
	
	t_multilinecomment =
		'/*' [h_legal - '*']* '*/' ;
	
	k_constant = '!constant' ;
	k_expose = '!expose' ;
	k_first = '!first' ;
	k_function = '!function' ;
	k_hidden = '!hidden' ;
	k_import = '!import' ;
	k_in = '!in' ;
	k_inout = '!inout' ;
	k_out = '!out' ;
	k_overload = '!overload' ;
	k_raise = '!raise' ;
	k_sieve = '!sieve' ;
	k_variable = '!variable' ;
	k_version = '!version' ;
	k_visible = '!visible' ;

	o_assign = '=' ;
	o_assignbreed = ':=' ;
	o_curlyclose = '}' ;
	o_curlyopen = '{' ;
	o_parenopen = '(' ;
	o_parenclose = ')' ;
	o_period = '.' ;
	o_placeholder = '-' ;
	o_semicolon = ';' ;


Ignored Tokens

	t_whitespace ,
	t_linecomment ,
	t_multilinecomment ;


Productions

	document {-> document}
		= module
			{-> New document(module)} ;


	//----- FAMILIES
	/*
	statementdeclaration {-> statementdeclaration}
		= {declarefirst} declarefirst
			{-> New statementdeclaration.declarefirst(declarefirst)}
		| {sieve} sieve
			{-> New statementdeclaration.sieve(sieve)} ;

	expression {-> expression}
		= {declareempty} declareempty
			{-> New expression.declareempty(declareempty)}
		| {raise} raise
			{-> New expression.raise(raise)}
		| {assign} assign
			{-> New expression.assign(assign)}
		| {call} call
			{-> New expression.call(call)}
		| {compound} compound
			{-> New expression.compound(compound)}
		| {conditional} conditional
			{-> New expression.conditional(conditional)}
		| {curry} curry
			{-> New expression.curry(curry)}
		| {declareassign} declareassign
			{-> New expression.declareassign(declareassign)}
		| {identifier} identifier
			{-> New expression.identifier(identifier)}
		| {select} select
			{-> New expression.select(select)}
		| {setproperty} setproperty
			{-> New expression.setproperty(setproperty)}
		| {trycatch} trycatch
			{-> New expression.trycatch(trycatch)}
		| {typeselect} typeselect
			{-> New expression.typeselect(typeselect)}
		| {and} and
			{-> New expression.and(and)}
		| {nand} nand
			{-> New expression.nand(nand)}
		| {or} or
			{-> New expression.or(or)}
		| {nor} nor
			{-> New expression.nor(nor)}
		| {xor} xor
			{-> New expression.xor(xor)}
		| {xnor} xnor
			{-> New expression.xnor(xnor)}
		| {breed} breed
			{-> New expression.breed(breed)}
		| {caller} caller
			{-> New expression.caller(caller)}
		| {object} object
			{-> New expression.object(object)}
		| {dictionary} dictionary
			{-> New expression.dictionary(dictionary)}
		| {enum} enum
			{-> New expression.enum(enum)}
		| {extractmember} extractmember
			{-> New expression.extractmember(extractmember)}
		| {function} function
			{-> New expression.function(function)}
		| {functioninterface} functioninterface
			{-> New expression.functioninterface(functioninterface)}
		| {generator} generator
			{-> New expression.generator(generator)}
		| {genericfunction} genericfunction
			{-> New expression.genericfunction(genericfunction)}
		| {genericinterface} genericinterface
			{-> New expression.genericinterface(genericinterface)}
		| {instantiategeneric} instantiategeneric
			{-> New expression.instantiategeneric(instantiategeneric)}
		| {integer} integer
			{-> New expression.integer(integer)}
		| {interface} interface
			{-> New expression.interface(interface)}
		| {rational} rational
			{-> New expression.rational(rational)}
		| {string} string
			{-> New expression.string(string)} ;

	interfacemember {-> interfacemember}
		= {breeder} breeder
			{-> New interfacemember.breeder(breeder)}
		| {callee} callee
			{-> New interfacemember.callee(callee)}
		| {property} property
			{-> New interfacemember.property(property)}
		| {method} method
			{-> New interfacemember.method(method)} ;
	*/
	expression
		= {declareempty} declareempty
		| {raise} raise
		| {identifier} identifier
		| {function} function
		| {integer} integer ;
	
	statementdeclaration
		= {declarefirst} declarefirst
		| {sieve} sieve ;

	//----- NON-EXECUTABLE
	
	import {-> import}
		= k_import identifier o_curlyopen importattempt+ o_curlyclose
			{-> New import(identifier, [importattempt.importattempt])} ;
	
	importattempt {-> importattempt}
		= [scheme]:string [body]:string o_semicolon
			{-> New importattempt(scheme, body)} ;
	
	parameterimpl {-> parameterimpl}
		= {a} parameterimpldirection [type]:expression [name]:identifier
			{-> New parameterimpl(parameterimpldirection.direction, type, name, Null)}
		| {b} parameterimpldirection [type]:expression [name]:identifier o_assign [defaultvalue]:expression
			{-> New parameterimpl(parameterimpldirection.direction, type, name, defaultvalue)} ;
	parameterimpldirection {-> direction}
		= {in} k_in {-> New direction.in()}
		| {out} k_out {-> New direction.out()}
		| {inout} k_inout {-> New direction.inout()} ;
	
	
	//----- STATEMENTS

	declarefirst {-> declarefirst}
		= {overload} k_first k_overload [type]:expression identifier o_assign [value]:expression
			{-> New declarefirst(identifier, New boolean.true(), type, New boolean.false(), value)}
		| {overloadbreed} k_first k_overload [type]:expression identifier o_assignbreed [value]:expression
			{-> New declarefirst(identifier, New boolean.true(), type, New boolean.true(), value)}
		| {constant} k_first k_constant [type]:expression identifier o_assign [value]:expression
			{-> New declarefirst(identifier, New boolean.false(), type, New boolean.false(), value)}
		| {constantbreed} k_first k_constant [type]:expression identifier o_assignbreed [value]:expression
			{-> New declarefirst(identifier, New boolean.false(), type, New boolean.true(), value)} ;

	hidable {-> hidable}
		= {hidden} k_hidden statementdeclaration o_semicolon
			{-> New hidable(New boolean.true(), statementdeclaration)}
		| {visible} k_visible statementdeclaration o_semicolon
			{-> New hidable(New boolean.false(), statementdeclaration)} ;

	module {-> module}
		= k_version [major]:integer [minor]:integer o_semicolon import*  modulesieve
			{-> New module(major, minor, [import], modulesieve.sieve)} ;
	modulesieve {-> sieve}
		= [expose]:moduleexpose* hidable*
			{-> New sieve([expose.expression], [hidable])} ;
	moduleexpose {-> expression}
		= k_expose [expose]:expression o_semicolon {-> expose.expression} ;
	
	sieve {-> sieve}
		= k_sieve o_curlyopen [expose]:sieveexpose* hidable* o_curlyclose
			{-> New sieve([expose.expression], [hidable])} ;
	sieveexpose {-> expression}
		= k_expose [expose]:expression o_semicolon {-> expose.expression} ;
	
	
	//----- NON-PRODUCING
	
	declareempty {-> declareempty}
		= k_variable [type]:expression identifier
			{-> New declareempty(identifier, type)} ;
	
	raise {-> raise}
		= k_raise expression
			{-> New raise(expression)} ;


	//----- ALWAYS PRODUCING
	
	function {-> function}
		= k_function o_parenopen parameterimpl* o_parenclose [returntype]:expression o_curlyopen [body]:expression o_curlyclose
			{-> New function([parameterimpl], returntype, body)} ;

Abstract Syntax Tree

	document
		= module ;


	//----- ENUMS

	boolean
		= {true}
		| {false} ;
		
	direction
		= {in}
		| {out}
		| {inout} ;
	
	memberstatus
		= {new}
		| {normal}
		| {deprecated} ;

	membertype
		= {breeder}
		| {callee}
		| {getter}
		| {setter}
		| {method} ;
	

	and
		= [first]:expression [second]:expression ;

	declarefirst
		= [name]:identifier [overload]:boolean [type]:expression [breed]:boolean [value]:expression ;

	conditional
		= [test]:expression [result]:expression [else]:expression? ;

	declareempty
		= [name]:identifier [type]:expression ;

	argument
		= [parametername]:identifier? [value]:expression? ;

	module
		= [niviokmajorversionnumber]:integer [niviokminorversionnumber]:integer import* sieve ;

	parameterinfo
		= direction [type]:expression [name]:identifier [hasdefaultvalue]:boolean ;

	statusedmember
		= memberstatus [member]:interfacemember ;

	dictionaryentry
		= [key]:expression [value]:expression ;

	importattempt
		= [scheme]:string [body]:string ;

	select
		= [inputvalue]:expression case* [else]:expression? ;

	genericinterface
		= [parameter]:parameterinfo+ interface ;

	parameterimpl
		= direction [type]:expression [name]:identifier [defaultvalue]:expression? ;

	xor
		= [first]:expression [second]:expression ;

	raise
		= [value]:expression ;

	generator
		= [type]:expression [body]:expression ;

	breed
		= [parent]:expression [interface]:expression? ;

	nand
		= [first]:expression [second]:expression ;

	hidable
		= [hidden]:boolean [declaration]:statementdeclaration ;

	functioninterface
		= [templateargumentcount]:expression? parameterinfo* [returntype]:expression ;

	call
		= [receiver]:expression argument* ;

	typeselect
		= [inputvalue]:expression [castedname]:identifier? [requirematch]:boolean? typecase* [else]:expression? ;

	typecase
		= [testtype]:expression+ [result]:expression ;

	import
		= [alias]:identifier importattempt+ ;

	method
		= [name]:identifier [interface]:expression ;

	function
		= parameterimpl* [returntype]:expression [body]:expression ;

	xnor
		= [first]:expression [second]:expression ;

	instantiategeneric
		= [generic]:expression argument+ ;

	dictionary
		= [keytype]:expression [valuetype]:expression dictionaryentry* ;

	object
		= worker+ ;

	worker
		= [face]:expression [childworker]:worker* memberimplementation* ;

	genericfunction
		= [parameter]:parameterinfo+ function ;

	enum
		= [type]:expression enumentry+ ;

	declareassign
		= [name]:identifier [constant]:boolean [type]:expression [breed]:boolean [value]:expression ;

	compound
		= [expose]:expression* [declaration]:statementdeclaration* [member]:expression+ ;

	interface
		= [inheritee]:expression* [member]:statusedmember* ;

	statementdeclaration
		= {declarefirst} declarefirst
		| {sieve} sieve ;

	setproperty
		= [source]:expression [propertyname]:identifier [value]:expression ;

	sieve
		= [expose]:expression* hidable* ;

	extractmember
		= [source]:expression [membername]:identifier ;

	nor
		= [first]:expression [second]:expression ;

	case
		= [testvalue]:expression+ [result]:expression ;

	catcher
		= [type]:expression [name]:identifier? [test]:expression? [result]:expression ;

	trycatch
		= [try]:expression catcher* [onsuccess]:expression? [finally]:expression? ;

	callee
		= parameterinfo* [returntype]:expression ;

	caller
		= [interface]:expression? [methodname]:identifier ;

	assign
		= [name]:identifier [breed]:boolean [value]:expression ;

	memberimplementation
		= membertype [name]:identifier? [interface]:expression? [function]:expression ;

	interfacemember
		= {breeder} breeder
		| {callee} callee
		| {property} property
		| {method} method ;

	expression
		= {declareempty} declareempty
		| {raise} raise
		| {assign} assign
		| {call} call
		| {compound} compound
		| {conditional} conditional
		| {curry} curry
		| {declareassign} declareassign
		| {identifier} identifier
		| {select} select
		| {setproperty} setproperty
		| {trycatch} trycatch
		| {typeselect} typeselect
		| {and} and
		| {nand} nand
		| {or} or
		| {nor} nor
		| {xor} xor
		| {xnor} xnor
		| {breed} breed
		| {caller} caller
		| {object} object
		| {dictionary} dictionary
		| {enum} enum
		| {extractmember} extractmember
		| {function} function
		| {functioninterface} functioninterface
		| {generator} generator
		| {genericfunction} genericfunction
		| {genericinterface} genericinterface
		| {instantiategeneric} instantiategeneric
		| {integer} integer
		| {interface} interface
		| {rational} rational
		| {string} string ;

	enumentry
		= [name]:identifier [value]:expression? ;

	breeder
		= [type]:expression? ;

	property
		= [name]:identifier [writable]:boolean [type]:expression ;

	curry
		= [function]:expression argument* [call]:boolean ;

	or
		= [first]:expression [second]:expression ;
