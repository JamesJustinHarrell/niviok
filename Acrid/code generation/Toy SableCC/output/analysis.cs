/* This file was generated by SableCC (http://www.sablecc.org/). */

using System;
using System.Collections;
using Acrid.Toy.SableCC.node;

namespace Acrid.Toy.SableCC.analysis {


public interface Analysis : Switch
{
    Object GetIn(Node node);
    void SetIn(Node node, Object inobj);
    Object GetOut(Node node);
    void SetOut(Node node, Object outobj);

    void CaseStart(Start node);
    void CaseADocument(ADocument node);
    void CaseAWordSexp(AWordSexp node);
    void CaseAIntegerSexp(AIntegerSexp node);
    void CaseARationalSexp(ARationalSexp node);
    void CaseAStringSexp(AStringSexp node);
    void CaseAPlaceholderSexp(APlaceholderSexp node);
    void CaseAListSexp(AListSexp node);

    void CaseTTWord(TTWord node);
    void CaseTTInteger(TTInteger node);
    void CaseTTRational(TTRational node);
    void CaseTTString(TTString node);
    void CaseTTParenopen(TTParenopen node);
    void CaseTTParenclose(TTParenclose node);
    void CaseTTPlaceholder(TTPlaceholder node);
    void CaseTTWhitespace(TTWhitespace node);
    void CaseTTLinecomment(TTLinecomment node);
    void CaseTTMultilinecomment(TTMultilinecomment node);
    void CaseEOF(EOF node);
}


public class AnalysisAdapter : Analysis
{
    private Hashtable inhash;
    private Hashtable outhash;

    public virtual Object GetIn(Node node)
    {
        if(inhash == null)
        {
            return null;
        }

        return inhash[node];
    }

    public virtual void SetIn(Node node, Object inobj)
    {
        if(this.inhash == null)
        {
            this.inhash = new Hashtable(1);
        }

        if(inobj != null)
        {
            this.inhash[node] = inobj;
        }
        else
        {
            this.inhash.Remove(node);
        }
    }
    public virtual Object GetOut(Node node)
    {
        if(outhash == null)
        {
            return null;
        }

        return outhash[node];
    }

    public virtual void SetOut(Node node, Object outobj)
    {
        if(this.outhash == null)
        {
            this.outhash = new Hashtable(1);
        }

        if(outobj != null)
        {
            this.outhash[node] = outobj;
        }
        else
        {
            this.outhash.Remove(node);
        }
    }
    public virtual void CaseStart(Start node)
    {
        DefaultCase(node);
    }

    public virtual void CaseADocument(ADocument node)
    {
        DefaultCase(node);
    }
    public virtual void CaseAWordSexp(AWordSexp node)
    {
        DefaultCase(node);
    }
    public virtual void CaseAIntegerSexp(AIntegerSexp node)
    {
        DefaultCase(node);
    }
    public virtual void CaseARationalSexp(ARationalSexp node)
    {
        DefaultCase(node);
    }
    public virtual void CaseAStringSexp(AStringSexp node)
    {
        DefaultCase(node);
    }
    public virtual void CaseAPlaceholderSexp(APlaceholderSexp node)
    {
        DefaultCase(node);
    }
    public virtual void CaseAListSexp(AListSexp node)
    {
        DefaultCase(node);
    }

    public virtual void CaseTTWord(TTWord node)
    {
        DefaultCase(node);
    }
    public virtual void CaseTTInteger(TTInteger node)
    {
        DefaultCase(node);
    }
    public virtual void CaseTTRational(TTRational node)
    {
        DefaultCase(node);
    }
    public virtual void CaseTTString(TTString node)
    {
        DefaultCase(node);
    }
    public virtual void CaseTTParenopen(TTParenopen node)
    {
        DefaultCase(node);
    }
    public virtual void CaseTTParenclose(TTParenclose node)
    {
        DefaultCase(node);
    }
    public virtual void CaseTTPlaceholder(TTPlaceholder node)
    {
        DefaultCase(node);
    }
    public virtual void CaseTTWhitespace(TTWhitespace node)
    {
        DefaultCase(node);
    }
    public virtual void CaseTTLinecomment(TTLinecomment node)
    {
        DefaultCase(node);
    }
    public virtual void CaseTTMultilinecomment(TTMultilinecomment node)
    {
        DefaultCase(node);
    }

    public virtual void CaseEOF(EOF node)
    {
        DefaultCase(node);
    }

    public virtual void DefaultCase(Node node)
    {
    }
}


public class DepthFirstAdapter : AnalysisAdapter
{
    public virtual void InStart(Start node)
    {
        DefaultIn(node);
    }

    public virtual void OutStart(Start node)
    {
        DefaultOut(node);
    }

    public virtual void DefaultIn(Node node)
    {
    }

    public virtual void DefaultOut(Node node)
    {
    }

    public override void CaseStart(Start node)
    {
        InStart(node);
        node.GetPDocument().Apply(this);
        node.GetEOF().Apply(this);
        OutStart(node);
    }

    public virtual void InADocument(ADocument node)
    {
        DefaultIn(node);
    }

    public virtual void OutADocument(ADocument node)
    {
        DefaultOut(node);
    }

    public override void CaseADocument(ADocument node)
    {
        InADocument(node);
        {
            Object[] temp = new Object[node.GetSexp().Count];
            node.GetSexp().CopyTo(temp, 0);
            for(int i = 0; i < temp.Length; i++)
            {
                ((PSexp) temp[i]).Apply(this);
            }
        }
        OutADocument(node);
    }
    public virtual void InAWordSexp(AWordSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutAWordSexp(AWordSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseAWordSexp(AWordSexp node)
    {
        InAWordSexp(node);
        if(node.GetTWord() != null)
        {
            node.GetTWord().Apply(this);
        }
        OutAWordSexp(node);
    }
    public virtual void InAIntegerSexp(AIntegerSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutAIntegerSexp(AIntegerSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseAIntegerSexp(AIntegerSexp node)
    {
        InAIntegerSexp(node);
        if(node.GetTInteger() != null)
        {
            node.GetTInteger().Apply(this);
        }
        OutAIntegerSexp(node);
    }
    public virtual void InARationalSexp(ARationalSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutARationalSexp(ARationalSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseARationalSexp(ARationalSexp node)
    {
        InARationalSexp(node);
        if(node.GetTRational() != null)
        {
            node.GetTRational().Apply(this);
        }
        OutARationalSexp(node);
    }
    public virtual void InAStringSexp(AStringSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutAStringSexp(AStringSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseAStringSexp(AStringSexp node)
    {
        InAStringSexp(node);
        if(node.GetTString() != null)
        {
            node.GetTString().Apply(this);
        }
        OutAStringSexp(node);
    }
    public virtual void InAPlaceholderSexp(APlaceholderSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutAPlaceholderSexp(APlaceholderSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseAPlaceholderSexp(APlaceholderSexp node)
    {
        InAPlaceholderSexp(node);
        if(node.GetTPlaceholder() != null)
        {
            node.GetTPlaceholder().Apply(this);
        }
        OutAPlaceholderSexp(node);
    }
    public virtual void InAListSexp(AListSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutAListSexp(AListSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseAListSexp(AListSexp node)
    {
        InAListSexp(node);
        if(node.GetTParenopen() != null)
        {
            node.GetTParenopen().Apply(this);
        }
        {
            Object[] temp = new Object[node.GetSexp().Count];
            node.GetSexp().CopyTo(temp, 0);
            for(int i = 0; i < temp.Length; i++)
            {
                ((PSexp) temp[i]).Apply(this);
            }
        }
        OutAListSexp(node);
    }
}


public class ReversedDepthFirstAdapter : AnalysisAdapter
{
    public virtual void InStart(Start node)
    {
        DefaultIn(node);
    }

    public virtual void OutStart(Start node)
    {
        DefaultOut(node);
    }

    public virtual void DefaultIn(Node node)
    {
    }

    public virtual void DefaultOut(Node node)
    {
    }

    public override void CaseStart(Start node)
    {
        InStart(node);
        node.GetEOF().Apply(this);
        node.GetPDocument().Apply(this);
        OutStart(node);
    }

    public virtual void InADocument(ADocument node)
    {
        DefaultIn(node);
    }

    public virtual void OutADocument(ADocument node)
    {
        DefaultOut(node);
    }

    public override void CaseADocument(ADocument node)
    {
        InADocument(node);
        {
            Object[] temp = new Object[node.GetSexp().Count];
            node.GetSexp().CopyTo(temp, 0);
            for(int i = temp.Length - 1; i >= 0; i--)
            {
                ((PSexp) temp[i]).Apply(this);
            }
        }
        OutADocument(node);
    }
    public virtual void InAWordSexp(AWordSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutAWordSexp(AWordSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseAWordSexp(AWordSexp node)
    {
        InAWordSexp(node);
        if(node.GetTWord() != null)
        {
            node.GetTWord().Apply(this);
        }
        OutAWordSexp(node);
    }
    public virtual void InAIntegerSexp(AIntegerSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutAIntegerSexp(AIntegerSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseAIntegerSexp(AIntegerSexp node)
    {
        InAIntegerSexp(node);
        if(node.GetTInteger() != null)
        {
            node.GetTInteger().Apply(this);
        }
        OutAIntegerSexp(node);
    }
    public virtual void InARationalSexp(ARationalSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutARationalSexp(ARationalSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseARationalSexp(ARationalSexp node)
    {
        InARationalSexp(node);
        if(node.GetTRational() != null)
        {
            node.GetTRational().Apply(this);
        }
        OutARationalSexp(node);
    }
    public virtual void InAStringSexp(AStringSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutAStringSexp(AStringSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseAStringSexp(AStringSexp node)
    {
        InAStringSexp(node);
        if(node.GetTString() != null)
        {
            node.GetTString().Apply(this);
        }
        OutAStringSexp(node);
    }
    public virtual void InAPlaceholderSexp(APlaceholderSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutAPlaceholderSexp(APlaceholderSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseAPlaceholderSexp(APlaceholderSexp node)
    {
        InAPlaceholderSexp(node);
        if(node.GetTPlaceholder() != null)
        {
            node.GetTPlaceholder().Apply(this);
        }
        OutAPlaceholderSexp(node);
    }
    public virtual void InAListSexp(AListSexp node)
    {
        DefaultIn(node);
    }

    public virtual void OutAListSexp(AListSexp node)
    {
        DefaultOut(node);
    }

    public override void CaseAListSexp(AListSexp node)
    {
        InAListSexp(node);
        {
            Object[] temp = new Object[node.GetSexp().Count];
            node.GetSexp().CopyTo(temp, 0);
            for(int i = temp.Length - 1; i >= 0; i--)
            {
                ((PSexp) temp[i]).Apply(this);
            }
        }
        if(node.GetTParenopen() != null)
        {
            node.GetTParenopen().Apply(this);
        }
        OutAListSexp(node);
    }
}
} // namespace Acrid.Toy.SableCC.analysis
